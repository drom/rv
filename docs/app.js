!function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,(function(r){return o(e[i][1][r]||r)}),p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}({1:[function(require,module,exports){"use strict";const getElement=require("./get-element.js"),mountCodeMirrorISA=require("./mount-code-mirror-isa.js"),mountInfoRenderer=require("./mount-info-renderer.js");window.RV=contentDiv=>{const content=getElement(contentDiv),isaDiv=document.createElement("div");content.append(isaDiv);const infoDiv=document.createElement("div");content.append(infoDiv);const infoRenderer=mountInfoRenderer(infoDiv);mountCodeMirrorISA(isaDiv,infoRenderer)}},{"./get-element.js":5,"./mount-code-mirror-isa.js":7,"./mount-info-renderer.js":8}],2:[function(require,module,exports){"use strict";const{StreamLanguage:StreamLanguage,syntaxHighlighting:syntaxHighlighting,HighlightStyle:HighlightStyle}=require("@codemirror/language"),{tags:tags}=require("@lezer/highlight");module.exports=()=>{return[StreamLanguage.define({startState:function(){return{state:0}},token:function(stream,stt){switch(stt.state){case 0:if(stream.match(/^[rR][vV]/))return stt.state=1,"namespace";break;case 1:if(stream.match(/^(32|64|128)/))return stt.state=2,"className";break;case 2:return stream.match(/^_/)?"comment":stream.match(/^z[a-zA-Z]+/)?(stt.state=3,"macroName"):stream.match(/^s[a-zA-Z]+/)?(stt.state=3,"propertyName"):stream.match(/^x[a-zA-Z]+/)?(stt.state=3,"labelName"):stream.match(/^[a-zA-Z]+/)?(stt.state=3,"typeName"):(stream.skipToEnd(),"comment");case 3:if(stream.match(/^\d+/))return stt.state=4,"number";stt.state=2;break;case 4:return stream.match(/^[pP]/)?(stt.state=5,"punctuation"):(stt.state=2,"comment");case 5:return stream.match(/^\d+/)?(stt.state=2,"number"):(stt.state=2,"comment");default:if(stream.match(/^\w/))return"comment"}return"comment"}}),syntaxHighlighting(HighlightStyle.define((t=tags,[{tag:[t.comment],color:"hsl(0,     0%, 30%)"},{tag:[t.namespace],color:"hsl(100, 100%, 90%)"},{tag:[t.className],color:"hsl(100, 100%, 90%)",fontWeight:"bold"},{tag:[t.punctuation],color:"hsl(56,    0%, 50%)"},{tag:[t.number],color:"hsl(56,    0%, 70%)"},{tag:[t.typeName],color:"hsl(210, 100%, 70%)"},{tag:[t.macroName],color:"hsl(150, 100%, 70%)"},{tag:[t.propertyName],color:"hsl( 70, 100%, 70%)"},{tag:[t.labelName],color:"hsl(  0, 100%, 70%)"}])))];var t}},{"@codemirror/language":10,"@lezer/highlight":14}],3:[function(require,module,exports){"use strict";const{EditorView:EditorView}=require("@codemirror/view"),extIsaTheme=EditorView.theme({"&":{color:"#fff",backgroundColor:"#222",padding:"4px",border:"1px solid #570;",borderRadius:"16px"},".cm-content":{caretColor:"#3ff",fontFamily:"Iosevka",lineHeight:1.5,fontSize:"24px",width:"100%"}},{dark:!0});module.exports=extIsaTheme},{"@codemirror/view":12}],4:[function(require,module,exports){"use strict";const exto={"32i":{id:"32i",ver:2.1,count:37,desc:"integer instructions. XLEN = 32"},zifencei:{id:"zifencei",ver:2,count:1,desc:"instruction-Fetch Fence"},zihintntl:{id:"zihintntl",ver:.2,desc:"Non-Temporal Locality Hints"},zihintpause:{id:"zihintpause",ver:2,desc:"Pause Hint"},"32e":{id:"32e",ver:2,count:37,desc:"Base Integer Instruction Set with 16 general-purpose registers. XLEN = 32"},"64e":{id:"64e",ver:2,count:49,desc:"Base Integer Instruction Set with 16 general-purpose registers. XLEN = 64"},"64i":{id:"64i",ver:2.1,count:49,desc:"Base Integer Instruction Set. XLEN = 64"},"128i":{id:"128i",ver:1.7,count:52,desc:"Base Integer Instruction Set. XLEN = 128"},m:{id:"m",ver:2,count:8,desc:"Standard Extension for Integer Multiplication and Division"},zmmul:{id:"zmmul",ver:1,count:4,desc:"Standard Extension for Integer Multiplication"},a:{id:"a",ver:2.1,count:11,desc:"Standard Extension for Atomic Instructions"},zicsr:{id:"zicsr",ver:2,count:6,desc:"Control and Status Register (CSR) Instructions"},zicntr:{id:"zicntr",ver:2.1,desc:"Standard Extension for Base Counters and Timers"},zihpm:{id:"zihpm",ver:2.1,desc:"Standard Extension for Hardware Performance Counters"},f:{id:"f",ver:2.2,count:26,desc:"Standard Extension for Single-Precision Floating-Point"},d:{id:"d",ver:2.2,desc:"Standard Extension for Double-Precision Floating-Point"},q:{id:"q",ver:2.2,desc:"Standard Extension for Quad-Precision Floating-Point"},zfh:{id:"zfh",ver:1,desc:"Standard Extension for Half-Precision Floating-Point"},zfhmin:{id:"zfhmin",ver:1,desc:"Standard Extension for Half-Precision Floating-Point"},c:{id:"c",ver:2,desc:"Standard Extension for Compressed Instructions"},b:{id:"b",ver:1,desc:"Standard Extension for Bit Manipulation"},zba:{id:"zba",ver:1,desc:"Bit Manipulation; Address generation instructions"},zbb:{id:"zbb",ver:1,desc:"Basic bit-manipulation"},zbc:{id:"zbc",ver:1,desc:"Bit Manipulation; Carry-less multiplication"},zbs:{id:"zbs",ver:1,desc:"Bit Manipulation; Single-bit instructions"},zbe:{id:"zbe",ver:0,desc:"Bit Manipulation"},zbf:{id:"zbf",ver:0,desc:"Bit Manipulation"},zbkb:{id:"zbkb",ver:0,desc:"Bit-manipulation for Cryptography"},zbkc:{id:"zbkc",ver:0,desc:"Bit Manipulation; Carry-less multiplication for Cryptography"},zbkx:{id:"zbkx",ver:0,desc:"Bit Manipulation; Crossbar permutations"},zk:{id:"zk",ver:0,desc:"Bit Manipulation"},zknh:{id:"zknh",ver:0,desc:"Bit Manipulation"},zkn:{id:"zkn",ver:0,desc:"Bit Manipulation"},zks:{id:"zks",ver:0,desc:"Bit Manipulation"},zksed:{id:"zksed",ver:0,desc:"Bit Manipulation"},zksh:{id:"zksh",ver:0,desc:"Bit Manipulation"},zknd:{id:"zknd",ver:0,desc:"Bit Manipulation"},zkne:{id:"zkne",ver:0,desc:"Bit Manipulation"},zbm:{id:"zbm",ver:0,desc:"Bit Manipulation"},zbp:{id:"zbp",ver:0,desc:"Bit Manipulation"},zbpbo:{id:"zbpbo",ver:0,desc:"Bit Manipulation"},zbr:{id:"zbr",ver:0,desc:"Bit Manipulation"},zbt:{id:"zbt",ver:0,desc:"Bit Manipulation"},zpn:{id:"zpn",ver:0,desc:"Standard Extension for Packed-SIMD Instructions"},zpsf:{id:"zpsf",ver:0,desc:"Standard Extension for Packed-SIMD Instructions"},v:{id:"v",ver:1,desc:"Standard Extension for Vector Operations"},zam:{id:"zam",ver:.1,desc:"Standard Extension for Misaligned Atomics"},zfinx:{id:"zfinx",ver:1,desc:"Standard Extension for single-precision Floating-Point in Integer Registers"},zdinx:{id:"zdinx",ver:1,desc:"Standard Extension for double-precision Floating-Point in Integer Registers"},zhinx:{id:"zhinx",ver:1,desc:"Standard Extension for half-precision Floating-Point in Integer Registers"},zhinxmin:{id:"zhinxmin",ver:1,desc:"Standard Extension for half-precision Floating-Point in Integer Registers"},zfa:{id:"zfa",ver:.1,desc:"Standard Extension for Additional Floating-Point Instructions"},ztso:{id:"ztso",ver:1,desc:"Standard Extension for Total Store Ordering"},svinval:{id:"svinval",ver:1,desc:"Standard Extension for Fine-Grained Address-Translation Cache Invalidation"},svnapot:{id:"svnapot",ver:1,desc:"Standard Extension for NAPOT Translation Contiguity"},svpbmt:{id:"svpbmt",ver:1,desc:"Standard Extension for Page-Based Memory Types"},sscofpmf:{id:"sscofpmf",ver:.5,desc:"Supervisor-level Count OverFlow and Privilege Mode Filtering"},zc:{id:"zc",ver:"1.0.2",desc:""},zcf:{id:"zcf",ver:2,desc:""},zcd:{id:"zcd",ver:"1.0.2",desc:""},zcb:{id:"zcb",ver:"1.0.2",desc:""},zcmp:{id:"zcmp",ver:"1.0.2",desc:""},zccmt:{id:"zccmt",ver:"1.0.2",desc:""},zicbom:{id:"zicbom",ver:"1.0.2",desc:"cache-block management instructions"},zicboz:{id:"zicboz",ver:"1.0.2",desc:"cache-block zero instruction"},zicbop:{id:"zicbop",ver:"1.0.2",desc:"prefetch hint pseudoinstructions"},zawrs:{id:"zawrs",ver:0,desc:"Wait-on-Reservation-Set extension"}};exto["32g"]=[exto["32i"],exto.m,exto.a,exto.f,exto.d,exto.zicsr,exto.zifencei],exto["64g"]=[exto["64i"],exto.m,exto.a,exto.f,exto.d,exto.zicsr,exto.zifencei],exto["128g"]=[exto["128i"],exto.m,exto.a,exto.f,exto.d,exto.zicsr,exto.zifencei],module.exports=exto},{}],5:[function(require,module,exports){"use strict";module.exports=divName=>{if("string"==typeof divName){const c=document.getElementById(divName);if(null===c)throw new Error('<div> element width Id: "'+divName+'" not found');return c}return divName}},{}],6:[function(require,module,exports){"use strict";module.exports={"@font-face":{"font-family":"Iosevka",src:"url(./iosevka-term-light.woff2) format(woff2)"},body:{"font-family":"'IBM Plex Sans', sans-serif",background:"#111",color:"#fff",height:"100%"},".error":{color:"#f30"},".row":{margin:"4px",padding:"4px",background:"#333"},".ext":{"font-weight":"bold",margin:"4px",padding:"2px 6px",background:"#000",color:"#3af"},".zext":{"font-weight":"bold",margin:"4px",padding:"2px 6px",background:"#000",color:"#3fa"},".xext":{"font-weight":"bold",margin:"4px",padding:"2px 6px",background:"#000",color:"#f30"},".sext":{"font-weight":"bold",margin:"4px",padding:"2px 6px",background:"#000",color:"#ff0"},".version":{margin:"4px",padding:"2px 6px",background:"#000",color:"#eee"},".ver":{margin:"4px",padding:"2px 6px",background:"#000",color:"#777"},".group":{margin:"8px",padding:"2px",background:"#222"},".group-head":{padding:"2px"},".count":{borderRadius:"16px",margin:"4px",padding:"2px 6px",background:"#555",color:"#ddd"}}},{}],7:[function(require,module,exports){"use strict";const{EditorState:EditorState}=require("@codemirror/state"),{EditorView:EditorView,keymap:keymap}=require("@codemirror/view"),{history:history,defaultKeymap:defaultKeymap,historyKeymap:historyKeymap}=require("@codemirror/commands"),extIsaTheme=require("./ext-isa-theme.js"),extIsaLangWith=require("./ext-isa-lang-with.js"),extRenderInfo=infoRenderer=>EditorView.updateListener.of((update=>{if(update.docChanged){const str=update.state.doc.toString();infoRenderer(str)}}));module.exports=(isaDiv,infoRenderer)=>{const isaState=EditorState.create({doc:"rv64i2p1ma2p1f2p2d2p2c_v1_zicsr_zifencei_sscofpmf0p1_zba1_zbb1_xpa_xpb1",extensions:[history(),keymap.of([...defaultKeymap,...historyKeymap]),EditorView.lineWrapping,extIsaTheme,extIsaLangWith(),extRenderInfo(infoRenderer)]});new EditorView({lineWrapping:!0,state:isaState,parent:isaDiv}),infoRenderer(isaState.doc.toString())}},{"./ext-isa-lang-with.js":2,"./ext-isa-theme.js":3,"@codemirror/commands":9,"@codemirror/state":11,"@codemirror/view":12}],8:[function(require,module,exports){"use strict";const renderer=require("onml/renderer"),{StyleModule:StyleModule}=require("style-mod"),infoTheme=require("./info-theme.js"),exto=require("./exto.js"),prefixes={z:"z",x:"x",s:"s"},ext=(o,root)=>{const{litera:litera,major:major,minor:minor}=o,extDesc=exto[litera];let res;Array.isArray(extDesc)?(res=["div",{class:"group"}],res.push(["span",{class:"ext"},litera]),major&&res.push(["span",{class:"version"},"v"+major+(minor?"."+minor:"")]),extDesc.map((e=>{const res1=["div",{class:"row"}];res1.push(["span",{class:(prefixes[e.id.toLowerCase()]||"")+"ext"},e.id]),e.ver&&res1.push(["span",{class:"ver"},"v"+e.ver]),e.count&&res1.push(["span",{class:"count"},e.count]),e.desc&&res1.push(["span",{class:"desc"},e.desc]),res.push(res1)}))):(res=["div",{class:"row"}],res.push(["span",{class:(prefixes[litera[0].toLowerCase()]||"")+"ext"},litera]),major?res.push(["span",{class:"version"},"v"+major+(minor?"."+minor:"")]):extDesc&&extDesc.ver&&res.push(["span",{class:"ver"},"v"+extDesc.ver]),extDesc&&extDesc.count&&res.push(["span",{class:"count"},extDesc.count]),extDesc&&extDesc.desc&&res.push(["span",{class:"desc"},extDesc.desc])),root.push(res)};module.exports=div=>{const themeAllMod=new StyleModule(infoTheme);StyleModule.mount(document,themeAllMod);const render=renderer(div);return str=>{render((str=>{const res=["div"];let pos=0;{const m=str.match(/^([Rr][Vv](?<litera>(32|64)[eEiIgG]|128[iIgG])((?<major>\d+)(p(?<minor>\d+))?)?)/);if(console.log(m),!m)return res.push(["div",["span",{class:"error"},"ERROR: ["+pos+"]"]," RISC-V ISA string must begin with either ",["span",{class:"ext"},"RV32I"],", ",["span",{class:"ext"},"RV32E"],", ",["span",{class:"ext"},"RV64I"],", or ",["span",{class:"ext"},"RV128I"]," indicating the supported address space size in bits for the base integer ISA."]),res;{const len=m[0].length;str=str.slice(len),pos+=len,ext(m.groups,res)}}for(;;){const m=str.match(/^_?(?<litera>[a-yA-Y])((?<major>\d+)(p(?<minor>\d+))?)?/);if(console.log(m),!m)break;const len=m[0].length;str=str.slice(len),pos+=len,ext(m.groups,res)}for(;;){const m=str.match(/^_(?<litera>[zZsS][a-yA-Y]+)((?<major>\d+)(p(?<minor>\d+))?)?/);if(console.log(m),!m)break;const len=m[0].length;str=str.slice(len),pos+=len,ext(m.groups,res)}for(;;){const m=str.match(/^_(?<litera>[xX][a-zA-Z]+)((?<major>\d+)(p(?<minor>\d+))?)?/);if(console.log(m),!m)break;const len=m[0].length;str=str.slice(len),pos+=len,ext(m.groups,res)}return res})(str))}}},{"./exto.js":4,"./info-theme.js":6,"onml/renderer":15,"style-mod":17}],9:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var state=require("@codemirror/state"),view=require("@codemirror/view"),language=require("@codemirror/language"),common=require("@lezer/common");const toggleComment=target=>{let config=getConfig(target.state);return config.line?toggleLineComment(target):!!config.block&&toggleBlockCommentByLine(target)};function command(f,option){return({state:state,dispatch:dispatch})=>{if(state.readOnly)return!1;let tr=f(option,state);return!!tr&&(dispatch(state.update(tr)),!0)}}const toggleLineComment=command(changeLineComment,0),lineComment=command(changeLineComment,1),lineUncomment=command(changeLineComment,2),toggleBlockComment=command(changeBlockComment,0),blockComment=command(changeBlockComment,1),blockUncomment=command(changeBlockComment,2),toggleBlockCommentByLine=command(((o,s)=>changeBlockComment(o,s,function(state){let ranges=[];for(let r of state.selection.ranges){let fromLine=state.doc.lineAt(r.from),toLine=r.to<=fromLine.to?fromLine:state.doc.lineAt(r.to),last=ranges.length-1;last>=0&&ranges[last].to>fromLine.from?ranges[last].to=toLine.to:ranges.push({from:fromLine.from,to:toLine.to})}return ranges}(s))),0);function getConfig(state,pos=state.selection.main.head){let data=state.languageDataAt("commentTokens",pos);return data.length?data[0]:{}}function changeBlockComment(option,state,ranges=state.selection.ranges){let tokens=ranges.map((r=>getConfig(state,r.from).block));if(!tokens.every((c=>c)))return null;let comments=ranges.map(((r,i)=>function(state,{open:open,close:close},from,to){let startText,endText,textBefore=state.sliceDoc(from-50,from),textAfter=state.sliceDoc(to,to+50),spaceBefore=/\s*$/.exec(textBefore)[0].length,spaceAfter=/^\s*/.exec(textAfter)[0].length,beforeOff=textBefore.length-spaceBefore;if(textBefore.slice(beforeOff-open.length,beforeOff)==open&&textAfter.slice(spaceAfter,spaceAfter+close.length)==close)return{open:{pos:from-spaceBefore,margin:spaceBefore&&1},close:{pos:to+spaceAfter,margin:spaceAfter&&1}};to-from<=100?startText=endText=state.sliceDoc(from,to):(startText=state.sliceDoc(from,from+50),endText=state.sliceDoc(to-50,to));let startSpace=/^\s*/.exec(startText)[0].length,endSpace=/\s*$/.exec(endText)[0].length,endOff=endText.length-endSpace-close.length;return startText.slice(startSpace,startSpace+open.length)==open&&endText.slice(endOff,endOff+close.length)==close?{open:{pos:from+startSpace+open.length,margin:/\s/.test(startText.charAt(startSpace+open.length))?1:0},close:{pos:to-endSpace-close.length,margin:/\s/.test(endText.charAt(endOff-1))?1:0}}:null}(state,tokens[i],r.from,r.to)));if(2!=option&&!comments.every((c=>c)))return{changes:state.changes(ranges.map(((range,i)=>comments[i]?[]:[{from:range.from,insert:tokens[i].open+" "},{from:range.to,insert:" "+tokens[i].close}])))};if(1!=option&&comments.some((c=>c))){let changes=[];for(let comment,i=0;i<comments.length;i++)if(comment=comments[i]){let token=tokens[i],{open:open,close:close}=comment;changes.push({from:open.pos-token.open.length,to:open.pos+open.margin},{from:close.pos-close.margin,to:close.pos+token.close.length})}return{changes:changes}}return null}function changeLineComment(option,state,ranges=state.selection.ranges){let lines=[],prevLine=-1;for(let{from:from,to:to}of ranges){let startI=lines.length,minIndent=1e9;for(let pos=from;pos<=to;){let line=state.doc.lineAt(pos);if(line.from>prevLine&&(from==to||to>line.from)){prevLine=line.from;let token=getConfig(state,pos).line;if(!token)continue;let indent=/^\s*/.exec(line.text)[0].length,empty=indent==line.length,comment=line.text.slice(indent,indent+token.length)==token?indent:-1;indent<line.text.length&&indent<minIndent&&(minIndent=indent),lines.push({line:line,comment:comment,token:token,indent:indent,empty:empty,single:!1})}pos=line.to+1}if(minIndent<1e9)for(let i=startI;i<lines.length;i++)lines[i].indent<lines[i].line.text.length&&(lines[i].indent=minIndent);lines.length==startI+1&&(lines[startI].single=!0)}if(2!=option&&lines.some((l=>l.comment<0&&(!l.empty||l.single)))){let changes=[];for(let{line:line,token:token,indent:indent,empty:empty,single:single}of lines)!single&&empty||changes.push({from:line.from+indent,insert:token+" "});let changeSet=state.changes(changes);return{changes:changeSet,selection:state.selection.map(changeSet,1)}}if(1!=option&&lines.some((l=>l.comment>=0))){let changes=[];for(let{line:line,comment:comment,token:token}of lines)if(comment>=0){let from=line.from+comment,to=from+token.length;" "==line.text[to-line.from]&&to++,changes.push({from:from,to:to})}return{changes:changes}}return null}const fromHistory=state.Annotation.define(),isolateHistory=state.Annotation.define(),invertedEffects=state.Facet.define(),historyConfig=state.Facet.define({combine:configs=>state.combineConfig(configs,{minDepth:100,newGroupDelay:500,joinToEvent:(_t,isAdjacent)=>isAdjacent},{minDepth:Math.max,newGroupDelay:Math.min,joinToEvent:(a,b)=>(tr,adj)=>a(tr,adj)||b(tr,adj)})});const historyField_=state.StateField.define({create:()=>HistoryState.empty,update(state$1,tr){let config=tr.state.facet(historyConfig),fromHist=tr.annotation(fromHistory);if(fromHist){let selection=tr.docChanged?state.EditorSelection.single(function(changes){let end=0;return changes.iterChangedRanges(((_,to)=>end=to)),end}(tr.changes)):void 0,item=HistEvent.fromTransaction(tr,selection),from=fromHist.side,other=0==from?state$1.undone:state$1.done;return other=item?updateBranch(other,other.length,config.minDepth,item):addSelection(other,tr.startState.selection),new HistoryState(0==from?fromHist.rest:other,0==from?other:fromHist.rest)}let isolate=tr.annotation(isolateHistory);if("full"!=isolate&&"before"!=isolate||(state$1=state$1.isolate()),!1===tr.annotation(state.Transaction.addToHistory))return tr.changes.empty?state$1:state$1.addMapping(tr.changes.desc);let event=HistEvent.fromTransaction(tr),time=tr.annotation(state.Transaction.time),userEvent=tr.annotation(state.Transaction.userEvent);return event?state$1=state$1.addChanges(event,time,userEvent,config,tr):tr.selection&&(state$1=state$1.addSelection(tr.startState.selection,time,userEvent,config.newGroupDelay)),"full"!=isolate&&"after"!=isolate||(state$1=state$1.isolate()),state$1},toJSON:value=>({done:value.done.map((e=>e.toJSON())),undone:value.undone.map((e=>e.toJSON()))}),fromJSON:json=>new HistoryState(json.done.map(HistEvent.fromJSON),json.undone.map(HistEvent.fromJSON))});const historyField=historyField_;function cmd(side,selection){return function({state:state,dispatch:dispatch}){if(!selection&&state.readOnly)return!1;let historyState=state.field(historyField_,!1);if(!historyState)return!1;let tr=historyState.pop(side,state,selection);return!!tr&&(dispatch(tr),!0)}}const undo=cmd(0,!1),redo=cmd(1,!1),undoSelection=cmd(0,!0),redoSelection=cmd(1,!0);function depth(side){return function(state){let histState=state.field(historyField_,!1);if(!histState)return 0;let branch=0==side?histState.done:histState.undone;return branch.length-(branch.length&&!branch[0].changes?1:0)}}const undoDepth=depth(0),redoDepth=depth(1);class HistEvent{constructor(changes,effects,mapped,startSelection,selectionsAfter){this.changes=changes,this.effects=effects,this.mapped=mapped,this.startSelection=startSelection,this.selectionsAfter=selectionsAfter}setSelAfter(after){return new HistEvent(this.changes,this.effects,this.mapped,this.startSelection,after)}toJSON(){var _a,_b,_c;return{changes:null===(_a=this.changes)||void 0===_a?void 0:_a.toJSON(),mapped:null===(_b=this.mapped)||void 0===_b?void 0:_b.toJSON(),startSelection:null===(_c=this.startSelection)||void 0===_c?void 0:_c.toJSON(),selectionsAfter:this.selectionsAfter.map((s=>s.toJSON()))}}static fromJSON(json){return new HistEvent(json.changes&&state.ChangeSet.fromJSON(json.changes),[],json.mapped&&state.ChangeDesc.fromJSON(json.mapped),json.startSelection&&state.EditorSelection.fromJSON(json.startSelection),json.selectionsAfter.map(state.EditorSelection.fromJSON))}static fromTransaction(tr,selection){let effects=none;for(let invert of tr.startState.facet(invertedEffects)){let result=invert(tr);result.length&&(effects=effects.concat(result))}return!effects.length&&tr.changes.empty?null:new HistEvent(tr.changes.invert(tr.startState.doc),effects,void 0,selection||tr.startState.selection,none)}static selection(selections){return new HistEvent(void 0,none,void 0,void 0,selections)}}function updateBranch(branch,to,maxLen,newEvent){let start=to+1>maxLen+20?to-maxLen-1:0,newBranch=branch.slice(start,to);return newBranch.push(newEvent),newBranch}function conc(a,b){return a.length?b.length?a.concat(b):a:b}const none=[];function addSelection(branch,selection){if(branch.length){let lastEvent=branch[branch.length-1],sels=lastEvent.selectionsAfter.slice(Math.max(0,lastEvent.selectionsAfter.length-200));return sels.length&&sels[sels.length-1].eq(selection)?branch:(sels.push(selection),updateBranch(branch,branch.length-1,1e9,lastEvent.setSelAfter(sels)))}return[HistEvent.selection([selection])]}function popSelection(branch){let last=branch[branch.length-1],newBranch=branch.slice();return newBranch[branch.length-1]=last.setSelAfter(last.selectionsAfter.slice(0,last.selectionsAfter.length-1)),newBranch}function addMappingToBranch(branch,mapping){if(!branch.length)return branch;let length=branch.length,selections=none;for(;length;){let event=mapEvent(branch[length-1],mapping,selections);if(event.changes&&!event.changes.empty||event.effects.length){let result=branch.slice(0,length);return result[length-1]=event,result}mapping=event.mapped,length--,selections=event.selectionsAfter}return selections.length?[HistEvent.selection(selections)]:none}function mapEvent(event,mapping,extraSelections){let selections=conc(event.selectionsAfter.length?event.selectionsAfter.map((s=>s.map(mapping))):none,extraSelections);if(!event.changes)return HistEvent.selection(selections);let mappedChanges=event.changes.map(mapping),before=mapping.mapDesc(event.changes,!0),fullMapping=event.mapped?event.mapped.composeDesc(before):before;return new HistEvent(mappedChanges,state.StateEffect.mapEffects(event.effects,mapping),fullMapping,event.startSelection.map(before),selections)}const joinableUserEvent=/^(input\.type|delete)($|\.)/;class HistoryState{constructor(done,undone,prevTime=0,prevUserEvent){this.done=done,this.undone=undone,this.prevTime=prevTime,this.prevUserEvent=prevUserEvent}isolate(){return this.prevTime?new HistoryState(this.done,this.undone):this}addChanges(event,time,userEvent,config,tr){let done=this.done,lastEvent=done[done.length-1];return done=lastEvent&&lastEvent.changes&&!lastEvent.changes.empty&&event.changes&&(!userEvent||joinableUserEvent.test(userEvent))&&(!lastEvent.selectionsAfter.length&&time-this.prevTime<config.newGroupDelay&&config.joinToEvent(tr,function(a,b){let ranges=[],isAdjacent=!1;return a.iterChangedRanges(((f,t)=>ranges.push(f,t))),b.iterChangedRanges(((_f,_t,f,t)=>{for(let i=0;i<ranges.length;){let from=ranges[i++],to=ranges[i++];t>=from&&f<=to&&(isAdjacent=!0)}})),isAdjacent}(lastEvent.changes,event.changes))||"input.type.compose"==userEvent)?updateBranch(done,done.length-1,config.minDepth,new HistEvent(event.changes.compose(lastEvent.changes),conc(event.effects,lastEvent.effects),lastEvent.mapped,lastEvent.startSelection,none)):updateBranch(done,done.length,config.minDepth,event),new HistoryState(done,none,time,userEvent)}addSelection(selection,time,userEvent,newGroupDelay){let last=this.done.length?this.done[this.done.length-1].selectionsAfter:none;return last.length>0&&time-this.prevTime<newGroupDelay&&userEvent==this.prevUserEvent&&userEvent&&/^select($|\.)/.test(userEvent)&&(a=last[last.length-1],b=selection,a.ranges.length==b.ranges.length&&0===a.ranges.filter(((r,i)=>r.empty!=b.ranges[i].empty)).length)?this:new HistoryState(addSelection(this.done,selection),this.undone,time,userEvent);var a,b}addMapping(mapping){return new HistoryState(addMappingToBranch(this.done,mapping),addMappingToBranch(this.undone,mapping),this.prevTime,this.prevUserEvent)}pop(side,state,selection){let branch=0==side?this.done:this.undone;if(0==branch.length)return null;let event=branch[branch.length-1];if(selection&&event.selectionsAfter.length)return state.update({selection:event.selectionsAfter[event.selectionsAfter.length-1],annotations:fromHistory.of({side:side,rest:popSelection(branch)}),userEvent:0==side?"select.undo":"select.redo",scrollIntoView:!0});if(event.changes){let rest=1==branch.length?none:branch.slice(0,branch.length-1);return event.mapped&&(rest=addMappingToBranch(rest,event.mapped)),state.update({changes:event.changes,selection:event.startSelection,effects:event.effects,annotations:fromHistory.of({side:side,rest:rest}),filter:!1,userEvent:0==side?"undo":"redo",scrollIntoView:!0})}return null}}HistoryState.empty=new HistoryState(none,none);const historyKeymap=[{key:"Mod-z",run:undo,preventDefault:!0},{key:"Mod-y",mac:"Mod-Shift-z",run:redo,preventDefault:!0},{linux:"Ctrl-Shift-z",run:redo,preventDefault:!0},{key:"Mod-u",run:undoSelection,preventDefault:!0},{key:"Alt-u",mac:"Mod-Shift-u",run:redoSelection,preventDefault:!0}];function updateSel(sel,by){return state.EditorSelection.create(sel.ranges.map(by),sel.mainIndex)}function setSel(state,selection){return state.update({selection:selection,scrollIntoView:!0,userEvent:"select"})}function moveSel({state:state,dispatch:dispatch},how){let selection=updateSel(state.selection,how);return!selection.eq(state.selection)&&(dispatch(setSel(state,selection)),!0)}function rangeEnd(range,forward){return state.EditorSelection.cursor(forward?range.to:range.from)}function cursorByChar(view,forward){return moveSel(view,(range=>range.empty?view.moveByChar(range,forward):rangeEnd(range,forward)))}function ltrAtCursor(view$1){return view$1.textDirectionAt(view$1.state.selection.main.head)==view.Direction.LTR}const cursorCharLeft=view=>cursorByChar(view,!ltrAtCursor(view)),cursorCharRight=view=>cursorByChar(view,ltrAtCursor(view));function cursorByGroup(view,forward){return moveSel(view,(range=>range.empty?view.moveByGroup(range,forward):rangeEnd(range,forward)))}const cursorGroupLeft=view=>cursorByGroup(view,!ltrAtCursor(view)),cursorGroupRight=view=>cursorByGroup(view,ltrAtCursor(view));function moveBySubword(view,range,forward){let categorize=view.state.charCategorizer(range.from);return view.moveByChar(range,forward,(start=>{let cat=state.CharCategory.Space,pos=range.from,done=!1,sawUpper=!1,sawLower=!1,step=next=>{if(done)return!1;pos+=forward?next.length:-next.length;let ahead,nextCat=categorize(next);if(cat==state.CharCategory.Space&&(cat=nextCat),cat!=nextCat)return!1;if(cat==state.CharCategory.Word)if(next.toLowerCase()==next){if(!forward&&sawUpper)return!1;sawLower=!0}else if(sawLower){if(forward)return!1;done=!0}else{if(sawUpper&&forward&&categorize(ahead=view.state.sliceDoc(pos,pos+1))==state.CharCategory.Word&&ahead.toLowerCase()==ahead)return!1;sawUpper=!0}return!0};return step(start),step}))}function cursorBySubword(view,forward){return moveSel(view,(range=>range.empty?moveBySubword(view,range,forward):rangeEnd(range,forward)))}function interestingNode(state,node,bracketProp){if(node.type.prop(bracketProp))return!0;let len=node.to-node.from;return len&&(len>2||/[^\s,.;:]/.test(state.sliceDoc(node.from,node.to)))||node.firstChild}function moveBySyntax(state$1,start,forward){let match,newPos,pos=language.syntaxTree(state$1).resolveInner(start.head),bracketProp=forward?common.NodeProp.closedBy:common.NodeProp.openedBy;for(let at=start.head;;){let next=forward?pos.childAfter(at):pos.childBefore(at);if(!next)break;interestingNode(state$1,next,bracketProp)?pos=next:at=forward?next.to:next.from}return newPos=pos.type.prop(bracketProp)&&(match=forward?language.matchBrackets(state$1,pos.from,1):language.matchBrackets(state$1,pos.to,-1))&&match.matched?forward?match.end.to:match.end.from:forward?pos.to:pos.from,state.EditorSelection.cursor(newPos,forward?-1:1)}const cursorSyntaxLeft=view=>moveSel(view,(range=>moveBySyntax(view.state,range,!ltrAtCursor(view)))),cursorSyntaxRight=view=>moveSel(view,(range=>moveBySyntax(view.state,range,ltrAtCursor(view))));function cursorByLine(view,forward){return moveSel(view,(range=>{if(!range.empty)return rangeEnd(range,forward);let moved=view.moveVertically(range,forward);return moved.head!=range.head?moved:view.moveToLineBoundary(range,forward)}))}const cursorLineUp=view=>cursorByLine(view,!1),cursorLineDown=view=>cursorByLine(view,!0);function pageHeight(view){return Math.max(view.defaultLineHeight,Math.min(view.dom.clientHeight,innerHeight)-5)}function cursorByPage(view$1,forward){let{state:state}=view$1,selection=updateSel(state.selection,(range=>range.empty?view$1.moveVertically(range,forward,pageHeight(view$1)):rangeEnd(range,forward)));if(selection.eq(state.selection))return!1;let effect,startPos=view$1.coordsAtPos(state.selection.main.head),scrollRect=view$1.scrollDOM.getBoundingClientRect();return startPos&&startPos.top>scrollRect.top&&startPos.bottom<scrollRect.bottom&&startPos.top-scrollRect.top<=view$1.scrollDOM.scrollHeight-view$1.scrollDOM.scrollTop-view$1.scrollDOM.clientHeight&&(effect=view.EditorView.scrollIntoView(selection.main.head,{y:"start",yMargin:startPos.top-scrollRect.top})),view$1.dispatch(setSel(state,selection),{effects:effect}),!0}const cursorPageUp=view=>cursorByPage(view,!1),cursorPageDown=view=>cursorByPage(view,!0);function moveByLineBoundary(view,start,forward){let line=view.lineBlockAt(start.head),moved=view.moveToLineBoundary(start,forward);if(moved.head==start.head&&moved.head!=(forward?line.to:line.from)&&(moved=view.moveToLineBoundary(start,forward,!1)),!forward&&moved.head==line.from&&line.length){let space=/^\s*/.exec(view.state.sliceDoc(line.from,Math.min(line.from+100,line.to)))[0].length;space&&start.head!=line.from+space&&(moved=state.EditorSelection.cursor(line.from+space))}return moved}const cursorLineBoundaryForward=view=>moveSel(view,(range=>moveByLineBoundary(view,range,!0))),cursorLineBoundaryBackward=view=>moveSel(view,(range=>moveByLineBoundary(view,range,!1))),cursorLineBoundaryLeft=view=>moveSel(view,(range=>moveByLineBoundary(view,range,!ltrAtCursor(view)))),cursorLineBoundaryRight=view=>moveSel(view,(range=>moveByLineBoundary(view,range,ltrAtCursor(view)))),cursorLineStart=view=>moveSel(view,(range=>state.EditorSelection.cursor(view.lineBlockAt(range.head).from,1))),cursorLineEnd=view=>moveSel(view,(range=>state.EditorSelection.cursor(view.lineBlockAt(range.head).to,-1)));function toMatchingBracket(state$1,dispatch,extend){let found=!1,selection=updateSel(state$1.selection,(range=>{let matching=language.matchBrackets(state$1,range.head,-1)||language.matchBrackets(state$1,range.head,1)||range.head>0&&language.matchBrackets(state$1,range.head-1,1)||range.head<state$1.doc.length&&language.matchBrackets(state$1,range.head+1,-1);if(!matching||!matching.end)return range;found=!0;let head=matching.start.from==range.head?matching.end.to:matching.end.from;return extend?state.EditorSelection.range(range.anchor,head):state.EditorSelection.cursor(head)}));return!!found&&(dispatch(setSel(state$1,selection)),!0)}const cursorMatchingBracket=({state:state,dispatch:dispatch})=>toMatchingBracket(state,dispatch,!1);function extendSel(view,how){let selection=updateSel(view.state.selection,(range=>{let head=how(range);return state.EditorSelection.range(range.anchor,head.head,head.goalColumn,head.bidiLevel||void 0)}));return!selection.eq(view.state.selection)&&(view.dispatch(setSel(view.state,selection)),!0)}function selectByChar(view,forward){return extendSel(view,(range=>view.moveByChar(range,forward)))}const selectCharLeft=view=>selectByChar(view,!ltrAtCursor(view)),selectCharRight=view=>selectByChar(view,ltrAtCursor(view));function selectByGroup(view,forward){return extendSel(view,(range=>view.moveByGroup(range,forward)))}const selectGroupLeft=view=>selectByGroup(view,!ltrAtCursor(view)),selectGroupRight=view=>selectByGroup(view,ltrAtCursor(view));function selectBySubword(view,forward){return extendSel(view,(range=>moveBySubword(view,range,forward)))}const selectSyntaxLeft=view=>extendSel(view,(range=>moveBySyntax(view.state,range,!ltrAtCursor(view)))),selectSyntaxRight=view=>extendSel(view,(range=>moveBySyntax(view.state,range,ltrAtCursor(view))));function selectByLine(view,forward){return extendSel(view,(range=>view.moveVertically(range,forward)))}const selectLineUp=view=>selectByLine(view,!1),selectLineDown=view=>selectByLine(view,!0);function selectByPage(view,forward){return extendSel(view,(range=>view.moveVertically(range,forward,pageHeight(view))))}const selectPageUp=view=>selectByPage(view,!1),selectPageDown=view=>selectByPage(view,!0),selectLineBoundaryForward=view=>extendSel(view,(range=>moveByLineBoundary(view,range,!0))),selectLineBoundaryBackward=view=>extendSel(view,(range=>moveByLineBoundary(view,range,!1))),selectLineBoundaryLeft=view=>extendSel(view,(range=>moveByLineBoundary(view,range,!ltrAtCursor(view)))),selectLineBoundaryRight=view=>extendSel(view,(range=>moveByLineBoundary(view,range,ltrAtCursor(view)))),selectLineStart=view=>extendSel(view,(range=>state.EditorSelection.cursor(view.lineBlockAt(range.head).from))),selectLineEnd=view=>extendSel(view,(range=>state.EditorSelection.cursor(view.lineBlockAt(range.head).to))),cursorDocStart=({state:state,dispatch:dispatch})=>(dispatch(setSel(state,{anchor:0})),!0),cursorDocEnd=({state:state,dispatch:dispatch})=>(dispatch(setSel(state,{anchor:state.doc.length})),!0),selectDocStart=({state:state,dispatch:dispatch})=>(dispatch(setSel(state,{anchor:state.selection.main.anchor,head:0})),!0),selectDocEnd=({state:state,dispatch:dispatch})=>(dispatch(setSel(state,{anchor:state.selection.main.anchor,head:state.doc.length})),!0),selectAll=({state:state,dispatch:dispatch})=>(dispatch(state.update({selection:{anchor:0,head:state.doc.length},userEvent:"select"})),!0),selectLine=({state:state$1,dispatch:dispatch})=>{let ranges=selectedLineBlocks(state$1).map((({from:from,to:to})=>state.EditorSelection.range(from,Math.min(to+1,state$1.doc.length))));return dispatch(state$1.update({selection:state.EditorSelection.create(ranges),userEvent:"select"})),!0},selectParentSyntax=({state:state$1,dispatch:dispatch})=>{let selection=updateSel(state$1.selection,(range=>{var _a;let context=language.syntaxTree(state$1).resolveInner(range.head,1);for(;!(context.from<range.from&&context.to>=range.to||context.to>range.to&&context.from<=range.from)&&(null===(_a=context.parent)||void 0===_a?void 0:_a.parent);)context=context.parent;return state.EditorSelection.range(context.to,context.from)}));return dispatch(setSel(state$1,selection)),!0},simplifySelection=({state:state$1,dispatch:dispatch})=>{let cur=state$1.selection,selection=null;return cur.ranges.length>1?selection=state.EditorSelection.create([cur.main]):cur.main.empty||(selection=state.EditorSelection.create([state.EditorSelection.cursor(cur.main.head)])),!!selection&&(dispatch(setSel(state$1,selection)),!0)};function deleteBy(target,by){if(target.state.readOnly)return!1;let event="delete.selection",{state:state$1}=target,changes=state$1.changeByRange((range=>{let{from:from,to:to}=range;if(from==to){let towards=by(from);towards<from?(event="delete.backward",towards=skipAtomic(target,towards,!1)):towards>from&&(event="delete.forward",towards=skipAtomic(target,towards,!0)),from=Math.min(from,towards),to=Math.max(to,towards)}else from=skipAtomic(target,from,!1),to=skipAtomic(target,to,!0);return from==to?{range:range}:{changes:{from:from,to:to},range:state.EditorSelection.cursor(from)}}));return!changes.changes.empty&&(target.dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:event,effects:"delete.selection"==event?view.EditorView.announce.of(state$1.phrase("Selection deleted")):void 0})),!0)}function skipAtomic(target,pos,forward){if(target instanceof view.EditorView)for(let ranges of target.state.facet(view.EditorView.atomicRanges).map((f=>f(target))))ranges.between(pos,pos,((from,to)=>{from<pos&&to>pos&&(pos=forward?to:from)}));return pos}const deleteByChar=(target,forward)=>deleteBy(target,(pos=>{let before,targetPos,{state:state$1}=target,line=state$1.doc.lineAt(pos);if(!forward&&pos>line.from&&pos<line.from+200&&!/[^ \t]/.test(before=line.text.slice(0,pos-line.from))){if("\t"==before[before.length-1])return pos-1;let drop=state.countColumn(before,state$1.tabSize)%language.getIndentUnit(state$1)||language.getIndentUnit(state$1);for(let i=0;i<drop&&" "==before[before.length-1-i];i++)pos--;targetPos=pos}else targetPos=state.findClusterBreak(line.text,pos-line.from,forward,forward)+line.from,targetPos==pos&&line.number!=(forward?state$1.doc.lines:1)&&(targetPos+=forward?1:-1);return targetPos})),deleteCharBackward=view=>deleteByChar(view,!1),deleteCharForward=view=>deleteByChar(view,!0),deleteByGroup=(target,forward)=>deleteBy(target,(start=>{let pos=start,{state:state$1}=target,line=state$1.doc.lineAt(pos),categorize=state$1.charCategorizer(pos);for(let cat=null;;){if(pos==(forward?line.to:line.from)){pos==start&&line.number!=(forward?state$1.doc.lines:1)&&(pos+=forward?1:-1);break}let next=state.findClusterBreak(line.text,pos-line.from,forward)+line.from,nextChar=line.text.slice(Math.min(pos,next)-line.from,Math.max(pos,next)-line.from),nextCat=categorize(nextChar);if(null!=cat&&nextCat!=cat)break;" "==nextChar&&pos==start||(cat=nextCat),pos=next}return pos})),deleteGroupBackward=target=>deleteByGroup(target,!1),deleteGroupForward=target=>deleteByGroup(target,!0),deleteToLineEnd=view=>deleteBy(view,(pos=>{let lineEnd=view.lineBlockAt(pos).to;return pos<lineEnd?lineEnd:Math.min(view.state.doc.length,pos+1)})),deleteToLineStart=view=>deleteBy(view,(pos=>{let lineStart=view.lineBlockAt(pos).from;return pos>lineStart?lineStart:Math.max(0,pos-1)})),splitLine=({state:state$1,dispatch:dispatch})=>{if(state$1.readOnly)return!1;let changes=state$1.changeByRange((range=>({changes:{from:range.from,to:range.to,insert:state.Text.of(["",""])},range:state.EditorSelection.cursor(range.from)})));return dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"input"})),!0},transposeChars=({state:state$1,dispatch:dispatch})=>{if(state$1.readOnly)return!1;let changes=state$1.changeByRange((range=>{if(!range.empty||0==range.from||range.from==state$1.doc.length)return{range:range};let pos=range.from,line=state$1.doc.lineAt(pos),from=pos==line.from?pos-1:state.findClusterBreak(line.text,pos-line.from,!1)+line.from,to=pos==line.to?pos+1:state.findClusterBreak(line.text,pos-line.from,!0)+line.from;return{changes:{from:from,to:to,insert:state$1.doc.slice(pos,to).append(state$1.doc.slice(from,pos))},range:state.EditorSelection.cursor(to)}}));return!changes.changes.empty&&(dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"move.character"})),!0)};function selectedLineBlocks(state){let blocks=[],upto=-1;for(let range of state.selection.ranges){let startLine=state.doc.lineAt(range.from),endLine=state.doc.lineAt(range.to);if(range.empty||range.to!=endLine.from||(endLine=state.doc.lineAt(range.to-1)),upto>=startLine.number){let prev=blocks[blocks.length-1];prev.to=endLine.to,prev.ranges.push(range)}else blocks.push({from:startLine.from,to:endLine.to,ranges:[range]});upto=endLine.number+1}return blocks}function moveLine(state$1,dispatch,forward){if(state$1.readOnly)return!1;let changes=[],ranges=[];for(let block of selectedLineBlocks(state$1)){if(forward?block.to==state$1.doc.length:0==block.from)continue;let nextLine=state$1.doc.lineAt(forward?block.to+1:block.from-1),size=nextLine.length+1;if(forward){changes.push({from:block.to,to:nextLine.to},{from:block.from,insert:nextLine.text+state$1.lineBreak});for(let r of block.ranges)ranges.push(state.EditorSelection.range(Math.min(state$1.doc.length,r.anchor+size),Math.min(state$1.doc.length,r.head+size)))}else{changes.push({from:nextLine.from,to:block.from},{from:block.to,insert:state$1.lineBreak+nextLine.text});for(let r of block.ranges)ranges.push(state.EditorSelection.range(r.anchor-size,r.head-size))}}return!!changes.length&&(dispatch(state$1.update({changes:changes,scrollIntoView:!0,selection:state.EditorSelection.create(ranges,state$1.selection.mainIndex),userEvent:"move.line"})),!0)}const moveLineUp=({state:state,dispatch:dispatch})=>moveLine(state,dispatch,!1),moveLineDown=({state:state,dispatch:dispatch})=>moveLine(state,dispatch,!0);function copyLine(state,dispatch,forward){if(state.readOnly)return!1;let changes=[];for(let block of selectedLineBlocks(state))forward?changes.push({from:block.from,insert:state.doc.slice(block.from,block.to)+state.lineBreak}):changes.push({from:block.to,insert:state.lineBreak+state.doc.slice(block.from,block.to)});return dispatch(state.update({changes:changes,scrollIntoView:!0,userEvent:"input.copyline"})),!0}const copyLineUp=({state:state,dispatch:dispatch})=>copyLine(state,dispatch,!1),copyLineDown=({state:state,dispatch:dispatch})=>copyLine(state,dispatch,!0),deleteLine=view=>{if(view.state.readOnly)return!1;let{state:state}=view,changes=state.changes(selectedLineBlocks(state).map((({from:from,to:to})=>(from>0?from--:to<state.doc.length&&to++,{from:from,to:to})))),selection=updateSel(state.selection,(range=>view.moveVertically(range,!0))).map(changes);return view.dispatch({changes:changes,selection:selection,scrollIntoView:!0,userEvent:"delete.line"}),!0};const insertNewlineAndIndent=newlineAndIndent(!1),insertBlankLine=newlineAndIndent(!0);function newlineAndIndent(atEof){return({state:state$1,dispatch:dispatch})=>{if(state$1.readOnly)return!1;let changes=state$1.changeByRange((range=>{let{from:from,to:to}=range,line=state$1.doc.lineAt(from),explode=!atEof&&from==to&&function(state,pos){if(/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos-1,pos+1)))return{from:pos,to:pos};let closedBy,context=language.syntaxTree(state).resolveInner(pos),before=context.childBefore(pos),after=context.childAfter(pos);return before&&after&&before.to<=pos&&after.from>=pos&&(closedBy=before.type.prop(common.NodeProp.closedBy))&&closedBy.indexOf(after.name)>-1&&state.doc.lineAt(before.to).from==state.doc.lineAt(after.from).from?{from:before.to,to:after.from}:null}(state$1,from);atEof&&(from=to=(to<=line.to?line:state$1.doc.lineAt(to)).to);let cx=new language.IndentContext(state$1,{simulateBreak:from,simulateDoubleBreak:!!explode}),indent=language.getIndentation(cx,from);for(null==indent&&(indent=/^\s*/.exec(state$1.doc.lineAt(from).text)[0].length);to<line.to&&/\s/.test(line.text[to-line.from]);)to++;explode?({from:from,to:to}=explode):from>line.from&&from<line.from+100&&!/\S/.test(line.text.slice(0,from))&&(from=line.from);let insert=["",language.indentString(state$1,indent)];return explode&&insert.push(language.indentString(state$1,cx.lineIndent(line.from,-1))),{changes:{from:from,to:to,insert:state.Text.of(insert)},range:state.EditorSelection.cursor(from+1+insert[1].length)}}));return dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"input"})),!0}}function changeBySelectedLine(state$1,f){let atLine=-1;return state$1.changeByRange((range=>{let changes=[];for(let pos=range.from;pos<=range.to;){let line=state$1.doc.lineAt(pos);line.number>atLine&&(range.empty||range.to>line.from)&&(f(line,changes,range),atLine=line.number),pos=line.to+1}let changeSet=state$1.changes(changes);return{changes:changes,range:state.EditorSelection.range(changeSet.mapPos(range.anchor,1),changeSet.mapPos(range.head,1))}}))}const indentSelection=({state:state,dispatch:dispatch})=>{if(state.readOnly)return!1;let updated=Object.create(null),context=new language.IndentContext(state,{overrideIndentation:start=>{let found=updated[start];return null==found?-1:found}}),changes=changeBySelectedLine(state,((line,changes,range)=>{let indent=language.getIndentation(context,line.from);if(null==indent)return;/\S/.test(line.text)||(indent=0);let cur=/^\s*/.exec(line.text)[0],norm=language.indentString(state,indent);(cur!=norm||range.from<line.from+cur.length)&&(updated[line.from]=indent,changes.push({from:line.from,to:line.from+cur.length,insert:norm}))}));return changes.changes.empty||dispatch(state.update(changes,{userEvent:"indent"})),!0},indentMore=({state:state,dispatch:dispatch})=>!state.readOnly&&(dispatch(state.update(changeBySelectedLine(state,((line,changes)=>{changes.push({from:line.from,insert:state.facet(language.indentUnit)})})),{userEvent:"input.indent"})),!0),indentLess=({state:state$1,dispatch:dispatch})=>!state$1.readOnly&&(dispatch(state$1.update(changeBySelectedLine(state$1,((line,changes)=>{let space=/^\s*/.exec(line.text)[0];if(!space)return;let col=state.countColumn(space,state$1.tabSize),keep=0,insert=language.indentString(state$1,Math.max(0,col-language.getIndentUnit(state$1)));for(;keep<space.length&&keep<insert.length&&space.charCodeAt(keep)==insert.charCodeAt(keep);)keep++;changes.push({from:line.from+keep,to:line.from+space.length,insert:insert.slice(keep)})})),{userEvent:"delete.dedent"})),!0),emacsStyleKeymap=[{key:"Ctrl-b",run:cursorCharLeft,shift:selectCharLeft,preventDefault:!0},{key:"Ctrl-f",run:cursorCharRight,shift:selectCharRight},{key:"Ctrl-p",run:cursorLineUp,shift:selectLineUp},{key:"Ctrl-n",run:cursorLineDown,shift:selectLineDown},{key:"Ctrl-a",run:cursorLineStart,shift:selectLineStart},{key:"Ctrl-e",run:cursorLineEnd,shift:selectLineEnd},{key:"Ctrl-d",run:deleteCharForward},{key:"Ctrl-h",run:deleteCharBackward},{key:"Ctrl-k",run:deleteToLineEnd},{key:"Ctrl-Alt-h",run:deleteGroupBackward},{key:"Ctrl-o",run:splitLine},{key:"Ctrl-t",run:transposeChars},{key:"Ctrl-v",run:cursorPageDown}],standardKeymap=[{key:"ArrowLeft",run:cursorCharLeft,shift:selectCharLeft,preventDefault:!0},{key:"Mod-ArrowLeft",mac:"Alt-ArrowLeft",run:cursorGroupLeft,shift:selectGroupLeft,preventDefault:!0},{mac:"Cmd-ArrowLeft",run:cursorLineBoundaryLeft,shift:selectLineBoundaryLeft,preventDefault:!0},{key:"ArrowRight",run:cursorCharRight,shift:selectCharRight,preventDefault:!0},{key:"Mod-ArrowRight",mac:"Alt-ArrowRight",run:cursorGroupRight,shift:selectGroupRight,preventDefault:!0},{mac:"Cmd-ArrowRight",run:cursorLineBoundaryRight,shift:selectLineBoundaryRight,preventDefault:!0},{key:"ArrowUp",run:cursorLineUp,shift:selectLineUp,preventDefault:!0},{mac:"Cmd-ArrowUp",run:cursorDocStart,shift:selectDocStart},{mac:"Ctrl-ArrowUp",run:cursorPageUp,shift:selectPageUp},{key:"ArrowDown",run:cursorLineDown,shift:selectLineDown,preventDefault:!0},{mac:"Cmd-ArrowDown",run:cursorDocEnd,shift:selectDocEnd},{mac:"Ctrl-ArrowDown",run:cursorPageDown,shift:selectPageDown},{key:"PageUp",run:cursorPageUp,shift:selectPageUp},{key:"PageDown",run:cursorPageDown,shift:selectPageDown},{key:"Home",run:cursorLineBoundaryBackward,shift:selectLineBoundaryBackward,preventDefault:!0},{key:"Mod-Home",run:cursorDocStart,shift:selectDocStart},{key:"End",run:cursorLineBoundaryForward,shift:selectLineBoundaryForward,preventDefault:!0},{key:"Mod-End",run:cursorDocEnd,shift:selectDocEnd},{key:"Enter",run:insertNewlineAndIndent},{key:"Mod-a",run:selectAll},{key:"Backspace",run:deleteCharBackward,shift:deleteCharBackward},{key:"Delete",run:deleteCharForward},{key:"Mod-Backspace",mac:"Alt-Backspace",run:deleteGroupBackward},{key:"Mod-Delete",mac:"Alt-Delete",run:deleteGroupForward},{mac:"Mod-Backspace",run:deleteToLineStart},{mac:"Mod-Delete",run:deleteToLineEnd}].concat(emacsStyleKeymap.map((b=>({mac:b.key,run:b.run,shift:b.shift})))),defaultKeymap=[{key:"Alt-ArrowLeft",mac:"Ctrl-ArrowLeft",run:cursorSyntaxLeft,shift:selectSyntaxLeft},{key:"Alt-ArrowRight",mac:"Ctrl-ArrowRight",run:cursorSyntaxRight,shift:selectSyntaxRight},{key:"Alt-ArrowUp",run:moveLineUp},{key:"Shift-Alt-ArrowUp",run:copyLineUp},{key:"Alt-ArrowDown",run:moveLineDown},{key:"Shift-Alt-ArrowDown",run:copyLineDown},{key:"Escape",run:simplifySelection},{key:"Mod-Enter",run:insertBlankLine},{key:"Alt-l",mac:"Ctrl-l",run:selectLine},{key:"Mod-i",run:selectParentSyntax,preventDefault:!0},{key:"Mod-[",run:indentLess},{key:"Mod-]",run:indentMore},{key:"Mod-Alt-\\",run:indentSelection},{key:"Shift-Mod-k",run:deleteLine},{key:"Shift-Mod-\\",run:cursorMatchingBracket},{key:"Mod-/",run:toggleComment},{key:"Alt-A",run:toggleBlockComment}].concat(standardKeymap),indentWithTab={key:"Tab",run:indentMore,shift:indentLess};exports.blockComment=blockComment,exports.blockUncomment=blockUncomment,exports.copyLineDown=copyLineDown,exports.copyLineUp=copyLineUp,exports.cursorCharBackward=view=>cursorByChar(view,!1),exports.cursorCharForward=view=>cursorByChar(view,!0),exports.cursorCharLeft=cursorCharLeft,exports.cursorCharRight=cursorCharRight,exports.cursorDocEnd=cursorDocEnd,exports.cursorDocStart=cursorDocStart,exports.cursorGroupBackward=view=>cursorByGroup(view,!1),exports.cursorGroupForward=view=>cursorByGroup(view,!0),exports.cursorGroupLeft=cursorGroupLeft,exports.cursorGroupRight=cursorGroupRight,exports.cursorLineBoundaryBackward=cursorLineBoundaryBackward,exports.cursorLineBoundaryForward=cursorLineBoundaryForward,exports.cursorLineBoundaryLeft=cursorLineBoundaryLeft,exports.cursorLineBoundaryRight=cursorLineBoundaryRight,exports.cursorLineDown=cursorLineDown,exports.cursorLineEnd=cursorLineEnd,exports.cursorLineStart=cursorLineStart,exports.cursorLineUp=cursorLineUp,exports.cursorMatchingBracket=cursorMatchingBracket,exports.cursorPageDown=cursorPageDown,exports.cursorPageUp=cursorPageUp,exports.cursorSubwordBackward=view=>cursorBySubword(view,!1),exports.cursorSubwordForward=view=>cursorBySubword(view,!0),exports.cursorSyntaxLeft=cursorSyntaxLeft,exports.cursorSyntaxRight=cursorSyntaxRight,exports.defaultKeymap=defaultKeymap,exports.deleteCharBackward=deleteCharBackward,exports.deleteCharForward=deleteCharForward,exports.deleteGroupBackward=deleteGroupBackward,exports.deleteGroupForward=deleteGroupForward,exports.deleteLine=deleteLine,exports.deleteToLineEnd=deleteToLineEnd,exports.deleteToLineStart=deleteToLineStart,exports.deleteTrailingWhitespace=({state:state,dispatch:dispatch})=>{if(state.readOnly)return!1;let changes=[];for(let pos=0,prev="",iter=state.doc.iter();;){if(iter.next(),iter.lineBreak||iter.done){let trailing=prev.search(/\s+$/);if(trailing>-1&&changes.push({from:pos-(prev.length-trailing),to:pos}),iter.done)break;prev=""}else prev=iter.value;pos+=iter.value.length}return!!changes.length&&(dispatch(state.update({changes:changes,userEvent:"delete"})),!0)},exports.emacsStyleKeymap=emacsStyleKeymap,exports.history=function(config={}){return[historyField_,historyConfig.of(config),view.EditorView.domEventHandlers({beforeinput(e,view){let command="historyUndo"==e.inputType?undo:"historyRedo"==e.inputType?redo:null;return!!command&&(e.preventDefault(),command(view))}})]},exports.historyField=historyField,exports.historyKeymap=historyKeymap,exports.indentLess=indentLess,exports.indentMore=indentMore,exports.indentSelection=indentSelection,exports.indentWithTab=indentWithTab,exports.insertBlankLine=insertBlankLine,exports.insertNewline=({state:state,dispatch:dispatch})=>(dispatch(state.update(state.replaceSelection(state.lineBreak),{scrollIntoView:!0,userEvent:"input"})),!0),exports.insertNewlineAndIndent=insertNewlineAndIndent,exports.insertTab=({state:state,dispatch:dispatch})=>state.selection.ranges.some((r=>!r.empty))?indentMore({state:state,dispatch:dispatch}):(dispatch(state.update(state.replaceSelection("\t"),{scrollIntoView:!0,userEvent:"input"})),!0),exports.invertedEffects=invertedEffects,exports.isolateHistory=isolateHistory,exports.lineComment=lineComment,exports.lineUncomment=lineUncomment,exports.moveLineDown=moveLineDown,exports.moveLineUp=moveLineUp,exports.redo=redo,exports.redoDepth=redoDepth,exports.redoSelection=redoSelection,exports.selectAll=selectAll,exports.selectCharBackward=view=>selectByChar(view,!1),exports.selectCharForward=view=>selectByChar(view,!0),exports.selectCharLeft=selectCharLeft,exports.selectCharRight=selectCharRight,exports.selectDocEnd=selectDocEnd,exports.selectDocStart=selectDocStart,exports.selectGroupBackward=view=>selectByGroup(view,!1),exports.selectGroupForward=view=>selectByGroup(view,!0),exports.selectGroupLeft=selectGroupLeft,exports.selectGroupRight=selectGroupRight,exports.selectLine=selectLine,exports.selectLineBoundaryBackward=selectLineBoundaryBackward,exports.selectLineBoundaryForward=selectLineBoundaryForward,exports.selectLineBoundaryLeft=selectLineBoundaryLeft,exports.selectLineBoundaryRight=selectLineBoundaryRight,exports.selectLineDown=selectLineDown,exports.selectLineEnd=selectLineEnd,exports.selectLineStart=selectLineStart,exports.selectLineUp=selectLineUp,exports.selectMatchingBracket=({state:state,dispatch:dispatch})=>toMatchingBracket(state,dispatch,!0),exports.selectPageDown=selectPageDown,exports.selectPageUp=selectPageUp,exports.selectParentSyntax=selectParentSyntax,exports.selectSubwordBackward=view=>selectBySubword(view,!1),exports.selectSubwordForward=view=>selectBySubword(view,!0),exports.selectSyntaxLeft=selectSyntaxLeft,exports.selectSyntaxRight=selectSyntaxRight,exports.simplifySelection=simplifySelection,exports.splitLine=splitLine,exports.standardKeymap=standardKeymap,exports.toggleBlockComment=toggleBlockComment,exports.toggleBlockCommentByLine=toggleBlockCommentByLine,exports.toggleComment=toggleComment,exports.toggleLineComment=toggleLineComment,exports.transposeChars=transposeChars,exports.undo=undo,exports.undoDepth=undoDepth,exports.undoSelection=undoSelection},{"@codemirror/language":10,"@codemirror/state":11,"@codemirror/view":12,"@lezer/common":13}],10:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _a,common=require("@lezer/common"),state=require("@codemirror/state"),view=require("@codemirror/view"),highlight=require("@lezer/highlight"),styleMod=require("style-mod");const languageDataProp=new common.NodeProp;function defineLanguageFacet(baseData){return state.Facet.define({combine:baseData?values=>values.concat(baseData):void 0})}class Language{constructor(data,parser,extraExtensions=[],name=""){this.data=data,this.name=name,state.EditorState.prototype.hasOwnProperty("tree")||Object.defineProperty(state.EditorState.prototype,"tree",{get(){return syntaxTree(this)}}),this.parser=parser,this.extension=[language.of(this),state.EditorState.languageData.of(((state,pos,side)=>state.facet(languageDataFacetAt(state,pos,side))))].concat(extraExtensions)}isActiveAt(state,pos,side=-1){return languageDataFacetAt(state,pos,side)==this.data}findRegions(state){let lang=state.facet(language);if((null==lang?void 0:lang.data)==this.data)return[{from:0,to:state.doc.length}];if(!lang||!lang.allowsNesting)return[];let result=[],explore=(tree,from)=>{if(tree.prop(languageDataProp)==this.data)return void result.push({from:from,to:from+tree.length});let mount=tree.prop(common.NodeProp.mounted);if(mount){if(mount.tree.prop(languageDataProp)==this.data){if(mount.overlay)for(let r of mount.overlay)result.push({from:r.from+from,to:r.to+from});else result.push({from:from,to:from+tree.length});return}if(mount.overlay){let size=result.length;if(explore(mount.tree,mount.overlay[0].from+from),result.length>size)return}}for(let i=0;i<tree.children.length;i++){let ch=tree.children[i];ch instanceof common.Tree&&explore(ch,tree.positions[i]+from)}};return explore(syntaxTree(state),0),result}get allowsNesting(){return!0}}function languageDataFacetAt(state,pos,side){let topLang=state.facet(language);if(!topLang)return null;let facet=topLang.data;if(topLang.allowsNesting)for(let node=syntaxTree(state).topNode;node;node=node.enter(pos,side,common.IterMode.ExcludeBuffers))facet=node.type.prop(languageDataProp)||facet;return facet}Language.setState=state.StateEffect.define();class LRLanguage extends Language{constructor(data,parser,name){super(data,parser,[],name),this.parser=parser}static define(spec){let data=defineLanguageFacet(spec.languageData);return new LRLanguage(data,spec.parser.configure({props:[languageDataProp.add((type=>type.isTop?data:void 0))]}),spec.name)}configure(options,name){return new LRLanguage(this.data,this.parser.configure(options),name||this.name)}get allowsNesting(){return this.parser.hasWrappers()}}function syntaxTree(state){let field=state.field(Language.state,!1);return field?field.tree:common.Tree.empty}function ensureSyntaxTree(state,upto,timeout=50){var _a;let parse=null===(_a=state.field(Language.state,!1))||void 0===_a?void 0:_a.context;if(!parse)return null;let oldVieport=parse.viewport;parse.updateViewport({from:0,to:upto});let result=parse.isDone(upto)||parse.work(timeout,upto)?parse.tree:null;return parse.updateViewport(oldVieport),result}class DocInput{constructor(doc,length=doc.length){this.doc=doc,this.length=length,this.cursorPos=0,this.string="",this.cursor=doc.iter()}syncTo(pos){return this.string=this.cursor.next(pos-this.cursorPos).value,this.cursorPos=pos+this.string.length,this.cursorPos-this.string.length}chunk(pos){return this.syncTo(pos),this.string}get lineChunks(){return!0}read(from,to){let stringStart=this.cursorPos-this.string.length;return from<stringStart||to>=this.cursorPos?this.doc.sliceString(from,to):this.string.slice(from-stringStart,to-stringStart)}}let currentContext=null;class ParseContext{constructor(parser,state,fragments=[],tree,treeLen,viewport,skipped,scheduleOn){this.parser=parser,this.state=state,this.fragments=fragments,this.tree=tree,this.treeLen=treeLen,this.viewport=viewport,this.skipped=skipped,this.scheduleOn=scheduleOn,this.parse=null,this.tempSkipped=[]}static create(parser,state,viewport){return new ParseContext(parser,state,[],common.Tree.empty,0,viewport,[],null)}startParse(){return this.parser.startParse(new DocInput(this.state.doc),this.fragments)}work(until,upto){return null!=upto&&upto>=this.state.doc.length&&(upto=void 0),this.tree!=common.Tree.empty&&this.isDone(null!=upto?upto:this.state.doc.length)?(this.takeTree(),!0):this.withContext((()=>{var _a;if("number"==typeof until){let endTime=Date.now()+until;until=()=>Date.now()>endTime}for(this.parse||(this.parse=this.startParse()),null!=upto&&(null==this.parse.stoppedAt||this.parse.stoppedAt>upto)&&upto<this.state.doc.length&&this.parse.stopAt(upto);;){let done=this.parse.advance();if(done){if(this.fragments=this.withoutTempSkipped(common.TreeFragment.addTree(done,this.fragments,null!=this.parse.stoppedAt)),this.treeLen=null!==(_a=this.parse.stoppedAt)&&void 0!==_a?_a:this.state.doc.length,this.tree=done,this.parse=null,!(this.treeLen<(null!=upto?upto:this.state.doc.length)))return!0;this.parse=this.startParse()}if(until())return!1}}))}takeTree(){let pos,tree;this.parse&&(pos=this.parse.parsedPos)>=this.treeLen&&((null==this.parse.stoppedAt||this.parse.stoppedAt>pos)&&this.parse.stopAt(pos),this.withContext((()=>{for(;!(tree=this.parse.advance()););})),this.treeLen=pos,this.tree=tree,this.fragments=this.withoutTempSkipped(common.TreeFragment.addTree(this.tree,this.fragments,!0)),this.parse=null)}withContext(f){let prev=currentContext;currentContext=this;try{return f()}finally{currentContext=prev}}withoutTempSkipped(fragments){for(let r;r=this.tempSkipped.pop();)fragments=cutFragments(fragments,r.from,r.to);return fragments}changes(changes,newState){let{fragments:fragments,tree:tree,treeLen:treeLen,viewport:viewport,skipped:skipped}=this;if(this.takeTree(),!changes.empty){let ranges=[];if(changes.iterChangedRanges(((fromA,toA,fromB,toB)=>ranges.push({fromA:fromA,toA:toA,fromB:fromB,toB:toB}))),fragments=common.TreeFragment.applyChanges(fragments,ranges),tree=common.Tree.empty,treeLen=0,viewport={from:changes.mapPos(viewport.from,-1),to:changes.mapPos(viewport.to,1)},this.skipped.length){skipped=[];for(let r of this.skipped){let from=changes.mapPos(r.from,1),to=changes.mapPos(r.to,-1);from<to&&skipped.push({from:from,to:to})}}}return new ParseContext(this.parser,newState,fragments,tree,treeLen,viewport,skipped,this.scheduleOn)}updateViewport(viewport){if(this.viewport.from==viewport.from&&this.viewport.to==viewport.to)return!1;this.viewport=viewport;let startLen=this.skipped.length;for(let i=0;i<this.skipped.length;i++){let{from:from,to:to}=this.skipped[i];from<viewport.to&&to>viewport.from&&(this.fragments=cutFragments(this.fragments,from,to),this.skipped.splice(i--,1))}return!(this.skipped.length>=startLen)&&(this.reset(),!0)}reset(){this.parse&&(this.takeTree(),this.parse=null)}skipUntilInView(from,to){this.skipped.push({from:from,to:to})}static getSkippingParser(until){return new class extends common.Parser{createParse(input,fragments,ranges){let from=ranges[0].from,to=ranges[ranges.length-1].to;return{parsedPos:from,advance(){let cx=currentContext;if(cx){for(let r of ranges)cx.tempSkipped.push(r);until&&(cx.scheduleOn=cx.scheduleOn?Promise.all([cx.scheduleOn,until]):until)}return this.parsedPos=to,new common.Tree(common.NodeType.none,[],[],to-from)},stoppedAt:null,stopAt(){}}}}}isDone(upto){upto=Math.min(upto,this.state.doc.length);let frags=this.fragments;return this.treeLen>=upto&&frags.length&&0==frags[0].from&&frags[0].to>=upto}static get(){return currentContext}}function cutFragments(fragments,from,to){return common.TreeFragment.applyChanges(fragments,[{fromA:from,toA:to,fromB:from,toB:to}])}class LanguageState{constructor(context){this.context=context,this.tree=context.tree}apply(tr){if(!tr.docChanged&&this.tree==this.context.tree)return this;let newCx=this.context.changes(tr.changes,tr.state),upto=this.context.treeLen==tr.startState.doc.length?void 0:Math.max(tr.changes.mapPos(this.context.treeLen),newCx.viewport.to);return newCx.work(20,upto)||newCx.takeTree(),new LanguageState(newCx)}static init(state){let vpTo=Math.min(3e3,state.doc.length),parseState=ParseContext.create(state.facet(language).parser,state,{from:0,to:vpTo});return parseState.work(20,vpTo)||parseState.takeTree(),new LanguageState(parseState)}}Language.state=state.StateField.define({create:LanguageState.init,update(value,tr){for(let e of tr.effects)if(e.is(Language.setState))return e.value;return tr.startState.facet(language)!=tr.state.facet(language)?LanguageState.init(tr.state):value.apply(tr)}});let requestIdle=callback=>{let timeout=setTimeout((()=>callback()),500);return()=>clearTimeout(timeout)};"undefined"!=typeof requestIdleCallback&&(requestIdle=callback=>{let idle=-1,timeout=setTimeout((()=>{idle=requestIdleCallback(callback,{timeout:400})}),100);return()=>idle<0?clearTimeout(timeout):cancelIdleCallback(idle)});const isInputPending="undefined"!=typeof navigator&&(null===(_a=navigator.scheduling)||void 0===_a?void 0:_a.isInputPending)?()=>navigator.scheduling.isInputPending():null,parseWorker=view.ViewPlugin.fromClass(class{constructor(view){this.view=view,this.working=null,this.workScheduled=0,this.chunkEnd=-1,this.chunkBudget=-1,this.work=this.work.bind(this),this.scheduleWork()}update(update){let cx=this.view.state.field(Language.state).context;(cx.updateViewport(update.view.viewport)||this.view.viewport.to>cx.treeLen)&&this.scheduleWork(),update.docChanged&&(this.view.hasFocus&&(this.chunkBudget+=50),this.scheduleWork()),this.checkAsyncSchedule(cx)}scheduleWork(){if(this.working)return;let{state:state}=this.view,field=state.field(Language.state);field.tree==field.context.tree&&field.context.isDone(state.doc.length)||(this.working=requestIdle(this.work))}work(deadline){this.working=null;let now=Date.now();if(this.chunkEnd<now&&(this.chunkEnd<0||this.view.hasFocus)&&(this.chunkEnd=now+3e4,this.chunkBudget=3e3),this.chunkBudget<=0)return;let{state:state,viewport:{to:vpTo}}=this.view,field=state.field(Language.state);if(field.tree==field.context.tree&&field.context.isDone(vpTo+1e5))return;let endTime=Date.now()+Math.min(this.chunkBudget,100,deadline&&!isInputPending?Math.max(25,deadline.timeRemaining()-5):1e9),viewportFirst=field.context.treeLen<vpTo&&state.doc.length>vpTo+1e3,done=field.context.work((()=>isInputPending&&isInputPending()||Date.now()>endTime),vpTo+(viewportFirst?0:1e5));this.chunkBudget-=Date.now()-now,(done||this.chunkBudget<=0)&&(field.context.takeTree(),this.view.dispatch({effects:Language.setState.of(new LanguageState(field.context))})),this.chunkBudget>0&&(!done||viewportFirst)&&this.scheduleWork(),this.checkAsyncSchedule(field.context)}checkAsyncSchedule(cx){cx.scheduleOn&&(this.workScheduled++,cx.scheduleOn.then((()=>this.scheduleWork())).catch((err=>view.logException(this.view.state,err))).then((()=>this.workScheduled--)),cx.scheduleOn=null)}destroy(){this.working&&this.working()}isWorking(){return!!(this.working||this.workScheduled>0)}},{eventHandlers:{focus(){this.scheduleWork()}}}),language=state.Facet.define({combine:languages=>languages.length?languages[0]:null,enables:language=>[Language.state,parseWorker,view.EditorView.contentAttributes.compute([language],(state=>{let lang=state.facet(language);return lang&&lang.name?{"data-language":lang.name}:{}}))]});class LanguageDescription{constructor(name,alias,extensions,filename,loadFunc,support){this.name=name,this.alias=alias,this.extensions=extensions,this.filename=filename,this.loadFunc=loadFunc,this.support=support,this.loading=null}load(){return this.loading||(this.loading=this.loadFunc().then((support=>this.support=support),(err=>{throw this.loading=null,err})))}static of(spec){let{load:load,support:support}=spec;if(!load){if(!support)throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");load=()=>Promise.resolve(support)}return new LanguageDescription(spec.name,(spec.alias||[]).concat(spec.name).map((s=>s.toLowerCase())),spec.extensions||[],spec.filename,load,support)}static matchFilename(descs,filename){for(let d of descs)if(d.filename&&d.filename.test(filename))return d;let ext=/\.([^.]+)$/.exec(filename);if(ext)for(let d of descs)if(d.extensions.indexOf(ext[1])>-1)return d;return null}static matchLanguageName(descs,name,fuzzy=!0){name=name.toLowerCase();for(let d of descs)if(d.alias.some((a=>a==name)))return d;if(fuzzy)for(let d of descs)for(let a of d.alias){let found=name.indexOf(a);if(found>-1&&(a.length>2||!/\w/.test(name[found-1])&&!/\w/.test(name[found+a.length])))return d}return null}}const indentService=state.Facet.define(),indentUnit=state.Facet.define({combine:values=>{if(!values.length)return"  ";if(!/^(?: +|\t+)$/.test(values[0]))throw new Error("Invalid indent unit: "+JSON.stringify(values[0]));return values[0]}});function getIndentUnit(state){let unit=state.facet(indentUnit);return 9==unit.charCodeAt(0)?state.tabSize*unit.length:unit.length}function indentString(state,cols){let result="",ts=state.tabSize;if(9==state.facet(indentUnit).charCodeAt(0))for(;cols>=ts;)result+="\t",cols-=ts;for(let i=0;i<cols;i++)result+=" ";return result}function getIndentation(context,pos){context instanceof state.EditorState&&(context=new IndentContext(context));for(let service of context.state.facet(indentService)){let result=service(context,pos);if(void 0!==result)return result}let tree=syntaxTree(context.state);return tree?function(cx,ast,pos){return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos),pos,cx)}(context,tree,pos):null}class IndentContext{constructor(state,options={}){this.state=state,this.options=options,this.unit=getIndentUnit(state)}lineAt(pos,bias=1){let line=this.state.doc.lineAt(pos),{simulateBreak:simulateBreak,simulateDoubleBreak:simulateDoubleBreak}=this.options;return null!=simulateBreak&&simulateBreak>=line.from&&simulateBreak<=line.to?simulateDoubleBreak&&simulateBreak==pos?{text:"",from:pos}:(bias<0?simulateBreak<pos:simulateBreak<=pos)?{text:line.text.slice(simulateBreak-line.from),from:simulateBreak}:{text:line.text.slice(0,simulateBreak-line.from),from:line.from}:line}textAfterPos(pos,bias=1){if(this.options.simulateDoubleBreak&&pos==this.options.simulateBreak)return"";let{text:text,from:from}=this.lineAt(pos,bias);return text.slice(pos-from,Math.min(text.length,pos+100-from))}column(pos,bias=1){let{text:text,from:from}=this.lineAt(pos,bias),result=this.countColumn(text,pos-from),override=this.options.overrideIndentation?this.options.overrideIndentation(from):-1;return override>-1&&(result+=override-this.countColumn(text,text.search(/\S|$/))),result}countColumn(line,pos=line.length){return state.countColumn(line,this.state.tabSize,pos)}lineIndent(pos,bias=1){let{text:text,from:from}=this.lineAt(pos,bias),override=this.options.overrideIndentation;if(override){let overriden=override(from);if(overriden>-1)return overriden}return this.countColumn(text,text.search(/\S|$/))}get simulatedBreak(){return this.options.simulateBreak||null}}const indentNodeProp=new common.NodeProp;function indentStrategy(tree){let strategy=tree.type.prop(indentNodeProp);if(strategy)return strategy;let close,first=tree.firstChild;if(first&&(close=first.type.prop(common.NodeProp.closedBy))){let last=tree.lastChild,closed=last&&close.indexOf(last.name)>-1;return cx=>delimitedStrategy(cx,!0,1,void 0,closed&&!function(cx){return cx.pos==cx.options.simulateBreak&&cx.options.simulateDoubleBreak}(cx)?last.from:void 0)}return null==tree.parent?topIndent:null}function indentFrom(node,pos,base){for(;node;node=node.parent){let strategy=indentStrategy(node);if(strategy)return strategy(TreeIndentContext.create(base,pos,node))}return null}function topIndent(){return 0}class TreeIndentContext extends IndentContext{constructor(base,pos,node){super(base.state,base.options),this.base=base,this.pos=pos,this.node=node}static create(base,pos,node){return new TreeIndentContext(base,pos,node)}get textAfter(){return this.textAfterPos(this.pos)}get baseIndent(){let line=this.state.doc.lineAt(this.node.from);for(;;){let atBreak=this.node.resolve(line.from);for(;atBreak.parent&&atBreak.parent.from==atBreak.from;)atBreak=atBreak.parent;if(isParent(atBreak,this.node))break;line=this.state.doc.lineAt(atBreak.from)}return this.lineIndent(line.from)}continue(){let parent=this.node.parent;return parent?indentFrom(parent,this.pos,this.base):0}}function isParent(parent,of){for(let cur=of;cur;cur=cur.parent)if(parent==cur)return!0;return!1}function delimitedStrategy(context,align,units,closing,closedAt){let after=context.textAfter,space=after.match(/^\s*/)[0].length,closed=closing&&after.slice(space,space+closing.length)==closing||closedAt==context.pos+space,aligned=align?function(context){let tree=context.node,openToken=tree.childAfter(tree.from),last=tree.lastChild;if(!openToken)return null;let sim=context.options.simulateBreak,openLine=context.state.doc.lineAt(openToken.from),lineEnd=null==sim||sim<=openLine.from?openLine.to:Math.min(openLine.to,sim);for(let pos=openToken.to;;){let next=tree.childAfter(pos);if(!next||next==last)return null;if(!next.type.isSkipped)return next.from<lineEnd?openToken:null;pos=next.to}}(context):null;return aligned?closed?context.column(aligned.from):context.column(aligned.to):context.baseIndent+(closed?0:context.unit*units)}const foldService=state.Facet.define(),foldNodeProp=new common.NodeProp;function isUnfinished(node){let ch=node.lastChild;return ch&&ch.to==node.to&&ch.type.isError}function foldable(state,lineStart,lineEnd){for(let service of state.facet(foldService)){let result=service(state,lineStart,lineEnd);if(result)return result}return function(state,start,end){let tree=syntaxTree(state);if(tree.length<end)return null;let found=null;for(let cur=tree.resolveInner(end,1);cur;cur=cur.parent){if(cur.to<=end||cur.from>end)continue;if(found&&cur.from<start)break;let prop=cur.type.prop(foldNodeProp);if(prop&&(cur.to<tree.length-50||tree.length==state.doc.length||!isUnfinished(cur))){let value=prop(cur,state);value&&value.from<=end&&value.from>=start&&value.to>end&&(found=value)}}return found}(state,lineStart,lineEnd)}function mapRange(range,mapping){let from=mapping.mapPos(range.from,1),to=mapping.mapPos(range.to,-1);return from>=to?void 0:{from:from,to:to}}const foldEffect=state.StateEffect.define({map:mapRange}),unfoldEffect=state.StateEffect.define({map:mapRange});function selectedLines(view){let lines=[];for(let{head:head}of view.state.selection.ranges)lines.some((l=>l.from<=head&&l.to>=head))||lines.push(view.lineBlockAt(head));return lines}const foldState=state.StateField.define({create:()=>view.Decoration.none,update(folded,tr){folded=folded.map(tr.changes);for(let e of tr.effects)e.is(foldEffect)&&!foldExists(folded,e.value.from,e.value.to)?folded=folded.update({add:[foldWidget.range(e.value.from,e.value.to)]}):e.is(unfoldEffect)&&(folded=folded.update({filter:(from,to)=>e.value.from!=from||e.value.to!=to,filterFrom:e.value.from,filterTo:e.value.to}));if(tr.selection){let onSelection=!1,{head:head}=tr.selection.main;folded.between(head,head,((a,b)=>{a<head&&b>head&&(onSelection=!0)})),onSelection&&(folded=folded.update({filterFrom:head,filterTo:head,filter:(a,b)=>b<=head||a>=head}))}return folded},provide:f=>view.EditorView.decorations.from(f),toJSON(folded,state){let ranges=[];return folded.between(0,state.doc.length,((from,to)=>{ranges.push(from,to)})),ranges},fromJSON(value){if(!Array.isArray(value)||value.length%2)throw new RangeError("Invalid JSON for fold state");let ranges=[];for(let i=0;i<value.length;){let from=value[i++],to=value[i++];if("number"!=typeof from||"number"!=typeof to)throw new RangeError("Invalid JSON for fold state");ranges.push(foldWidget.range(from,to))}return view.Decoration.set(ranges,!0)}});function findFold(state,from,to){var _a;let found=null;return null===(_a=state.field(foldState,!1))||void 0===_a||_a.between(from,to,((from,to)=>{(!found||found.from>from)&&(found={from:from,to:to})})),found}function foldExists(folded,from,to){let found=!1;return folded.between(from,from,((a,b)=>{a==from&&b==to&&(found=!0)})),found}function maybeEnable(state$1,other){return state$1.field(foldState,!1)?other:other.concat(state.StateEffect.appendConfig.of(codeFolding()))}const foldCode=view=>{for(let line of selectedLines(view)){let range=foldable(view.state,line.from,line.to);if(range)return view.dispatch({effects:maybeEnable(view.state,[foldEffect.of(range),announceFold(view,range)])}),!0}return!1},unfoldCode=view=>{if(!view.state.field(foldState,!1))return!1;let effects=[];for(let line of selectedLines(view)){let folded=findFold(view.state,line.from,line.to);folded&&effects.push(unfoldEffect.of(folded),announceFold(view,folded,!1))}return effects.length&&view.dispatch({effects:effects}),effects.length>0};function announceFold(view$1,range,fold=!0){let lineFrom=view$1.state.doc.lineAt(range.from).number,lineTo=view$1.state.doc.lineAt(range.to).number;return view.EditorView.announce.of(`${view$1.state.phrase(fold?"Folded lines":"Unfolded lines")} ${lineFrom} ${view$1.state.phrase("to")} ${lineTo}.`)}const foldAll=view=>{let{state:state}=view,effects=[];for(let pos=0;pos<state.doc.length;){let line=view.lineBlockAt(pos),range=foldable(state,line.from,line.to);range&&effects.push(foldEffect.of(range)),pos=(range?view.lineBlockAt(range.to):line).to+1}return effects.length&&view.dispatch({effects:maybeEnable(view.state,effects)}),!!effects.length},unfoldAll=view=>{let field=view.state.field(foldState,!1);if(!field||!field.size)return!1;let effects=[];return field.between(0,view.state.doc.length,((from,to)=>{effects.push(unfoldEffect.of({from:from,to:to}))})),view.dispatch({effects:effects}),!0},foldKeymap=[{key:"Ctrl-Shift-[",mac:"Cmd-Alt-[",run:foldCode},{key:"Ctrl-Shift-]",mac:"Cmd-Alt-]",run:unfoldCode},{key:"Ctrl-Alt-[",run:foldAll},{key:"Ctrl-Alt-]",run:unfoldAll}],defaultConfig={placeholderDOM:null,placeholderText:""},foldConfig=state.Facet.define({combine:values=>state.combineConfig(values,defaultConfig)});function codeFolding(config){let result=[foldState,baseTheme$1];return config&&result.push(foldConfig.of(config)),result}const foldWidget=view.Decoration.replace({widget:new class extends view.WidgetType{toDOM(view){let{state:state}=view,conf=state.facet(foldConfig),onclick=event=>{let line=view.lineBlockAt(view.posAtDOM(event.target)),folded=findFold(view.state,line.from,line.to);folded&&view.dispatch({effects:unfoldEffect.of(folded)}),event.preventDefault()};if(conf.placeholderDOM)return conf.placeholderDOM(view,onclick);let element=document.createElement("span");return element.textContent=conf.placeholderText,element.setAttribute("aria-label",state.phrase("folded code")),element.title=state.phrase("unfold"),element.className="cm-foldPlaceholder",element.onclick=onclick,element}}}),foldGutterDefaults={openText:"",closedText:"",markerDOM:null,domEventHandlers:{},foldingChanged:()=>!1};class FoldMarker extends view.GutterMarker{constructor(config,open){super(),this.config=config,this.open=open}eq(other){return this.config==other.config&&this.open==other.open}toDOM(view){if(this.config.markerDOM)return this.config.markerDOM(this.open);let span=document.createElement("span");return span.textContent=this.open?this.config.openText:this.config.closedText,span.title=view.state.phrase(this.open?"Fold line":"Unfold line"),span}}const baseTheme$1=view.EditorView.baseTheme({".cm-foldPlaceholder":{backgroundColor:"#eee",border:"1px solid #ddd",color:"#888",borderRadius:".2em",margin:"0 1px",padding:"0 1px",cursor:"pointer"},".cm-foldGutter span":{padding:"0 1px",cursor:"pointer"}});class HighlightStyle{constructor(specs,options){let modSpec;function def(spec){let cls=styleMod.StyleModule.newName();return(modSpec||(modSpec=Object.create(null)))["."+cls]=spec,cls}this.specs=specs;const all="string"==typeof options.all?options.all:options.all?def(options.all):void 0,scopeOpt=options.scope;this.scope=scopeOpt instanceof Language?type=>type.prop(languageDataProp)==scopeOpt.data:scopeOpt?type=>type==scopeOpt:void 0,this.style=highlight.tagHighlighter(specs.map((style=>({tag:style.tag,class:style.class||def(Object.assign({},style,{tag:null}))}))),{all:all}).style,this.module=modSpec?new styleMod.StyleModule(modSpec):null,this.themeType=options.themeType}static define(specs,options){return new HighlightStyle(specs,options||{})}}const highlighterFacet=state.Facet.define(),fallbackHighlighter=state.Facet.define({combine:values=>values.length?[values[0]]:null});function getHighlighters(state){let main=state.facet(highlighterFacet);return main.length?main:state.facet(fallbackHighlighter)}const treeHighlighter=state.Prec.high(view.ViewPlugin.fromClass(class{constructor(view){this.markCache=Object.create(null),this.tree=syntaxTree(view.state),this.decorations=this.buildDeco(view,getHighlighters(view.state))}update(update){let tree=syntaxTree(update.state),highlighters=getHighlighters(update.state),styleChange=highlighters!=getHighlighters(update.startState);tree.length<update.view.viewport.to&&!styleChange&&tree.type==this.tree.type?this.decorations=this.decorations.map(update.changes):(tree!=this.tree||update.viewportChanged||styleChange)&&(this.tree=tree,this.decorations=this.buildDeco(update.view,highlighters))}buildDeco(view$1,highlighters){if(!highlighters||!this.tree.length)return view.Decoration.none;let builder=new state.RangeSetBuilder;for(let{from:from,to:to}of view$1.visibleRanges)highlight.highlightTree(this.tree,highlighters,((from,to,style)=>{builder.add(from,to,this.markCache[style]||(this.markCache[style]=view.Decoration.mark({class:style})))}),from,to);return builder.finish()}},{decorations:v=>v.decorations})),defaultHighlightStyle=HighlightStyle.define([{tag:highlight.tags.meta,color:"#404740"},{tag:highlight.tags.link,textDecoration:"underline"},{tag:highlight.tags.heading,textDecoration:"underline",fontWeight:"bold"},{tag:highlight.tags.emphasis,fontStyle:"italic"},{tag:highlight.tags.strong,fontWeight:"bold"},{tag:highlight.tags.strikethrough,textDecoration:"line-through"},{tag:highlight.tags.keyword,color:"#708"},{tag:[highlight.tags.atom,highlight.tags.bool,highlight.tags.url,highlight.tags.contentSeparator,highlight.tags.labelName],color:"#219"},{tag:[highlight.tags.literal,highlight.tags.inserted],color:"#164"},{tag:[highlight.tags.string,highlight.tags.deleted],color:"#a11"},{tag:[highlight.tags.regexp,highlight.tags.escape,highlight.tags.special(highlight.tags.string)],color:"#e40"},{tag:highlight.tags.definition(highlight.tags.variableName),color:"#00f"},{tag:highlight.tags.local(highlight.tags.variableName),color:"#30a"},{tag:[highlight.tags.typeName,highlight.tags.namespace],color:"#085"},{tag:highlight.tags.className,color:"#167"},{tag:[highlight.tags.special(highlight.tags.variableName),highlight.tags.macroName],color:"#256"},{tag:highlight.tags.definition(highlight.tags.propertyName),color:"#00c"},{tag:highlight.tags.comment,color:"#940"},{tag:highlight.tags.invalid,color:"#f00"}]),baseTheme=view.EditorView.baseTheme({"&.cm-focused .cm-matchingBracket":{backgroundColor:"#328c8252"},"&.cm-focused .cm-nonmatchingBracket":{backgroundColor:"#bb555544"}}),bracketMatchingConfig=state.Facet.define({combine:configs=>state.combineConfig(configs,{afterCursor:!0,brackets:"()[]{}",maxScanDistance:1e4,renderMatch:defaultRenderMatch})}),matchingMark=view.Decoration.mark({class:"cm-matchingBracket"}),nonmatchingMark=view.Decoration.mark({class:"cm-nonmatchingBracket"});function defaultRenderMatch(match){let decorations=[],mark=match.matched?matchingMark:nonmatchingMark;return decorations.push(mark.range(match.start.from,match.start.to)),match.end&&decorations.push(mark.range(match.end.from,match.end.to)),decorations}const bracketMatchingUnique=[state.StateField.define({create:()=>view.Decoration.none,update(deco,tr){if(!tr.docChanged&&!tr.selection)return deco;let decorations=[],config=tr.state.facet(bracketMatchingConfig);for(let range of tr.state.selection.ranges){if(!range.empty)continue;let match=matchBrackets(tr.state,range.head,-1,config)||range.head>0&&matchBrackets(tr.state,range.head-1,1,config)||config.afterCursor&&(matchBrackets(tr.state,range.head,1,config)||range.head<tr.state.doc.length&&matchBrackets(tr.state,range.head+1,-1,config));match&&(decorations=decorations.concat(config.renderMatch(match,tr.state)))}return view.Decoration.set(decorations,!0)},provide:f=>view.EditorView.decorations.from(f)}),baseTheme];const bracketMatchingHandle=new common.NodeProp;function matchingNodes(node,dir,brackets){let byProp=node.prop(dir<0?common.NodeProp.openedBy:common.NodeProp.closedBy);if(byProp)return byProp;if(1==node.name.length){let index=brackets.indexOf(node.name);if(index>-1&&index%2==(dir<0?1:0))return[brackets[index+dir]]}return null}function findHandle(node){let hasHandle=node.type.prop(bracketMatchingHandle);return hasHandle?hasHandle(node.node):node}function matchBrackets(state,pos,dir,config={}){let maxScanDistance=config.maxScanDistance||1e4,brackets=config.brackets||"()[]{}",tree=syntaxTree(state),node=tree.resolveInner(pos,dir);for(let cur=node;cur;cur=cur.parent){let matches=matchingNodes(cur.type,dir,brackets);if(matches&&cur.from<cur.to){let handle=findHandle(cur);if(handle&&(dir>0?pos>=handle.from&&pos<handle.to:pos>handle.from&&pos<=handle.to))return matchMarkedBrackets(state,pos,dir,cur,handle,matches,brackets)}}return function(state,pos,dir,tree,tokenType,maxScanDistance,brackets){let startCh=dir<0?state.sliceDoc(pos-1,pos):state.sliceDoc(pos,pos+1),bracket=brackets.indexOf(startCh);if(bracket<0||bracket%2==0!=dir>0)return null;let startToken={from:dir<0?pos-1:pos,to:dir>0?pos+1:pos},iter=state.doc.iterRange(pos,dir>0?state.doc.length:0),depth=0;for(let distance=0;!iter.next().done&&distance<=maxScanDistance;){let text=iter.value;dir<0&&(distance+=text.length);let basePos=pos+distance*dir;for(let pos=dir>0?0:text.length-1,end=dir>0?text.length:-1;pos!=end;pos+=dir){let found=brackets.indexOf(text[pos]);if(!(found<0||tree.resolveInner(basePos+pos,1).type!=tokenType))if(found%2==0==dir>0)depth++;else{if(1==depth)return{start:startToken,end:{from:basePos+pos,to:basePos+pos+1},matched:found>>1==bracket>>1};depth--}}dir>0&&(distance+=text.length)}return iter.done?{start:startToken,matched:!1}:null}(state,pos,dir,tree,node.type,maxScanDistance,brackets)}function matchMarkedBrackets(_state,_pos,dir,token,handle,matching,brackets){let parent=token.parent,firstToken={from:handle.from,to:handle.to},depth=0,cursor=null==parent?void 0:parent.cursor();if(cursor&&(dir<0?cursor.childBefore(token.from):cursor.childAfter(token.to)))do{if(dir<0?cursor.to<=token.from:cursor.from>=token.to){if(0==depth&&matching.indexOf(cursor.type.name)>-1&&cursor.from<cursor.to){let endHandle=findHandle(cursor);return{start:firstToken,end:endHandle?{from:endHandle.from,to:endHandle.to}:void 0,matched:!0}}if(matchingNodes(cursor.type,dir,brackets))depth++;else if(matchingNodes(cursor.type,-dir,brackets)){if(0==depth){let endHandle=findHandle(cursor);return{start:firstToken,end:endHandle&&endHandle.from<endHandle.to?{from:endHandle.from,to:endHandle.to}:void 0,matched:!1}}depth--}}}while(dir<0?cursor.prevSibling():cursor.nextSibling());return{start:firstToken,matched:!1}}function countCol(string,end,tabSize,startIndex=0,startValue=0){null==end&&-1==(end=string.search(/[^\s\u00a0]/))&&(end=string.length);let n=startValue;for(let i=startIndex;i<end;i++)9==string.charCodeAt(i)?n+=tabSize-n%tabSize:n++;return n}class StringStream{constructor(string,tabSize,indentUnit){this.string=string,this.tabSize=tabSize,this.indentUnit=indentUnit,this.pos=0,this.start=0,this.lastColumnPos=0,this.lastColumnValue=0}eol(){return this.pos>=this.string.length}sol(){return 0==this.pos}peek(){return this.string.charAt(this.pos)||void 0}next(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)}eat(match){let ok,ch=this.string.charAt(this.pos);if(ok="string"==typeof match?ch==match:ch&&(match instanceof RegExp?match.test(ch):match(ch)),ok)return++this.pos,ch}eatWhile(match){let start=this.pos;for(;this.eat(match););return this.pos>start}eatSpace(){let start=this.pos;for(;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;return this.pos>start}skipToEnd(){this.pos=this.string.length}skipTo(ch){let found=this.string.indexOf(ch,this.pos);if(found>-1)return this.pos=found,!0}backUp(n){this.pos-=n}column(){return this.lastColumnPos<this.start&&(this.lastColumnValue=countCol(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue}indentation(){return countCol(this.string,null,this.tabSize)}match(pattern,consume,caseInsensitive){if("string"==typeof pattern){let cased=str=>caseInsensitive?str.toLowerCase():str;return cased(this.string.substr(this.pos,pattern.length))==cased(pattern)?(!1!==consume&&(this.pos+=pattern.length),!0):null}{let match=this.string.slice(this.pos).match(pattern);return match&&match.index>0?null:(match&&!1!==consume&&(this.pos+=match[0].length),match)}}current(){return this.string.slice(this.start,this.pos)}}function defaultCopyState(state){if("object"!=typeof state)return state;let newState={};for(let prop in state){let val=state[prop];newState[prop]=val instanceof Array?val.slice():val}return newState}class StreamLanguage extends Language{constructor(parser){let self,data=defineLanguageFacet(parser.languageData),p={name:(spec=parser).name||"",token:spec.token,blankLine:spec.blankLine||(()=>{}),startState:spec.startState||(()=>!0),copyState:spec.copyState||defaultCopyState,indent:spec.indent||(()=>null),languageData:spec.languageData||{},tokenTable:spec.tokenTable||noTokens};var spec;super(data,new class extends common.Parser{createParse(input,fragments,ranges){return new Parse(self,input,fragments,ranges)}},[indentService.of(((cx,pos)=>this.getIndent(cx,pos)))],parser.name),this.topNode=function(data){let type=common.NodeType.define({id:typeArray.length,name:"Document",props:[languageDataProp.add((()=>data))]});return typeArray.push(type),type}(data),self=this,this.streamParser=p,this.stateAfter=new common.NodeProp({perNode:!0}),this.tokenTable=parser.tokenTable?new TokenTable(p.tokenTable):defaultTokenTable}static define(spec){return new StreamLanguage(spec)}getIndent(cx,pos){let tree=syntaxTree(cx.state),at=tree.resolve(pos);for(;at&&at.type!=this.topNode;)at=at.parent;if(!at)return null;let statePos,state,start=findState(this,tree,0,at.from,pos);if(start?(state=start.state,statePos=start.pos+1):(state=this.streamParser.startState(cx.unit),statePos=0),pos-statePos>1e4)return null;for(;statePos<pos;){let line=cx.state.doc.lineAt(statePos),end=Math.min(pos,line.to);if(line.length){let stream=new StringStream(line.text,cx.state.tabSize,cx.unit);for(;stream.pos<end-line.from;)readToken(this.streamParser.token,stream,state)}else this.streamParser.blankLine(state,cx.unit);if(end==pos)break;statePos=line.to+1}let{text:text}=cx.lineAt(pos);return this.streamParser.indent(state,/^\s*(.*)/.exec(text)[1],cx)}get allowsNesting(){return!1}}function findState(lang,tree,off,startPos,before){let state=off>=startPos&&off+tree.length<=before&&tree.prop(lang.stateAfter);if(state)return{state:lang.streamParser.copyState(state),pos:off+tree.length};for(let i=tree.children.length-1;i>=0;i--){let child=tree.children[i],pos=off+tree.positions[i],found=child instanceof common.Tree&&pos<before&&findState(lang,child,pos,startPos,before);if(found)return found}return null}function cutTree(lang,tree,from,to,inside){if(inside&&from<=0&&to>=tree.length)return tree;inside||tree.type!=lang.topNode||(inside=!0);for(let i=tree.children.length-1;i>=0;i--){let inner,pos=tree.positions[i],child=tree.children[i];if(pos<to&&child instanceof common.Tree){if(!(inner=cutTree(lang,child,from-pos,to-pos,inside)))break;return inside?new common.Tree(tree.type,tree.children.slice(0,i).concat(inner),tree.positions.slice(0,i+1),pos+inner.length):inner}}return null}class Parse{constructor(lang,input,fragments,ranges){this.lang=lang,this.input=input,this.fragments=fragments,this.ranges=ranges,this.stoppedAt=null,this.chunks=[],this.chunkPos=[],this.chunk=[],this.chunkReused=void 0,this.rangeIndex=0,this.to=ranges[ranges.length-1].to;let context=ParseContext.get(),from=ranges[0].from,{state:state,tree:tree}=function(lang,fragments,startPos,editorState){for(let f of fragments){let tree,from=f.from+(f.openStart?25:0),to=f.to-(f.openEnd?25:0),found=from<=startPos&&to>startPos&&findState(lang,f.tree,0-f.offset,startPos,to);if(found&&(tree=cutTree(lang,f.tree,startPos+f.offset,found.pos+f.offset,!1)))return{state:found.state,tree:tree}}return{state:lang.streamParser.startState(editorState?getIndentUnit(editorState):4),tree:common.Tree.empty}}(lang,fragments,from,null==context?void 0:context.state);this.state=state,this.parsedPos=this.chunkStart=from+tree.length;for(let i=0;i<tree.children.length;i++)this.chunks.push(tree.children[i]),this.chunkPos.push(tree.positions[i]);context&&this.parsedPos<context.viewport.from-1e5&&(this.state=this.lang.streamParser.startState(getIndentUnit(context.state)),context.skipUntilInView(this.parsedPos,context.viewport.from),this.parsedPos=context.viewport.from),this.moveRangeIndex()}advance(){let context=ParseContext.get(),parseEnd=null==this.stoppedAt?this.to:Math.min(this.to,this.stoppedAt),end=Math.min(parseEnd,this.chunkStart+2048);for(context&&(end=Math.min(end,context.viewport.to));this.parsedPos<end;)this.parseLine(context);return this.chunkStart<this.parsedPos&&this.finishChunk(),this.parsedPos>=parseEnd?this.finish():context&&this.parsedPos>=context.viewport.to?(context.skipUntilInView(this.parsedPos,parseEnd),this.finish()):null}stopAt(pos){this.stoppedAt=pos}lineAfter(pos){let chunk=this.input.chunk(pos);if(this.input.lineChunks)"\n"==chunk&&(chunk="");else{let eol=chunk.indexOf("\n");eol>-1&&(chunk=chunk.slice(0,eol))}return pos+chunk.length<=this.to?chunk:chunk.slice(0,this.to-pos)}nextLine(){let from=this.parsedPos,line=this.lineAfter(from),end=from+line.length;for(let index=this.rangeIndex;;){let rangeEnd=this.ranges[index].to;if(rangeEnd>=end)break;if(line=line.slice(0,rangeEnd-(end-line.length)),index++,index==this.ranges.length)break;let rangeStart=this.ranges[index].from,after=this.lineAfter(rangeStart);line+=after,end=rangeStart+after.length}return{line:line,end:end}}skipGapsTo(pos,offset,side){for(;;){let end=this.ranges[this.rangeIndex].to,offPos=pos+offset;if(side>0?end>offPos:end>=offPos)break;offset+=this.ranges[++this.rangeIndex].from-end}return offset}moveRangeIndex(){for(;this.ranges[this.rangeIndex].to<this.parsedPos;)this.rangeIndex++}emitToken(id,from,to,size,offset){if(this.ranges.length>1){from+=offset=this.skipGapsTo(from,offset,1);let len0=this.chunk.length;to+=offset=this.skipGapsTo(to,offset,-1),size+=this.chunk.length-len0}return this.chunk.push(id,from,to,size),offset}parseLine(context){let{line:line,end:end}=this.nextLine(),offset=0,{streamParser:streamParser}=this.lang,stream=new StringStream(line,context?context.state.tabSize:4,context?getIndentUnit(context.state):2);if(stream.eol())streamParser.blankLine(this.state,stream.indentUnit);else for(;!stream.eol();){let token=readToken(streamParser.token,stream,this.state);if(token&&(offset=this.emitToken(this.lang.tokenTable.resolve(token),this.parsedPos+stream.start,this.parsedPos+stream.pos,4,offset)),stream.start>1e4)break}this.parsedPos=end,this.moveRangeIndex(),this.parsedPos<this.to&&this.parsedPos++}finishChunk(){let tree=common.Tree.build({buffer:this.chunk,start:this.chunkStart,length:this.parsedPos-this.chunkStart,nodeSet:nodeSet,topID:0,maxBufferLength:2048,reused:this.chunkReused});tree=new common.Tree(tree.type,tree.children,tree.positions,tree.length,[[this.lang.stateAfter,this.lang.streamParser.copyState(this.state)]]),this.chunks.push(tree),this.chunkPos.push(this.chunkStart-this.ranges[0].from),this.chunk=[],this.chunkReused=void 0,this.chunkStart=this.parsedPos}finish(){return new common.Tree(this.lang.topNode,this.chunks,this.chunkPos,this.parsedPos-this.ranges[0].from).balance()}}function readToken(token,stream,state){stream.start=stream.pos;for(let i=0;i<10;i++){let result=token(stream,state);if(stream.pos>stream.start)return result}throw new Error("Stream parser failed to advance stream.")}const noTokens=Object.create(null),typeArray=[common.NodeType.none],nodeSet=new common.NodeSet(typeArray),warned=[],defaultTable=Object.create(null);for(let[legacyName,name]of[["variable","variableName"],["variable-2","variableName.special"],["string-2","string.special"],["def","variableName.definition"],["tag","tagName"],["attribute","attributeName"],["type","typeName"],["builtin","variableName.standard"],["qualifier","modifier"],["error","invalid"],["header","heading"],["property","propertyName"]])defaultTable[legacyName]=createTokenType(noTokens,name);class TokenTable{constructor(extra){this.extra=extra,this.table=Object.assign(Object.create(null),defaultTable)}resolve(tag){return tag?this.table[tag]||(this.table[tag]=createTokenType(this.extra,tag)):0}}const defaultTokenTable=new TokenTable(noTokens);function warnForPart(part,msg){warned.indexOf(part)>-1||(warned.push(part),console.warn(msg))}function createTokenType(extra,tagStr){let tag=null;for(let part of tagStr.split(".")){let value=extra[part]||highlight.tags[part];value?"function"==typeof value?tag?tag=value(tag):warnForPart(part,`Modifier ${part} used at start of tag`):tag?warnForPart(part,`Tag ${part} used as modifier`):tag=value:warnForPart(part,`Unknown highlighting tag ${part}`)}if(!tag)return 0;let name=tagStr.replace(/ /g,"_"),type=common.NodeType.define({id:typeArray.length,name:name,props:[highlight.styleTags({[name]:tag})]});return typeArray.push(type),type.id}exports.HighlightStyle=HighlightStyle,exports.IndentContext=IndentContext,exports.LRLanguage=LRLanguage,exports.Language=Language,exports.LanguageDescription=LanguageDescription,exports.LanguageSupport=class{constructor(language,support=[]){this.language=language,this.support=support,this.extension=[language,support]}},exports.ParseContext=ParseContext,exports.StreamLanguage=StreamLanguage,exports.StringStream=StringStream,exports.TreeIndentContext=TreeIndentContext,exports.bracketMatching=function(config={}){return[bracketMatchingConfig.of(config),bracketMatchingUnique]},exports.bracketMatchingHandle=bracketMatchingHandle,exports.codeFolding=codeFolding,exports.continuedIndent=function({except:except,units:units=1}={}){return context=>{let matchExcept=except&&except.test(context.textAfter);return context.baseIndent+(matchExcept?0:units*context.unit)}},exports.defaultHighlightStyle=defaultHighlightStyle,exports.defineLanguageFacet=defineLanguageFacet,exports.delimitedIndent=function({closing:closing,align:align=!0,units:units=1}){return context=>delimitedStrategy(context,align,units,closing)},exports.ensureSyntaxTree=ensureSyntaxTree,exports.flatIndent=context=>context.baseIndent,exports.foldAll=foldAll,exports.foldCode=foldCode,exports.foldEffect=foldEffect,exports.foldGutter=function(config={}){let fullConfig=Object.assign(Object.assign({},foldGutterDefaults),config),canFold=new FoldMarker(fullConfig,!0),canUnfold=new FoldMarker(fullConfig,!1),markers=view.ViewPlugin.fromClass(class{constructor(view){this.from=view.viewport.from,this.markers=this.buildMarkers(view)}update(update){(update.docChanged||update.viewportChanged||update.startState.facet(language)!=update.state.facet(language)||update.startState.field(foldState,!1)!=update.state.field(foldState,!1)||syntaxTree(update.startState)!=syntaxTree(update.state)||fullConfig.foldingChanged(update))&&(this.markers=this.buildMarkers(update.view))}buildMarkers(view){let builder=new state.RangeSetBuilder;for(let line of view.viewportLineBlocks){let mark=findFold(view.state,line.from,line.to)?canUnfold:foldable(view.state,line.from,line.to)?canFold:null;mark&&builder.add(line.from,line.from,mark)}return builder.finish()}}),{domEventHandlers:domEventHandlers}=fullConfig;return[markers,view.gutter({class:"cm-foldGutter",markers(view){var _a;return(null===(_a=view.plugin(markers))||void 0===_a?void 0:_a.markers)||state.RangeSet.empty},initialSpacer:()=>new FoldMarker(fullConfig,!1),domEventHandlers:Object.assign(Object.assign({},domEventHandlers),{click:(view,line,event)=>{if(domEventHandlers.click&&domEventHandlers.click(view,line,event))return!0;let folded=findFold(view.state,line.from,line.to);if(folded)return view.dispatch({effects:unfoldEffect.of(folded)}),!0;let range=foldable(view.state,line.from,line.to);return!!range&&(view.dispatch({effects:foldEffect.of(range)}),!0)}})}),codeFolding()]},exports.foldInside=function(node){let first=node.firstChild,last=node.lastChild;return first&&first.to<last.from?{from:first.to,to:last.type.isError?node.to:last.from}:null},exports.foldKeymap=foldKeymap,exports.foldNodeProp=foldNodeProp,exports.foldService=foldService,exports.foldState=foldState,exports.foldable=foldable,exports.foldedRanges=function(state$1){return state$1.field(foldState,!1)||state.RangeSet.empty},exports.forceParsing=function(view,upto=view.viewport.to,timeout=100){let success=ensureSyntaxTree(view.state,upto,timeout);return success!=syntaxTree(view.state)&&view.dispatch({}),!!success},exports.getIndentUnit=getIndentUnit,exports.getIndentation=getIndentation,exports.highlightingFor=function(state,tags,scope){let highlighters=getHighlighters(state),result=null;if(highlighters)for(let highlighter of highlighters)if(!highlighter.scope||scope&&highlighter.scope(scope)){let cls=highlighter.style(tags);cls&&(result=result?result+" "+cls:cls)}return result},exports.indentNodeProp=indentNodeProp,exports.indentOnInput=function(){return state.EditorState.transactionFilter.of((tr=>{if(!tr.docChanged||!tr.isUserEvent("input.type")&&!tr.isUserEvent("input.complete"))return tr;let rules=tr.startState.languageDataAt("indentOnInput",tr.startState.selection.main.head);if(!rules.length)return tr;let doc=tr.newDoc,{head:head}=tr.newSelection.main,line=doc.lineAt(head);if(head>line.from+200)return tr;let lineStart=doc.sliceString(line.from,head);if(!rules.some((r=>r.test(lineStart))))return tr;let{state:state}=tr,last=-1,changes=[];for(let{head:head}of state.selection.ranges){let line=state.doc.lineAt(head);if(line.from==last)continue;last=line.from;let indent=getIndentation(state,line.from);if(null==indent)continue;let cur=/^\s*/.exec(line.text)[0],norm=indentString(state,indent);cur!=norm&&changes.push({from:line.from,to:line.from+cur.length,insert:norm})}return changes.length?[tr,{changes:changes,sequential:!0}]:tr}))},exports.indentRange=function(state,from,to){let updated=Object.create(null),context=new IndentContext(state,{overrideIndentation:start=>{var _a;return null!==(_a=updated[start])&&void 0!==_a?_a:-1}}),changes=[];for(let pos=from;pos<=to;){let line=state.doc.lineAt(pos);pos=line.to+1;let indent=getIndentation(context,line.from);if(null==indent)continue;/\S/.test(line.text)||(indent=0);let cur=/^\s*/.exec(line.text)[0],norm=indentString(state,indent);cur!=norm&&(updated[line.from]=indent,changes.push({from:line.from,to:line.from+cur.length,insert:norm}))}return state.changes(changes)},exports.indentService=indentService,exports.indentString=indentString,exports.indentUnit=indentUnit,exports.language=language,exports.languageDataProp=languageDataProp,exports.matchBrackets=matchBrackets,exports.syntaxHighlighting=function(highlighter,options){let themeType,ext=[treeHighlighter];return highlighter instanceof HighlightStyle&&(highlighter.module&&ext.push(view.EditorView.styleModule.of(highlighter.module)),themeType=highlighter.themeType),(null==options?void 0:options.fallback)?ext.push(fallbackHighlighter.of(highlighter)):themeType?ext.push(highlighterFacet.computeN([view.EditorView.darkTheme],(state=>state.facet(view.EditorView.darkTheme)==("dark"==themeType)?[highlighter]:[]))):ext.push(highlighterFacet.of(highlighter)),ext},exports.syntaxParserRunning=function(view){var _a;return(null===(_a=view.plugin(parseWorker))||void 0===_a?void 0:_a.isWorking())||!1},exports.syntaxTree=syntaxTree,exports.syntaxTreeAvailable=function(state,upto=state.doc.length){var _a;return(null===(_a=state.field(Language.state,!1))||void 0===_a?void 0:_a.context.isDone(upto))||!1},exports.unfoldAll=unfoldAll,exports.unfoldCode=unfoldCode,exports.unfoldEffect=unfoldEffect},{"@codemirror/state":11,"@codemirror/view":12,"@lezer/common":13,"@lezer/highlight":14,"style-mod":17}],11:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class Text{constructor(){}lineAt(pos){if(pos<0||pos>this.length)throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);return this.lineInner(pos,!1,1,0)}line(n){if(n<1||n>this.lines)throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);return this.lineInner(n,!0,1,0)}replace(from,to,text){let parts=[];return this.decompose(0,from,parts,2),text.length&&text.decompose(0,text.length,parts,3),this.decompose(to,this.length,parts,1),TextNode.from(parts,this.length-(to-from)+text.length)}append(other){return this.replace(this.length,this.length,other)}slice(from,to=this.length){let parts=[];return this.decompose(from,to,parts,0),TextNode.from(parts,to-from)}eq(other){if(other==this)return!0;if(other.length!=this.length||other.lines!=this.lines)return!1;let start=this.scanIdentical(other,1),end=this.length-this.scanIdentical(other,-1),a=new RawTextCursor(this),b=new RawTextCursor(other);for(let skip=start,pos=start;;){if(a.next(skip),b.next(skip),skip=0,a.lineBreak!=b.lineBreak||a.done!=b.done||a.value!=b.value)return!1;if(pos+=a.value.length,a.done||pos>=end)return!0}}iter(dir=1){return new RawTextCursor(this,dir)}iterRange(from,to=this.length){return new PartialTextCursor(this,from,to)}iterLines(from,to){let inner;if(null==from)inner=this.iter();else{null==to&&(to=this.lines+1);let start=this.line(from).from;inner=this.iterRange(start,Math.max(start,to==this.lines+1?this.length:to<=1?0:this.line(to-1).to))}return new LineCursor(inner)}toString(){return this.sliceString(0)}toJSON(){let lines=[];return this.flatten(lines),lines}static of(text){if(0==text.length)throw new RangeError("A document must have at least one line");return 1!=text.length||text[0]?text.length<=32?new TextLeaf(text):TextNode.from(TextLeaf.split(text,[])):Text.empty}}class TextLeaf extends Text{constructor(text,length=function(text){let length=-1;for(let line of text)length+=line.length+1;return length}(text)){super(),this.text=text,this.length=length}get lines(){return this.text.length}get children(){return null}lineInner(target,isLine,line,offset){for(let i=0;;i++){let string=this.text[i],end=offset+string.length;if((isLine?line:end)>=target)return new Line(offset,end,line,string);offset=end+1,line++}}decompose(from,to,target,open){let text=from<=0&&to>=this.length?this:new TextLeaf(sliceText(this.text,from,to),Math.min(to,this.length)-Math.max(0,from));if(1&open){let prev=target.pop(),joined=appendText(text.text,prev.text.slice(),0,text.length);if(joined.length<=32)target.push(new TextLeaf(joined,prev.length+text.length));else{let mid=joined.length>>1;target.push(new TextLeaf(joined.slice(0,mid)),new TextLeaf(joined.slice(mid)))}}else target.push(text)}replace(from,to,text){if(!(text instanceof TextLeaf))return super.replace(from,to,text);let lines=appendText(this.text,appendText(text.text,sliceText(this.text,0,from)),to),newLen=this.length+text.length-(to-from);return lines.length<=32?new TextLeaf(lines,newLen):TextNode.from(TextLeaf.split(lines,[]),newLen)}sliceString(from,to=this.length,lineSep="\n"){let result="";for(let pos=0,i=0;pos<=to&&i<this.text.length;i++){let line=this.text[i],end=pos+line.length;pos>from&&i&&(result+=lineSep),from<end&&to>pos&&(result+=line.slice(Math.max(0,from-pos),to-pos)),pos=end+1}return result}flatten(target){for(let line of this.text)target.push(line)}scanIdentical(){return 0}static split(text,target){let part=[],len=-1;for(let line of text)part.push(line),len+=line.length+1,32==part.length&&(target.push(new TextLeaf(part,len)),part=[],len=-1);return len>-1&&target.push(new TextLeaf(part,len)),target}}class TextNode extends Text{constructor(children,length){super(),this.children=children,this.length=length,this.lines=0;for(let child of children)this.lines+=child.lines}lineInner(target,isLine,line,offset){for(let i=0;;i++){let child=this.children[i],end=offset+child.length,endLine=line+child.lines-1;if((isLine?endLine:end)>=target)return child.lineInner(target,isLine,line,offset);offset=end+1,line=endLine+1}}decompose(from,to,target,open){for(let i=0,pos=0;pos<=to&&i<this.children.length;i++){let child=this.children[i],end=pos+child.length;if(from<=end&&to>=pos){let childOpen=open&((pos<=from?1:0)|(end>=to?2:0));pos>=from&&end<=to&&!childOpen?target.push(child):child.decompose(from-pos,to-pos,target,childOpen)}pos=end+1}}replace(from,to,text){if(text.lines<this.lines)for(let i=0,pos=0;i<this.children.length;i++){let child=this.children[i],end=pos+child.length;if(from>=pos&&to<=end){let updated=child.replace(from-pos,to-pos,text),totalLines=this.lines-child.lines+updated.lines;if(updated.lines<totalLines>>4&&updated.lines>totalLines>>6){let copy=this.children.slice();return copy[i]=updated,new TextNode(copy,this.length-(to-from)+text.length)}return super.replace(pos,end,updated)}pos=end+1}return super.replace(from,to,text)}sliceString(from,to=this.length,lineSep="\n"){let result="";for(let i=0,pos=0;i<this.children.length&&pos<=to;i++){let child=this.children[i],end=pos+child.length;pos>from&&i&&(result+=lineSep),from<end&&to>pos&&(result+=child.sliceString(from-pos,to-pos,lineSep)),pos=end+1}return result}flatten(target){for(let child of this.children)child.flatten(target)}scanIdentical(other,dir){if(!(other instanceof TextNode))return 0;let length=0,[iA,iB,eA,eB]=dir>0?[0,0,this.children.length,other.children.length]:[this.children.length-1,other.children.length-1,-1,-1];for(;;iA+=dir,iB+=dir){if(iA==eA||iB==eB)return length;let chA=this.children[iA],chB=other.children[iB];if(chA!=chB)return length+chA.scanIdentical(chB,dir);length+=chA.length+1}}static from(children,length=children.reduce(((l,ch)=>l+ch.length+1),-1)){let lines=0;for(let ch of children)lines+=ch.lines;if(lines<32){let flat=[];for(let ch of children)ch.flatten(flat);return new TextLeaf(flat,length)}let chunk=Math.max(32,lines>>5),maxChunk=chunk<<1,minChunk=chunk>>1,chunked=[],currentLines=0,currentLen=-1,currentChunk=[];function add(child){let last;if(child.lines>maxChunk&&child instanceof TextNode)for(let node of child.children)add(node);else child.lines>minChunk&&(currentLines>minChunk||!currentLines)?(flush(),chunked.push(child)):child instanceof TextLeaf&&currentLines&&(last=currentChunk[currentChunk.length-1])instanceof TextLeaf&&child.lines+last.lines<=32?(currentLines+=child.lines,currentLen+=child.length+1,currentChunk[currentChunk.length-1]=new TextLeaf(last.text.concat(child.text),last.length+1+child.length)):(currentLines+child.lines>chunk&&flush(),currentLines+=child.lines,currentLen+=child.length+1,currentChunk.push(child))}function flush(){0!=currentLines&&(chunked.push(1==currentChunk.length?currentChunk[0]:TextNode.from(currentChunk,currentLen)),currentLen=-1,currentLines=currentChunk.length=0)}for(let child of children)add(child);return flush(),1==chunked.length?chunked[0]:new TextNode(chunked,length)}}function appendText(text,target,from=0,to=1e9){for(let pos=0,i=0,first=!0;i<text.length&&pos<=to;i++){let line=text[i],end=pos+line.length;end>=from&&(end>to&&(line=line.slice(0,to-pos)),pos<from&&(line=line.slice(from-pos)),first?(target[target.length-1]+=line,first=!1):target.push(line)),pos=end+1}return target}function sliceText(text,from,to){return appendText(text,[""],from,to)}Text.empty=new TextLeaf([""],0);class RawTextCursor{constructor(text,dir=1){this.dir=dir,this.done=!1,this.lineBreak=!1,this.value="",this.nodes=[text],this.offsets=[dir>0?1:(text instanceof TextLeaf?text.text.length:text.children.length)<<1]}nextInner(skip,dir){for(this.done=this.lineBreak=!1;;){let last=this.nodes.length-1,top=this.nodes[last],offsetValue=this.offsets[last],offset=offsetValue>>1,size=top instanceof TextLeaf?top.text.length:top.children.length;if(offset==(dir>0?size:0)){if(0==last)return this.done=!0,this.value="",this;dir>0&&this.offsets[last-1]++,this.nodes.pop(),this.offsets.pop()}else if((1&offsetValue)==(dir>0?0:1)){if(this.offsets[last]+=dir,0==skip)return this.lineBreak=!0,this.value="\n",this;skip--}else if(top instanceof TextLeaf){let next=top.text[offset+(dir<0?-1:0)];if(this.offsets[last]+=dir,next.length>Math.max(0,skip))return this.value=0==skip?next:dir>0?next.slice(skip):next.slice(0,next.length-skip),this;skip-=next.length}else{let next=top.children[offset+(dir<0?-1:0)];skip>next.length?(skip-=next.length,this.offsets[last]+=dir):(dir<0&&this.offsets[last]--,this.nodes.push(next),this.offsets.push(dir>0?1:(next instanceof TextLeaf?next.text.length:next.children.length)<<1))}}}next(skip=0){return skip<0&&(this.nextInner(-skip,-this.dir),skip=this.value.length),this.nextInner(skip,this.dir)}}class PartialTextCursor{constructor(text,start,end){this.value="",this.done=!1,this.cursor=new RawTextCursor(text,start>end?-1:1),this.pos=start>end?text.length:0,this.from=Math.min(start,end),this.to=Math.max(start,end)}nextInner(skip,dir){if(dir<0?this.pos<=this.from:this.pos>=this.to)return this.value="",this.done=!0,this;skip+=Math.max(0,dir<0?this.pos-this.to:this.from-this.pos);let limit=dir<0?this.pos-this.from:this.to-this.pos;skip>limit&&(skip=limit),limit-=skip;let{value:value}=this.cursor.next(skip);return this.pos+=(value.length+skip)*dir,this.value=value.length<=limit?value:dir<0?value.slice(value.length-limit):value.slice(0,limit),this.done=!this.value,this}next(skip=0){return skip<0?skip=Math.max(skip,this.from-this.pos):skip>0&&(skip=Math.min(skip,this.to-this.pos)),this.nextInner(skip,this.cursor.dir)}get lineBreak(){return this.cursor.lineBreak&&""!=this.value}}class LineCursor{constructor(inner){this.inner=inner,this.afterBreak=!0,this.value="",this.done=!1}next(skip=0){let{done:done,lineBreak:lineBreak,value:value}=this.inner.next(skip);return done?(this.done=!0,this.value=""):lineBreak?this.afterBreak?this.value="":(this.afterBreak=!0,this.next()):(this.value=value,this.afterBreak=!1),this}get lineBreak(){return!1}}"undefined"!=typeof Symbol&&(Text.prototype[Symbol.iterator]=function(){return this.iter()},RawTextCursor.prototype[Symbol.iterator]=PartialTextCursor.prototype[Symbol.iterator]=LineCursor.prototype[Symbol.iterator]=function(){return this});class Line{constructor(from,to,number,text){this.from=from,this.to=to,this.number=number,this.text=text}get length(){return this.to-this.from}}let extend="lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s=>s?parseInt(s,36):1));for(let i=1;i<extend.length;i++)extend[i]+=extend[i-1];function isExtendingChar(code){for(let i=1;i<extend.length;i+=2)if(extend[i]>code)return extend[i-1]<=code;return!1}function isRegionalIndicator(code){return code>=127462&&code<=127487}function findClusterBreak(str,pos,forward=!0,includeExtending=!0){return(forward?nextClusterBreak:prevClusterBreak)(str,pos,includeExtending)}function nextClusterBreak(str,pos,includeExtending){if(pos==str.length)return pos;pos&&surrogateLow(str.charCodeAt(pos))&&surrogateHigh(str.charCodeAt(pos-1))&&pos--;let prev=codePointAt(str,pos);for(pos+=codePointSize(prev);pos<str.length;){let next=codePointAt(str,pos);if(8205==prev||8205==next||includeExtending&&isExtendingChar(next))pos+=codePointSize(next),prev=next;else{if(!isRegionalIndicator(next))break;{let countBefore=0,i=pos-2;for(;i>=0&&isRegionalIndicator(codePointAt(str,i));)countBefore++,i-=2;if(countBefore%2==0)break;pos+=2}}}return pos}function prevClusterBreak(str,pos,includeExtending){for(;pos>0;){let found=nextClusterBreak(str,pos-2,includeExtending);if(found<pos)return found;pos--}return 0}function surrogateLow(ch){return ch>=56320&&ch<57344}function surrogateHigh(ch){return ch>=55296&&ch<56320}function codePointAt(str,pos){let code0=str.charCodeAt(pos);if(!surrogateHigh(code0)||pos+1==str.length)return code0;let code1=str.charCodeAt(pos+1);return surrogateLow(code1)?code1-56320+(code0-55296<<10)+65536:code0}function codePointSize(code){return code<65536?1:2}const DefaultSplit=/\r\n?|\n/;var MapMode;exports.MapMode=void 0,(MapMode=exports.MapMode||(exports.MapMode={}))[MapMode.Simple=0]="Simple",MapMode[MapMode.TrackDel=1]="TrackDel",MapMode[MapMode.TrackBefore=2]="TrackBefore",MapMode[MapMode.TrackAfter=3]="TrackAfter";class ChangeDesc{constructor(sections){this.sections=sections}get length(){let result=0;for(let i=0;i<this.sections.length;i+=2)result+=this.sections[i];return result}get newLength(){let result=0;for(let i=0;i<this.sections.length;i+=2){let ins=this.sections[i+1];result+=ins<0?this.sections[i]:ins}return result}get empty(){return 0==this.sections.length||2==this.sections.length&&this.sections[1]<0}iterGaps(f){for(let i=0,posA=0,posB=0;i<this.sections.length;){let len=this.sections[i++],ins=this.sections[i++];ins<0?(f(posA,posB,len),posB+=len):posB+=ins,posA+=len}}iterChangedRanges(f,individual=!1){iterChanges(this,f,individual)}get invertedDesc(){let sections=[];for(let i=0;i<this.sections.length;){let len=this.sections[i++],ins=this.sections[i++];ins<0?sections.push(len,ins):sections.push(ins,len)}return new ChangeDesc(sections)}composeDesc(other){return this.empty?other:other.empty?this:composeSets(this,other)}mapDesc(other,before=!1){return other.empty?this:mapSet(this,other,before)}mapPos(pos,assoc=-1,mode=exports.MapMode.Simple){let posA=0,posB=0;for(let i=0;i<this.sections.length;){let len=this.sections[i++],ins=this.sections[i++],endA=posA+len;if(ins<0){if(endA>pos)return posB+(pos-posA);posB+=len}else{if(mode!=exports.MapMode.Simple&&endA>=pos&&(mode==exports.MapMode.TrackDel&&posA<pos&&endA>pos||mode==exports.MapMode.TrackBefore&&posA<pos||mode==exports.MapMode.TrackAfter&&endA>pos))return null;if(endA>pos||endA==pos&&assoc<0&&!len)return pos==posA||assoc<0?posB:posB+ins;posB+=ins}posA=endA}if(pos>posA)throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);return posB}touchesRange(from,to=from){for(let i=0,pos=0;i<this.sections.length&&pos<=to;){let end=pos+this.sections[i++];if(this.sections[i++]>=0&&pos<=to&&end>=from)return!(pos<from&&end>to)||"cover";pos=end}return!1}toString(){let result="";for(let i=0;i<this.sections.length;){let len=this.sections[i++],ins=this.sections[i++];result+=(result?" ":"")+len+(ins>=0?":"+ins:"")}return result}toJSON(){return this.sections}static fromJSON(json){if(!Array.isArray(json)||json.length%2||json.some((a=>"number"!=typeof a)))throw new RangeError("Invalid JSON representation of ChangeDesc");return new ChangeDesc(json)}static create(sections){return new ChangeDesc(sections)}}class ChangeSet extends ChangeDesc{constructor(sections,inserted){super(sections),this.inserted=inserted}apply(doc){if(this.length!=doc.length)throw new RangeError("Applying change set to a document with the wrong length");return iterChanges(this,((fromA,toA,fromB,_toB,text)=>doc=doc.replace(fromB,fromB+(toA-fromA),text)),!1),doc}mapDesc(other,before=!1){return mapSet(this,other,before,!0)}invert(doc){let sections=this.sections.slice(),inserted=[];for(let i=0,pos=0;i<sections.length;i+=2){let len=sections[i],ins=sections[i+1];if(ins>=0){sections[i]=ins,sections[i+1]=len;let index=i>>1;for(;inserted.length<index;)inserted.push(Text.empty);inserted.push(len?doc.slice(pos,pos+len):Text.empty)}pos+=len}return new ChangeSet(sections,inserted)}compose(other){return this.empty?other:other.empty?this:composeSets(this,other,!0)}map(other,before=!1){return other.empty?this:mapSet(this,other,before,!0)}iterChanges(f,individual=!1){iterChanges(this,f,individual)}get desc(){return ChangeDesc.create(this.sections)}filter(ranges){let resultSections=[],resultInserted=[],filteredSections=[],iter=new SectionIter(this);done:for(let i=0,pos=0;;){let next=i==ranges.length?1e9:ranges[i++];for(;pos<next||pos==next&&0==iter.len;){if(iter.done)break done;let len=Math.min(iter.len,next-pos);addSection(filteredSections,len,-1);let ins=-1==iter.ins?-1:0==iter.off?iter.ins:0;addSection(resultSections,len,ins),ins>0&&addInsert(resultInserted,resultSections,iter.text),iter.forward(len),pos+=len}let end=ranges[i++];for(;pos<end;){if(iter.done)break done;let len=Math.min(iter.len,end-pos);addSection(resultSections,len,-1),addSection(filteredSections,len,-1==iter.ins?-1:0==iter.off?iter.ins:0),iter.forward(len),pos+=len}}return{changes:new ChangeSet(resultSections,resultInserted),filtered:ChangeDesc.create(filteredSections)}}toJSON(){let parts=[];for(let i=0;i<this.sections.length;i+=2){let len=this.sections[i],ins=this.sections[i+1];ins<0?parts.push(len):0==ins?parts.push([len]):parts.push([len].concat(this.inserted[i>>1].toJSON()))}return parts}static of(changes,length,lineSep){let sections=[],inserted=[],pos=0,total=null;function flush(force=!1){if(!force&&!sections.length)return;pos<length&&addSection(sections,length-pos,-1);let set=new ChangeSet(sections,inserted);total=total?total.compose(set.map(total)):set,sections=[],inserted=[],pos=0}return function process(spec){if(Array.isArray(spec))for(let sub of spec)process(sub);else if(spec instanceof ChangeSet){if(spec.length!=length)throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);flush(),total=total?total.compose(spec.map(total)):spec}else{let{from:from,to:to=from,insert:insert}=spec;if(from>to||from<0||to>length)throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);let insText=insert?"string"==typeof insert?Text.of(insert.split(lineSep||DefaultSplit)):insert:Text.empty,insLen=insText.length;if(from==to&&0==insLen)return;from<pos&&flush(),from>pos&&addSection(sections,from-pos,-1),addSection(sections,to-from,insLen),addInsert(inserted,sections,insText),pos=to}}(changes),flush(!total),total}static empty(length){return new ChangeSet(length?[length,-1]:[],[])}static fromJSON(json){if(!Array.isArray(json))throw new RangeError("Invalid JSON representation of ChangeSet");let sections=[],inserted=[];for(let i=0;i<json.length;i++){let part=json[i];if("number"==typeof part)sections.push(part,-1);else{if(!Array.isArray(part)||"number"!=typeof part[0]||part.some(((e,i)=>i&&"string"!=typeof e)))throw new RangeError("Invalid JSON representation of ChangeSet");if(1==part.length)sections.push(part[0],0);else{for(;inserted.length<i;)inserted.push(Text.empty);inserted[i]=Text.of(part.slice(1)),sections.push(part[0],inserted[i].length)}}}return new ChangeSet(sections,inserted)}static createSet(sections,inserted){return new ChangeSet(sections,inserted)}}function addSection(sections,len,ins,forceJoin=!1){if(0==len&&ins<=0)return;let last=sections.length-2;last>=0&&ins<=0&&ins==sections[last+1]?sections[last]+=len:0==len&&0==sections[last]?sections[last+1]+=ins:forceJoin?(sections[last]+=len,sections[last+1]+=ins):sections.push(len,ins)}function addInsert(values,sections,value){if(0==value.length)return;let index=sections.length-2>>1;if(index<values.length)values[values.length-1]=values[values.length-1].append(value);else{for(;values.length<index;)values.push(Text.empty);values.push(value)}}function iterChanges(desc,f,individual){let inserted=desc.inserted;for(let posA=0,posB=0,i=0;i<desc.sections.length;){let len=desc.sections[i++],ins=desc.sections[i++];if(ins<0)posA+=len,posB+=len;else{let endA=posA,endB=posB,text=Text.empty;for(;endA+=len,endB+=ins,ins&&inserted&&(text=text.append(inserted[i-2>>1])),!(individual||i==desc.sections.length||desc.sections[i+1]<0);)len=desc.sections[i++],ins=desc.sections[i++];f(posA,endA,posB,endB,text),posA=endA,posB=endB}}}function mapSet(setA,setB,before,mkSet=!1){let sections=[],insert=mkSet?[]:null,a=new SectionIter(setA),b=new SectionIter(setB);for(let inserted=-1;;)if(-1==a.ins&&-1==b.ins){let len=Math.min(a.len,b.len);addSection(sections,len,-1),a.forward(len),b.forward(len)}else if(b.ins>=0&&(a.ins<0||inserted==a.i||0==a.off&&(b.len<a.len||b.len==a.len&&!before))){let len=b.len;for(addSection(sections,b.ins,-1);len;){let piece=Math.min(a.len,len);a.ins>=0&&inserted<a.i&&a.len<=piece&&(addSection(sections,0,a.ins),insert&&addInsert(insert,sections,a.text),inserted=a.i),a.forward(piece),len-=piece}b.next()}else{if(!(a.ins>=0)){if(a.done&&b.done)return insert?ChangeSet.createSet(sections,insert):ChangeDesc.create(sections);throw new Error("Mismatched change set lengths")}{let len=0,left=a.len;for(;left;)if(-1==b.ins){let piece=Math.min(left,b.len);len+=piece,left-=piece,b.forward(piece)}else{if(!(0==b.ins&&b.len<left))break;left-=b.len,b.next()}addSection(sections,len,inserted<a.i?a.ins:0),insert&&inserted<a.i&&addInsert(insert,sections,a.text),inserted=a.i,a.forward(a.len-left)}}}function composeSets(setA,setB,mkSet=!1){let sections=[],insert=mkSet?[]:null,a=new SectionIter(setA),b=new SectionIter(setB);for(let open=!1;;){if(a.done&&b.done)return insert?ChangeSet.createSet(sections,insert):ChangeDesc.create(sections);if(0==a.ins)addSection(sections,a.len,0,open),a.next();else if(0!=b.len||b.done){if(a.done||b.done)throw new Error("Mismatched change set lengths");{let len=Math.min(a.len2,b.len),sectionLen=sections.length;if(-1==a.ins){let insB=-1==b.ins?-1:b.off?0:b.ins;addSection(sections,len,insB,open),insert&&insB&&addInsert(insert,sections,b.text)}else-1==b.ins?(addSection(sections,a.off?0:a.len,len,open),insert&&addInsert(insert,sections,a.textBit(len))):(addSection(sections,a.off?0:a.len,b.off?0:b.ins,open),insert&&!b.off&&addInsert(insert,sections,b.text));open=(a.ins>len||b.ins>=0&&b.len>len)&&(open||sections.length>sectionLen),a.forward2(len),b.forward(len)}}else addSection(sections,0,b.ins,open),insert&&addInsert(insert,sections,b.text),b.next()}}class SectionIter{constructor(set){this.set=set,this.i=0,this.next()}next(){let{sections:sections}=this.set;this.i<sections.length?(this.len=sections[this.i++],this.ins=sections[this.i++]):(this.len=0,this.ins=-2),this.off=0}get done(){return-2==this.ins}get len2(){return this.ins<0?this.len:this.ins}get text(){let{inserted:inserted}=this.set,index=this.i-2>>1;return index>=inserted.length?Text.empty:inserted[index]}textBit(len){let{inserted:inserted}=this.set,index=this.i-2>>1;return index>=inserted.length&&!len?Text.empty:inserted[index].slice(this.off,null==len?void 0:this.off+len)}forward(len){len==this.len?this.next():(this.len-=len,this.off+=len)}forward2(len){-1==this.ins?this.forward(len):len==this.ins?this.next():(this.ins-=len,this.off+=len)}}class SelectionRange{constructor(from,to,flags){this.from=from,this.to=to,this.flags=flags}get anchor(){return 16&this.flags?this.to:this.from}get head(){return 16&this.flags?this.from:this.to}get empty(){return this.from==this.to}get assoc(){return 4&this.flags?-1:8&this.flags?1:0}get bidiLevel(){let level=3&this.flags;return 3==level?null:level}get goalColumn(){let value=this.flags>>5;return 33554431==value?void 0:value}map(change,assoc=-1){let from,to;return this.empty?from=to=change.mapPos(this.from,assoc):(from=change.mapPos(this.from,1),to=change.mapPos(this.to,-1)),from==this.from&&to==this.to?this:new SelectionRange(from,to,this.flags)}extend(from,to=from){if(from<=this.anchor&&to>=this.anchor)return EditorSelection.range(from,to);let head=Math.abs(from-this.anchor)>Math.abs(to-this.anchor)?from:to;return EditorSelection.range(this.anchor,head)}eq(other){return this.anchor==other.anchor&&this.head==other.head}toJSON(){return{anchor:this.anchor,head:this.head}}static fromJSON(json){if(!json||"number"!=typeof json.anchor||"number"!=typeof json.head)throw new RangeError("Invalid JSON representation for SelectionRange");return EditorSelection.range(json.anchor,json.head)}static create(from,to,flags){return new SelectionRange(from,to,flags)}}class EditorSelection{constructor(ranges,mainIndex){this.ranges=ranges,this.mainIndex=mainIndex}map(change,assoc=-1){return change.empty?this:EditorSelection.create(this.ranges.map((r=>r.map(change,assoc))),this.mainIndex)}eq(other){if(this.ranges.length!=other.ranges.length||this.mainIndex!=other.mainIndex)return!1;for(let i=0;i<this.ranges.length;i++)if(!this.ranges[i].eq(other.ranges[i]))return!1;return!0}get main(){return this.ranges[this.mainIndex]}asSingle(){return 1==this.ranges.length?this:new EditorSelection([this.main],0)}addRange(range,main=!0){return EditorSelection.create([range].concat(this.ranges),main?0:this.mainIndex+1)}replaceRange(range,which=this.mainIndex){let ranges=this.ranges.slice();return ranges[which]=range,EditorSelection.create(ranges,this.mainIndex)}toJSON(){return{ranges:this.ranges.map((r=>r.toJSON())),main:this.mainIndex}}static fromJSON(json){if(!json||!Array.isArray(json.ranges)||"number"!=typeof json.main||json.main>=json.ranges.length)throw new RangeError("Invalid JSON representation for EditorSelection");return new EditorSelection(json.ranges.map((r=>SelectionRange.fromJSON(r))),json.main)}static single(anchor,head=anchor){return new EditorSelection([EditorSelection.range(anchor,head)],0)}static create(ranges,mainIndex=0){if(0==ranges.length)throw new RangeError("A selection needs at least one range");for(let pos=0,i=0;i<ranges.length;i++){let range=ranges[i];if(range.empty?range.from<=pos:range.from<pos)return EditorSelection.normalized(ranges.slice(),mainIndex);pos=range.to}return new EditorSelection(ranges,mainIndex)}static cursor(pos,assoc=0,bidiLevel,goalColumn){return SelectionRange.create(pos,pos,(0==assoc?0:assoc<0?4:8)|(null==bidiLevel?3:Math.min(2,bidiLevel))|(null!=goalColumn?goalColumn:33554431)<<5)}static range(anchor,head,goalColumn,bidiLevel){let flags=(null!=goalColumn?goalColumn:33554431)<<5|(null==bidiLevel?3:Math.min(2,bidiLevel));return head<anchor?SelectionRange.create(head,anchor,24|flags):SelectionRange.create(anchor,head,(head>anchor?4:0)|flags)}static normalized(ranges,mainIndex=0){let main=ranges[mainIndex];ranges.sort(((a,b)=>a.from-b.from)),mainIndex=ranges.indexOf(main);for(let i=1;i<ranges.length;i++){let range=ranges[i],prev=ranges[i-1];if(range.empty?range.from<=prev.to:range.from<prev.to){let from=prev.from,to=Math.max(range.to,prev.to);i<=mainIndex&&mainIndex--,ranges.splice(--i,2,range.anchor>range.head?EditorSelection.range(to,from):EditorSelection.range(from,to))}}return new EditorSelection(ranges,mainIndex)}}function checkSelection(selection,docLength){for(let range of selection.ranges)if(range.to>docLength)throw new RangeError("Selection points outside of document")}let nextID=0;class Facet{constructor(combine,compareInput,compare,isStatic,enables){this.combine=combine,this.compareInput=compareInput,this.compare=compare,this.isStatic=isStatic,this.id=nextID++,this.default=combine([]),this.extensions="function"==typeof enables?enables(this):enables}static define(config={}){return new Facet(config.combine||(a=>a),config.compareInput||((a,b)=>a===b),config.compare||(config.combine?(a,b)=>a===b:sameArray),!!config.static,config.enables)}of(value){return new FacetProvider([],this,0,value)}compute(deps,get){if(this.isStatic)throw new Error("Can't compute a static facet");return new FacetProvider(deps,this,1,get)}computeN(deps,get){if(this.isStatic)throw new Error("Can't compute a static facet");return new FacetProvider(deps,this,2,get)}from(field,get){return get||(get=x=>x),this.compute([field],(state=>get(state.field(field))))}}function sameArray(a,b){return a==b||a.length==b.length&&a.every(((e,i)=>e===b[i]))}class FacetProvider{constructor(dependencies,facet,type,value){this.dependencies=dependencies,this.facet=facet,this.type=type,this.value=value,this.id=nextID++}dynamicSlot(addresses){var _a;let getter=this.value,compare=this.facet.compareInput,id=this.id,idx=addresses[id]>>1,multi=2==this.type,depDoc=!1,depSel=!1,depAddrs=[];for(let dep of this.dependencies)"doc"==dep?depDoc=!0:"selection"==dep?depSel=!0:0==(1&(null!==(_a=addresses[dep.id])&&void 0!==_a?_a:1))&&depAddrs.push(addresses[dep.id]);return{create:state=>(state.values[idx]=getter(state),1),update(state,tr){if(depDoc&&tr.docChanged||depSel&&(tr.docChanged||tr.selection)||ensureAll(state,depAddrs)){let newVal=getter(state);if(multi?!compareArray(newVal,state.values[idx],compare):!compare(newVal,state.values[idx]))return state.values[idx]=newVal,1}return 0},reconfigure:(state,oldState)=>{let newVal,oldAddr=oldState.config.address[id];if(null!=oldAddr){let oldVal=getAddr(oldState,oldAddr);if(this.dependencies.every((dep=>dep instanceof Facet?oldState.facet(dep)===state.facet(dep):!(dep instanceof StateField)||oldState.field(dep,!1)==state.field(dep,!1)))||(multi?compareArray(newVal=getter(state),oldVal,compare):compare(newVal=getter(state),oldVal)))return state.values[idx]=oldVal,0}else newVal=getter(state);return state.values[idx]=newVal,1}}}}function compareArray(a,b,compare){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!compare(a[i],b[i]))return!1;return!0}function ensureAll(state,addrs){let changed=!1;for(let addr of addrs)1&ensureAddr(state,addr)&&(changed=!0);return changed}function dynamicFacetSlot(addresses,facet,providers){let providerAddrs=providers.map((p=>addresses[p.id])),providerTypes=providers.map((p=>p.type)),dynamic=providerAddrs.filter((p=>!(1&p))),idx=addresses[facet.id]>>1;function get(state){let values=[];for(let i=0;i<providerAddrs.length;i++){let value=getAddr(state,providerAddrs[i]);if(2==providerTypes[i])for(let val of value)values.push(val);else values.push(value)}return facet.combine(values)}return{create(state){for(let addr of providerAddrs)ensureAddr(state,addr);return state.values[idx]=get(state),1},update(state,tr){if(!ensureAll(state,dynamic))return 0;let value=get(state);return facet.compare(value,state.values[idx])?0:(state.values[idx]=value,1)},reconfigure(state,oldState){let depChanged=ensureAll(state,providerAddrs),oldProviders=oldState.config.facets[facet.id],oldValue=oldState.facet(facet);if(oldProviders&&!depChanged&&sameArray(providers,oldProviders))return state.values[idx]=oldValue,0;let value=get(state);return facet.compare(value,oldValue)?(state.values[idx]=oldValue,0):(state.values[idx]=value,1)}}}const initField=Facet.define({static:!0});class StateField{constructor(id,createF,updateF,compareF,spec){this.id=id,this.createF=createF,this.updateF=updateF,this.compareF=compareF,this.spec=spec,this.provides=void 0}static define(config){let field=new StateField(nextID++,config.create,config.update,config.compare||((a,b)=>a===b),config);return config.provide&&(field.provides=config.provide(field)),field}create(state){let init=state.facet(initField).find((i=>i.field==this));return((null==init?void 0:init.create)||this.createF)(state)}slot(addresses){let idx=addresses[this.id]>>1;return{create:state=>(state.values[idx]=this.create(state),1),update:(state,tr)=>{let oldVal=state.values[idx],value=this.updateF(oldVal,tr);return this.compareF(oldVal,value)?0:(state.values[idx]=value,1)},reconfigure:(state,oldState)=>null!=oldState.config.address[this.id]?(state.values[idx]=oldState.field(this),0):(state.values[idx]=this.create(state),1)}}init(create){return[this,initField.of({field:this,create:create})]}get extension(){return this}}const Prec__lowest=4,Prec__low=3,Prec__default=2,Prec__high=1;function prec(value){return ext=>new PrecExtension(ext,value)}const Prec={highest:prec(0),high:prec(Prec__high),default:prec(Prec__default),low:prec(Prec__low),lowest:prec(Prec__lowest)};class PrecExtension{constructor(inner,prec){this.inner=inner,this.prec=prec}}class Compartment{of(ext){return new CompartmentInstance(this,ext)}reconfigure(content){return Compartment.reconfigure.of({compartment:this,extension:content})}get(state){return state.config.compartments.get(this)}}class CompartmentInstance{constructor(compartment,inner){this.compartment=compartment,this.inner=inner}}class Configuration{constructor(base,compartments,dynamicSlots,address,staticValues,facets){for(this.base=base,this.compartments=compartments,this.dynamicSlots=dynamicSlots,this.address=address,this.staticValues=staticValues,this.facets=facets,this.statusTemplate=[];this.statusTemplate.length<dynamicSlots.length;)this.statusTemplate.push(0)}staticFacet(facet){let addr=this.address[facet.id];return null==addr?facet.default:this.staticValues[addr>>1]}static resolve(base,compartments,oldState){let fields=[],facets=Object.create(null),newCompartments=new Map;for(let ext of function(extension,compartments,newCompartments){let result=[[],[],[],[],[]],seen=new Map;function inner(ext,prec){let known=seen.get(ext);if(null!=known){if(known<=prec)return;let found=result[known].indexOf(ext);found>-1&&result[known].splice(found,1),ext instanceof CompartmentInstance&&newCompartments.delete(ext.compartment)}if(seen.set(ext,prec),Array.isArray(ext))for(let e of ext)inner(e,prec);else if(ext instanceof CompartmentInstance){if(newCompartments.has(ext.compartment))throw new RangeError("Duplicate use of compartment in extensions");let content=compartments.get(ext.compartment)||ext.inner;newCompartments.set(ext.compartment,content),inner(content,prec)}else if(ext instanceof PrecExtension)inner(ext.inner,ext.prec);else if(ext instanceof StateField)result[prec].push(ext),ext.provides&&inner(ext.provides,prec);else if(ext instanceof FacetProvider)result[prec].push(ext),ext.facet.extensions&&inner(ext.facet.extensions,Prec__default);else{let content=ext.extension;if(!content)throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);inner(content,prec)}}return inner(extension,Prec__default),result.reduce(((a,b)=>a.concat(b)))}(base,compartments,newCompartments))ext instanceof StateField?fields.push(ext):(facets[ext.facet.id]||(facets[ext.facet.id]=[])).push(ext);let address=Object.create(null),staticValues=[],dynamicSlots=[];for(let field of fields)address[field.id]=dynamicSlots.length<<1,dynamicSlots.push((a=>field.slot(a)));let oldFacets=null==oldState?void 0:oldState.config.facets;for(let id in facets){let providers=facets[id],facet=providers[0].facet,oldProviders=oldFacets&&oldFacets[id]||[];if(providers.every((p=>0==p.type)))if(address[facet.id]=staticValues.length<<1|1,sameArray(oldProviders,providers))staticValues.push(oldState.facet(facet));else{let value=facet.combine(providers.map((p=>p.value)));staticValues.push(oldState&&facet.compare(value,oldState.facet(facet))?oldState.facet(facet):value)}else{for(let p of providers)0==p.type?(address[p.id]=staticValues.length<<1|1,staticValues.push(p.value)):(address[p.id]=dynamicSlots.length<<1,dynamicSlots.push((a=>p.dynamicSlot(a))));address[facet.id]=dynamicSlots.length<<1,dynamicSlots.push((a=>dynamicFacetSlot(a,facet,providers)))}}let dynamic=dynamicSlots.map((f=>f(address)));return new Configuration(base,newCompartments,dynamic,address,staticValues,facets)}}function ensureAddr(state,addr){if(1&addr)return 2;let idx=addr>>1,status=state.status[idx];if(4==status)throw new Error("Cyclic dependency between fields and/or facets");if(2&status)return status;state.status[idx]=4;let changed=state.computeSlot(state,state.config.dynamicSlots[idx]);return state.status[idx]=2|changed}function getAddr(state,addr){return 1&addr?state.config.staticValues[addr>>1]:state.values[addr>>1]}const languageData=Facet.define(),allowMultipleSelections=Facet.define({combine:values=>values.some((v=>v)),static:!0}),lineSeparator=Facet.define({combine:values=>values.length?values[0]:void 0,static:!0}),changeFilter=Facet.define(),transactionFilter=Facet.define(),transactionExtender=Facet.define(),readOnly=Facet.define({combine:values=>!!values.length&&values[0]});class Annotation{constructor(type,value){this.type=type,this.value=value}static define(){return new AnnotationType}}class AnnotationType{of(value){return new Annotation(this,value)}}class StateEffectType{constructor(map){this.map=map}of(value){return new StateEffect(this,value)}}class StateEffect{constructor(type,value){this.type=type,this.value=value}map(mapping){let mapped=this.type.map(this.value,mapping);return void 0===mapped?void 0:mapped==this.value?this:new StateEffect(this.type,mapped)}is(type){return this.type==type}static define(spec={}){return new StateEffectType(spec.map||(v=>v))}static mapEffects(effects,mapping){if(!effects.length)return effects;let result=[];for(let effect of effects){let mapped=effect.map(mapping);mapped&&result.push(mapped)}return result}}StateEffect.reconfigure=StateEffect.define(),StateEffect.appendConfig=StateEffect.define();class Transaction{constructor(startState,changes,selection,effects,annotations,scrollIntoView){this.startState=startState,this.changes=changes,this.selection=selection,this.effects=effects,this.annotations=annotations,this.scrollIntoView=scrollIntoView,this._doc=null,this._state=null,selection&&checkSelection(selection,changes.newLength),annotations.some((a=>a.type==Transaction.time))||(this.annotations=annotations.concat(Transaction.time.of(Date.now())))}static create(startState,changes,selection,effects,annotations,scrollIntoView){return new Transaction(startState,changes,selection,effects,annotations,scrollIntoView)}get newDoc(){return this._doc||(this._doc=this.changes.apply(this.startState.doc))}get newSelection(){return this.selection||this.startState.selection.map(this.changes)}get state(){return this._state||this.startState.applyTransaction(this),this._state}annotation(type){for(let ann of this.annotations)if(ann.type==type)return ann.value}get docChanged(){return!this.changes.empty}get reconfigured(){return this.startState.config!=this.state.config}isUserEvent(event){let e=this.annotation(Transaction.userEvent);return!(!e||!(e==event||e.length>event.length&&e.slice(0,event.length)==event&&"."==e[event.length]))}}function joinRanges(a,b){let result=[];for(let iA=0,iB=0;;){let from,to;if(iA<a.length&&(iB==b.length||b[iB]>=a[iA]))from=a[iA++],to=a[iA++];else{if(!(iB<b.length))return result;from=b[iB++],to=b[iB++]}!result.length||result[result.length-1]<from?result.push(from,to):result[result.length-1]<to&&(result[result.length-1]=to)}}function mergeTransaction(a,b,sequential){var _a;let mapForA,mapForB,changes;return sequential?(mapForA=b.changes,mapForB=ChangeSet.empty(b.changes.length),changes=a.changes.compose(b.changes)):(mapForA=b.changes.map(a.changes),mapForB=a.changes.mapDesc(b.changes,!0),changes=a.changes.compose(mapForA)),{changes:changes,selection:b.selection?b.selection.map(mapForB):null===(_a=a.selection)||void 0===_a?void 0:_a.map(mapForA),effects:StateEffect.mapEffects(a.effects,mapForA).concat(StateEffect.mapEffects(b.effects,mapForB)),annotations:a.annotations.length?a.annotations.concat(b.annotations):b.annotations,scrollIntoView:a.scrollIntoView||b.scrollIntoView}}function resolveTransactionInner(state,spec,docSize){let sel=spec.selection,annotations=asArray(spec.annotations);return spec.userEvent&&(annotations=annotations.concat(Transaction.userEvent.of(spec.userEvent))),{changes:spec.changes instanceof ChangeSet?spec.changes:ChangeSet.of(spec.changes||[],docSize,state.facet(lineSeparator)),selection:sel&&(sel instanceof EditorSelection?sel:EditorSelection.single(sel.anchor,sel.head)),effects:asArray(spec.effects),annotations:annotations,scrollIntoView:!!spec.scrollIntoView}}function resolveTransaction(state,specs,filter){let s=resolveTransactionInner(state,specs.length?specs[0]:{},state.doc.length);specs.length&&!1===specs[0].filter&&(filter=!1);for(let i=1;i<specs.length;i++){!1===specs[i].filter&&(filter=!1);let seq=!!specs[i].sequential;s=mergeTransaction(s,resolveTransactionInner(state,specs[i],seq?s.changes.newLength:state.doc.length),seq)}let tr=Transaction.create(state,s.changes,s.selection,s.effects,s.annotations,s.scrollIntoView);return function(tr){let state=tr.startState,extenders=state.facet(transactionExtender),spec=tr;for(let i=extenders.length-1;i>=0;i--){let extension=extenders[i](tr);extension&&Object.keys(extension).length&&(spec=mergeTransaction(spec,resolveTransactionInner(state,extension,tr.changes.newLength),!0))}return spec==tr?tr:Transaction.create(state,tr.changes,tr.selection,spec.effects,spec.annotations,spec.scrollIntoView)}(filter?function(tr){let state=tr.startState,result=!0;for(let filter of state.facet(changeFilter)){let value=filter(tr);if(!1===value){result=!1;break}Array.isArray(value)&&(result=!0===result?value:joinRanges(result,value))}if(!0!==result){let changes,back;if(!1===result)back=tr.changes.invertedDesc,changes=ChangeSet.empty(state.doc.length);else{let filtered=tr.changes.filter(result);changes=filtered.changes,back=filtered.filtered.mapDesc(filtered.changes).invertedDesc}tr=Transaction.create(state,changes,tr.selection&&tr.selection.map(back),StateEffect.mapEffects(tr.effects,back),tr.annotations,tr.scrollIntoView)}let filters=state.facet(transactionFilter);for(let i=filters.length-1;i>=0;i--){let filtered=filters[i](tr);tr=filtered instanceof Transaction?filtered:Array.isArray(filtered)&&1==filtered.length&&filtered[0]instanceof Transaction?filtered[0]:resolveTransaction(state,asArray(filtered),!1)}return tr}(tr):tr)}Transaction.time=Annotation.define(),Transaction.userEvent=Annotation.define(),Transaction.addToHistory=Annotation.define(),Transaction.remote=Annotation.define();const none=[];function asArray(value){return null==value?none:Array.isArray(value)?value:[value]}var CharCategory;exports.CharCategory=void 0,(CharCategory=exports.CharCategory||(exports.CharCategory={}))[CharCategory.Word=0]="Word",CharCategory[CharCategory.Space=1]="Space",CharCategory[CharCategory.Other=2]="Other";const nonASCIISingleCaseWordChar=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;let wordChar;try{wordChar=new RegExp("[\\p{Alphabetic}\\p{Number}_]","u")}catch(_){}function makeCategorizer(wordChars){return char=>{if(!/\S/.test(char))return exports.CharCategory.Space;if(function(str){if(wordChar)return wordChar.test(str);for(let i=0;i<str.length;i++){let ch=str[i];if(/\w/.test(ch)||ch>""&&(ch.toUpperCase()!=ch.toLowerCase()||nonASCIISingleCaseWordChar.test(ch)))return!0}return!1}(char))return exports.CharCategory.Word;for(let i=0;i<wordChars.length;i++)if(char.indexOf(wordChars[i])>-1)return exports.CharCategory.Word;return exports.CharCategory.Other}}class EditorState{constructor(config,doc,selection,values,computeSlot,tr){this.config=config,this.doc=doc,this.selection=selection,this.values=values,this.status=config.statusTemplate.slice(),this.computeSlot=computeSlot,tr&&(tr._state=this);for(let i=0;i<this.config.dynamicSlots.length;i++)ensureAddr(this,i<<1);this.computeSlot=null}field(field,require=!0){let addr=this.config.address[field.id];if(null!=addr)return ensureAddr(this,addr),getAddr(this,addr);if(require)throw new RangeError("Field is not present in this state")}update(...specs){return resolveTransaction(this,specs,!0)}applyTransaction(tr){let startValues,conf=this.config,{base:base,compartments:compartments}=conf;for(let effect of tr.effects)effect.is(Compartment.reconfigure)?(conf&&(compartments=new Map,conf.compartments.forEach(((val,key)=>compartments.set(key,val))),conf=null),compartments.set(effect.value.compartment,effect.value.extension)):effect.is(StateEffect.reconfigure)?(conf=null,base=effect.value):effect.is(StateEffect.appendConfig)&&(conf=null,base=asArray(base).concat(effect.value));if(conf)startValues=tr.startState.values.slice();else{conf=Configuration.resolve(base,compartments,this),startValues=new EditorState(conf,this.doc,this.selection,conf.dynamicSlots.map((()=>null)),((state,slot)=>slot.reconfigure(state,this)),null).values}new EditorState(conf,tr.newDoc,tr.newSelection,startValues,((state,slot)=>slot.update(state,tr)),tr)}replaceSelection(text){return"string"==typeof text&&(text=this.toText(text)),this.changeByRange((range=>({changes:{from:range.from,to:range.to,insert:text},range:EditorSelection.cursor(range.from+text.length)})))}changeByRange(f){let sel=this.selection,result1=f(sel.ranges[0]),changes=this.changes(result1.changes),ranges=[result1.range],effects=asArray(result1.effects);for(let i=1;i<sel.ranges.length;i++){let result=f(sel.ranges[i]),newChanges=this.changes(result.changes),newMapped=newChanges.map(changes);for(let j=0;j<i;j++)ranges[j]=ranges[j].map(newMapped);let mapBy=changes.mapDesc(newChanges,!0);ranges.push(result.range.map(mapBy)),changes=changes.compose(newMapped),effects=StateEffect.mapEffects(effects,newMapped).concat(StateEffect.mapEffects(asArray(result.effects),mapBy))}return{changes:changes,selection:EditorSelection.create(ranges,sel.mainIndex),effects:effects}}changes(spec=[]){return spec instanceof ChangeSet?spec:ChangeSet.of(spec,this.doc.length,this.facet(EditorState.lineSeparator))}toText(string){return Text.of(string.split(this.facet(EditorState.lineSeparator)||DefaultSplit))}sliceDoc(from=0,to=this.doc.length){return this.doc.sliceString(from,to,this.lineBreak)}facet(facet){let addr=this.config.address[facet.id];return null==addr?facet.default:(ensureAddr(this,addr),getAddr(this,addr))}toJSON(fields){let result={doc:this.sliceDoc(),selection:this.selection.toJSON()};if(fields)for(let prop in fields){let value=fields[prop];value instanceof StateField&&null!=this.config.address[value.id]&&(result[prop]=value.spec.toJSON(this.field(fields[prop]),this))}return result}static fromJSON(json,config={},fields){if(!json||"string"!=typeof json.doc)throw new RangeError("Invalid JSON representation for EditorState");let fieldInit=[];if(fields)for(let prop in fields)if(Object.prototype.hasOwnProperty.call(json,prop)){let field=fields[prop],value=json[prop];fieldInit.push(field.init((state=>field.spec.fromJSON(value,state))))}return EditorState.create({doc:json.doc,selection:EditorSelection.fromJSON(json.selection),extensions:config.extensions?fieldInit.concat([config.extensions]):fieldInit})}static create(config={}){let configuration=Configuration.resolve(config.extensions||[],new Map),doc=config.doc instanceof Text?config.doc:Text.of((config.doc||"").split(configuration.staticFacet(EditorState.lineSeparator)||DefaultSplit)),selection=config.selection?config.selection instanceof EditorSelection?config.selection:EditorSelection.single(config.selection.anchor,config.selection.head):EditorSelection.single(0);return checkSelection(selection,doc.length),configuration.staticFacet(allowMultipleSelections)||(selection=selection.asSingle()),new EditorState(configuration,doc,selection,configuration.dynamicSlots.map((()=>null)),((state,slot)=>slot.create(state)),null)}get tabSize(){return this.facet(EditorState.tabSize)}get lineBreak(){return this.facet(EditorState.lineSeparator)||"\n"}get readOnly(){return this.facet(readOnly)}phrase(phrase,...insert){for(let map of this.facet(EditorState.phrases))if(Object.prototype.hasOwnProperty.call(map,phrase)){phrase=map[phrase];break}return insert.length&&(phrase=phrase.replace(/\$(\$|\d*)/g,((m,i)=>{if("$"==i)return"$";let n=+(i||1);return!n||n>insert.length?m:insert[n-1]}))),phrase}languageDataAt(name,pos,side=-1){let values=[];for(let provider of this.facet(languageData))for(let result of provider(this,pos,side))Object.prototype.hasOwnProperty.call(result,name)&&values.push(result[name]);return values}charCategorizer(at){return makeCategorizer(this.languageDataAt("wordChars",at).join(""))}wordAt(pos){let{text:text,from:from,length:length}=this.doc.lineAt(pos),cat=this.charCategorizer(pos),start=pos-from,end=pos-from;for(;start>0;){let prev=findClusterBreak(text,start,!1);if(cat(text.slice(prev,start))!=exports.CharCategory.Word)break;start=prev}for(;end<length;){let next=findClusterBreak(text,end);if(cat(text.slice(end,next))!=exports.CharCategory.Word)break;end=next}return start==end?null:EditorSelection.range(start+from,end+from)}}EditorState.allowMultipleSelections=allowMultipleSelections,EditorState.tabSize=Facet.define({combine:values=>values.length?values[0]:4}),EditorState.lineSeparator=lineSeparator,EditorState.readOnly=readOnly,EditorState.phrases=Facet.define({compare(a,b){let kA=Object.keys(a),kB=Object.keys(b);return kA.length==kB.length&&kA.every((k=>a[k]==b[k]))}}),EditorState.languageData=languageData,EditorState.changeFilter=changeFilter,EditorState.transactionFilter=transactionFilter,EditorState.transactionExtender=transactionExtender,Compartment.reconfigure=StateEffect.define();class RangeValue{eq(other){return this==other}range(from,to=from){return Range.create(from,to,this)}}RangeValue.prototype.startSide=RangeValue.prototype.endSide=0,RangeValue.prototype.point=!1,RangeValue.prototype.mapMode=exports.MapMode.TrackDel;class Range{constructor(from,to,value){this.from=from,this.to=to,this.value=value}static create(from,to,value){return new Range(from,to,value)}}function cmpRange(a,b){return a.from-b.from||a.value.startSide-b.value.startSide}class Chunk{constructor(from,to,value,maxPoint){this.from=from,this.to=to,this.value=value,this.maxPoint=maxPoint}get length(){return this.to[this.to.length-1]}findIndex(pos,side,end,startAt=0){let arr=end?this.to:this.from;for(let lo=startAt,hi=arr.length;;){if(lo==hi)return lo;let mid=lo+hi>>1,diff=arr[mid]-pos||(end?this.value[mid].endSide:this.value[mid].startSide)-side;if(mid==lo)return diff>=0?lo:hi;diff>=0?hi=mid:lo=mid+1}}between(offset,from,to,f){for(let i=this.findIndex(from,-1e9,!0),e=this.findIndex(to,1e9,!1,i);i<e;i++)if(!1===f(this.from[i]+offset,this.to[i]+offset,this.value[i]))return!1}map(offset,changes){let value=[],from=[],to=[],newPos=-1,maxPoint=-1;for(let i=0;i<this.value.length;i++){let newFrom,newTo,val=this.value[i],curFrom=this.from[i]+offset,curTo=this.to[i]+offset;if(curFrom==curTo){let mapped=changes.mapPos(curFrom,val.startSide,val.mapMode);if(null==mapped)continue;if(newFrom=newTo=mapped,val.startSide!=val.endSide&&(newTo=changes.mapPos(curFrom,val.endSide),newTo<newFrom))continue}else if(newFrom=changes.mapPos(curFrom,val.startSide),newTo=changes.mapPos(curTo,val.endSide),newFrom>newTo||newFrom==newTo&&val.startSide>0&&val.endSide<=0)continue;(newTo-newFrom||val.endSide-val.startSide)<0||(newPos<0&&(newPos=newFrom),val.point&&(maxPoint=Math.max(maxPoint,newTo-newFrom)),value.push(val),from.push(newFrom-newPos),to.push(newTo-newPos))}return{mapped:value.length?new Chunk(from,to,value,maxPoint):null,pos:newPos}}}class RangeSet{constructor(chunkPos,chunk,nextLayer,maxPoint){this.chunkPos=chunkPos,this.chunk=chunk,this.nextLayer=nextLayer,this.maxPoint=maxPoint}static create(chunkPos,chunk,nextLayer,maxPoint){return new RangeSet(chunkPos,chunk,nextLayer,maxPoint)}get length(){let last=this.chunk.length-1;return last<0?0:Math.max(this.chunkEnd(last),this.nextLayer.length)}get size(){if(this.isEmpty)return 0;let size=this.nextLayer.size;for(let chunk of this.chunk)size+=chunk.value.length;return size}chunkEnd(index){return this.chunkPos[index]+this.chunk[index].length}update(updateSpec){let{add:add=[],sort:sort=!1,filterFrom:filterFrom=0,filterTo:filterTo=this.length}=updateSpec,filter=updateSpec.filter;if(0==add.length&&!filter)return this;if(sort&&(add=add.slice().sort(cmpRange)),this.isEmpty)return add.length?RangeSet.of(add):this;let cur=new LayerCursor(this,null,-1).goto(0),i=0,spill=[],builder=new RangeSetBuilder;for(;cur.value||i<add.length;)if(i<add.length&&(cur.from-add[i].from||cur.startSide-add[i].value.startSide)>=0){let range=add[i++];builder.addInner(range.from,range.to,range.value)||spill.push(range)}else 1==cur.rangeIndex&&cur.chunkIndex<this.chunk.length&&(i==add.length||this.chunkEnd(cur.chunkIndex)<add[i].from)&&(!filter||filterFrom>this.chunkEnd(cur.chunkIndex)||filterTo<this.chunkPos[cur.chunkIndex])&&builder.addChunk(this.chunkPos[cur.chunkIndex],this.chunk[cur.chunkIndex])?cur.nextChunk():((!filter||filterFrom>cur.to||filterTo<cur.from||filter(cur.from,cur.to,cur.value))&&(builder.addInner(cur.from,cur.to,cur.value)||spill.push(Range.create(cur.from,cur.to,cur.value))),cur.next());return builder.finishInner(this.nextLayer.isEmpty&&!spill.length?RangeSet.empty:this.nextLayer.update({add:spill,filter:filter,filterFrom:filterFrom,filterTo:filterTo}))}map(changes){if(changes.empty||this.isEmpty)return this;let chunks=[],chunkPos=[],maxPoint=-1;for(let i=0;i<this.chunk.length;i++){let start=this.chunkPos[i],chunk=this.chunk[i],touch=changes.touchesRange(start,start+chunk.length);if(!1===touch)maxPoint=Math.max(maxPoint,chunk.maxPoint),chunks.push(chunk),chunkPos.push(changes.mapPos(start));else if(!0===touch){let{mapped:mapped,pos:pos}=chunk.map(start,changes);mapped&&(maxPoint=Math.max(maxPoint,mapped.maxPoint),chunks.push(mapped),chunkPos.push(pos))}}let next=this.nextLayer.map(changes);return 0==chunks.length?next:new RangeSet(chunkPos,chunks,next||RangeSet.empty,maxPoint)}between(from,to,f){if(!this.isEmpty){for(let i=0;i<this.chunk.length;i++){let start=this.chunkPos[i],chunk=this.chunk[i];if(to>=start&&from<=start+chunk.length&&!1===chunk.between(start,from-start,to-start,f))return}this.nextLayer.between(from,to,f)}}iter(from=0){return HeapCursor.from([this]).goto(from)}get isEmpty(){return this.nextLayer==this}static iter(sets,from=0){return HeapCursor.from(sets).goto(from)}static compare(oldSets,newSets,textDiff,comparator,minPointSize=-1){let a=oldSets.filter((set=>set.maxPoint>0||!set.isEmpty&&set.maxPoint>=minPointSize)),b=newSets.filter((set=>set.maxPoint>0||!set.isEmpty&&set.maxPoint>=minPointSize)),sharedChunks=findSharedChunks(a,b,textDiff),sideA=new SpanCursor(a,sharedChunks,minPointSize),sideB=new SpanCursor(b,sharedChunks,minPointSize);textDiff.iterGaps(((fromA,fromB,length)=>compare(sideA,fromA,sideB,fromB,length,comparator))),textDiff.empty&&0==textDiff.length&&compare(sideA,0,sideB,0,0,comparator)}static eq(oldSets,newSets,from=0,to){null==to&&(to=999999999);let a=oldSets.filter((set=>!set.isEmpty&&newSets.indexOf(set)<0)),b=newSets.filter((set=>!set.isEmpty&&oldSets.indexOf(set)<0));if(a.length!=b.length)return!1;if(!a.length)return!0;let sharedChunks=findSharedChunks(a,b),sideA=new SpanCursor(a,sharedChunks,0).goto(from),sideB=new SpanCursor(b,sharedChunks,0).goto(from);for(;;){if(sideA.to!=sideB.to||!sameValues(sideA.active,sideB.active)||sideA.point&&(!sideB.point||!sideA.point.eq(sideB.point)))return!1;if(sideA.to>to)return!0;sideA.next(),sideB.next()}}static spans(sets,from,to,iterator,minPointSize=-1){let cursor=new SpanCursor(sets,null,minPointSize).goto(from),pos=from,openRanges=cursor.openStart;for(;;){let curTo=Math.min(cursor.to,to);if(cursor.point){let active=cursor.activeForPoint(cursor.to),openCount=cursor.pointFrom<from?active.length+1:Math.min(active.length,openRanges);iterator.point(pos,curTo,cursor.point,active,openCount,cursor.pointRank),openRanges=Math.min(cursor.openEnd(curTo),active.length)}else curTo>pos&&(iterator.span(pos,curTo,cursor.active,openRanges),openRanges=cursor.openEnd(curTo));if(cursor.to>to)return openRanges+(cursor.point&&cursor.to>to?1:0);pos=cursor.to,cursor.next()}}static of(ranges,sort=!1){let build=new RangeSetBuilder;for(let range of ranges instanceof Range?[ranges]:sort?function(ranges){if(ranges.length>1)for(let prev=ranges[0],i=1;i<ranges.length;i++){let cur=ranges[i];if(cmpRange(prev,cur)>0)return ranges.slice().sort(cmpRange);prev=cur}return ranges}(ranges):ranges)build.add(range.from,range.to,range.value);return build.finish()}}RangeSet.empty=new RangeSet([],[],null,-1),RangeSet.empty.nextLayer=RangeSet.empty;class RangeSetBuilder{constructor(){this.chunks=[],this.chunkPos=[],this.chunkStart=-1,this.last=null,this.lastFrom=-1e9,this.lastTo=-1e9,this.from=[],this.to=[],this.value=[],this.maxPoint=-1,this.setMaxPoint=-1,this.nextLayer=null}finishChunk(newArrays){this.chunks.push(new Chunk(this.from,this.to,this.value,this.maxPoint)),this.chunkPos.push(this.chunkStart),this.chunkStart=-1,this.setMaxPoint=Math.max(this.setMaxPoint,this.maxPoint),this.maxPoint=-1,newArrays&&(this.from=[],this.to=[],this.value=[])}add(from,to,value){this.addInner(from,to,value)||(this.nextLayer||(this.nextLayer=new RangeSetBuilder)).add(from,to,value)}addInner(from,to,value){let diff=from-this.lastTo||value.startSide-this.last.endSide;if(diff<=0&&(from-this.lastFrom||value.startSide-this.last.startSide)<0)throw new Error("Ranges must be added sorted by `from` position and `startSide`");return!(diff<0)&&(250==this.from.length&&this.finishChunk(!0),this.chunkStart<0&&(this.chunkStart=from),this.from.push(from-this.chunkStart),this.to.push(to-this.chunkStart),this.last=value,this.lastFrom=from,this.lastTo=to,this.value.push(value),value.point&&(this.maxPoint=Math.max(this.maxPoint,to-from)),!0)}addChunk(from,chunk){if((from-this.lastTo||chunk.value[0].startSide-this.last.endSide)<0)return!1;this.from.length&&this.finishChunk(!0),this.setMaxPoint=Math.max(this.setMaxPoint,chunk.maxPoint),this.chunks.push(chunk),this.chunkPos.push(from);let last=chunk.value.length-1;return this.last=chunk.value[last],this.lastFrom=chunk.from[last]+from,this.lastTo=chunk.to[last]+from,!0}finish(){return this.finishInner(RangeSet.empty)}finishInner(next){if(this.from.length&&this.finishChunk(!1),0==this.chunks.length)return next;let result=RangeSet.create(this.chunkPos,this.chunks,this.nextLayer?this.nextLayer.finishInner(next):next,this.setMaxPoint);return this.from=null,result}}function findSharedChunks(a,b,textDiff){let inA=new Map;for(let set of a)for(let i=0;i<set.chunk.length;i++)set.chunk[i].maxPoint<=0&&inA.set(set.chunk[i],set.chunkPos[i]);let shared=new Set;for(let set of b)for(let i=0;i<set.chunk.length;i++){let known=inA.get(set.chunk[i]);null==known||(textDiff?textDiff.mapPos(known):known)!=set.chunkPos[i]||(null==textDiff?void 0:textDiff.touchesRange(known,known+set.chunk[i].length))||shared.add(set.chunk[i])}return shared}class LayerCursor{constructor(layer,skip,minPoint,rank=0){this.layer=layer,this.skip=skip,this.minPoint=minPoint,this.rank=rank}get startSide(){return this.value?this.value.startSide:0}get endSide(){return this.value?this.value.endSide:0}goto(pos,side=-1e9){return this.chunkIndex=this.rangeIndex=0,this.gotoInner(pos,side,!1),this}gotoInner(pos,side,forward){for(;this.chunkIndex<this.layer.chunk.length;){let next=this.layer.chunk[this.chunkIndex];if(!(this.skip&&this.skip.has(next)||this.layer.chunkEnd(this.chunkIndex)<pos||next.maxPoint<this.minPoint))break;this.chunkIndex++,forward=!1}if(this.chunkIndex<this.layer.chunk.length){let rangeIndex=this.layer.chunk[this.chunkIndex].findIndex(pos-this.layer.chunkPos[this.chunkIndex],side,!0);(!forward||this.rangeIndex<rangeIndex)&&this.setRangeIndex(rangeIndex)}this.next()}forward(pos,side){(this.to-pos||this.endSide-side)<0&&this.gotoInner(pos,side,!0)}next(){for(;;){if(this.chunkIndex==this.layer.chunk.length){this.from=this.to=1e9,this.value=null;break}{let chunkPos=this.layer.chunkPos[this.chunkIndex],chunk=this.layer.chunk[this.chunkIndex],from=chunkPos+chunk.from[this.rangeIndex];if(this.from=from,this.to=chunkPos+chunk.to[this.rangeIndex],this.value=chunk.value[this.rangeIndex],this.setRangeIndex(this.rangeIndex+1),this.minPoint<0||this.value.point&&this.to-this.from>=this.minPoint)break}}}setRangeIndex(index){if(index==this.layer.chunk[this.chunkIndex].value.length){if(this.chunkIndex++,this.skip)for(;this.chunkIndex<this.layer.chunk.length&&this.skip.has(this.layer.chunk[this.chunkIndex]);)this.chunkIndex++;this.rangeIndex=0}else this.rangeIndex=index}nextChunk(){this.chunkIndex++,this.rangeIndex=0,this.next()}compare(other){return this.from-other.from||this.startSide-other.startSide||this.rank-other.rank||this.to-other.to||this.endSide-other.endSide}}class HeapCursor{constructor(heap){this.heap=heap}static from(sets,skip=null,minPoint=-1){let heap=[];for(let i=0;i<sets.length;i++)for(let cur=sets[i];!cur.isEmpty;cur=cur.nextLayer)cur.maxPoint>=minPoint&&heap.push(new LayerCursor(cur,skip,minPoint,i));return 1==heap.length?heap[0]:new HeapCursor(heap)}get startSide(){return this.value?this.value.startSide:0}goto(pos,side=-1e9){for(let cur of this.heap)cur.goto(pos,side);for(let i=this.heap.length>>1;i>=0;i--)heapBubble(this.heap,i);return this.next(),this}forward(pos,side){for(let cur of this.heap)cur.forward(pos,side);for(let i=this.heap.length>>1;i>=0;i--)heapBubble(this.heap,i);(this.to-pos||this.value.endSide-side)<0&&this.next()}next(){if(0==this.heap.length)this.from=this.to=1e9,this.value=null,this.rank=-1;else{let top=this.heap[0];this.from=top.from,this.to=top.to,this.value=top.value,this.rank=top.rank,top.value&&top.next(),heapBubble(this.heap,0)}}}function heapBubble(heap,index){for(let cur=heap[index];;){let childIndex=1+(index<<1);if(childIndex>=heap.length)break;let child=heap[childIndex];if(childIndex+1<heap.length&&child.compare(heap[childIndex+1])>=0&&(child=heap[childIndex+1],childIndex++),cur.compare(child)<0)break;heap[childIndex]=cur,heap[index]=child,index=childIndex}}class SpanCursor{constructor(sets,skip,minPoint){this.minPoint=minPoint,this.active=[],this.activeTo=[],this.activeRank=[],this.minActive=-1,this.point=null,this.pointFrom=0,this.pointRank=0,this.to=-1e9,this.endSide=0,this.openStart=-1,this.cursor=HeapCursor.from(sets,skip,minPoint)}goto(pos,side=-1e9){return this.cursor.goto(pos,side),this.active.length=this.activeTo.length=this.activeRank.length=0,this.minActive=-1,this.to=pos,this.endSide=side,this.openStart=-1,this.next(),this}forward(pos,side){for(;this.minActive>-1&&(this.activeTo[this.minActive]-pos||this.active[this.minActive].endSide-side)<0;)this.removeActive(this.minActive);this.cursor.forward(pos,side)}removeActive(index){remove(this.active,index),remove(this.activeTo,index),remove(this.activeRank,index),this.minActive=findMinIndex(this.active,this.activeTo)}addActive(trackOpen){let i=0,{value:value,to:to,rank:rank}=this.cursor;for(;i<this.activeRank.length&&this.activeRank[i]<=rank;)i++;insert(this.active,i,value),insert(this.activeTo,i,to),insert(this.activeRank,i,rank),trackOpen&&insert(trackOpen,i,this.cursor.from),this.minActive=findMinIndex(this.active,this.activeTo)}next(){let from=this.to,wasPoint=this.point;this.point=null;let trackOpen=this.openStart<0?[]:null;for(;;){let a=this.minActive;if(a>-1&&(this.activeTo[a]-this.cursor.from||this.active[a].endSide-this.cursor.startSide)<0){if(this.activeTo[a]>from){this.to=this.activeTo[a],this.endSide=this.active[a].endSide;break}this.removeActive(a),trackOpen&&remove(trackOpen,a)}else{if(!this.cursor.value){this.to=this.endSide=1e9;break}if(this.cursor.from>from){this.to=this.cursor.from,this.endSide=this.cursor.startSide;break}{let nextVal=this.cursor.value;if(nextVal.point){if(!(wasPoint&&this.cursor.to==this.to&&this.cursor.from<this.cursor.to)){this.point=nextVal,this.pointFrom=this.cursor.from,this.pointRank=this.cursor.rank,this.to=this.cursor.to,this.endSide=nextVal.endSide,this.cursor.next(),this.forward(this.to,this.endSide);break}this.cursor.next()}else this.addActive(trackOpen),this.cursor.next()}}}if(trackOpen){this.openStart=0;for(let i=trackOpen.length-1;i>=0&&trackOpen[i]<from;i--)this.openStart++}}activeForPoint(to){if(!this.active.length)return this.active;let active=[];for(let i=this.active.length-1;i>=0&&!(this.activeRank[i]<this.pointRank);i--)(this.activeTo[i]>to||this.activeTo[i]==to&&this.active[i].endSide>=this.point.endSide)&&active.push(this.active[i]);return active.reverse()}openEnd(to){let open=0;for(let i=this.activeTo.length-1;i>=0&&this.activeTo[i]>to;i--)open++;return open}}function compare(a,startA,b,startB,length,comparator){a.goto(startA),b.goto(startB);let endB=startB+length,pos=startB,dPos=startB-startA;for(;;){let diff=a.to+dPos-b.to||a.endSide-b.endSide,end=diff<0?a.to+dPos:b.to,clipEnd=Math.min(end,endB);if(a.point||b.point?a.point&&b.point&&(a.point==b.point||a.point.eq(b.point))&&sameValues(a.activeForPoint(a.to+dPos),b.activeForPoint(b.to))||comparator.comparePoint(pos,clipEnd,a.point,b.point):clipEnd>pos&&!sameValues(a.active,b.active)&&comparator.compareRange(pos,clipEnd,a.active,b.active),end>endB)break;pos=end,diff<=0&&a.next(),diff>=0&&b.next()}}function sameValues(a,b){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(a[i]!=b[i]&&!a[i].eq(b[i]))return!1;return!0}function remove(array,index){for(let i=index,e=array.length-1;i<e;i++)array[i]=array[i+1];array.pop()}function insert(array,index,value){for(let i=array.length-1;i>=index;i--)array[i+1]=array[i];array[index]=value}function findMinIndex(value,array){let found=-1,foundPos=1e9;for(let i=0;i<array.length;i++)(array[i]-foundPos||value[i].endSide-value[found].endSide)<0&&(found=i,foundPos=array[i]);return found}exports.Annotation=Annotation,exports.AnnotationType=AnnotationType,exports.ChangeDesc=ChangeDesc,exports.ChangeSet=ChangeSet,exports.Compartment=Compartment,exports.EditorSelection=EditorSelection,exports.EditorState=EditorState,exports.Facet=Facet,exports.Line=Line,exports.Prec=Prec,exports.Range=Range,exports.RangeSet=RangeSet,exports.RangeSetBuilder=RangeSetBuilder,exports.RangeValue=RangeValue,exports.SelectionRange=SelectionRange,exports.StateEffect=StateEffect,exports.StateEffectType=StateEffectType,exports.StateField=StateField,exports.Text=Text,exports.Transaction=Transaction,exports.codePointAt=codePointAt,exports.codePointSize=codePointSize,exports.combineConfig=function(configs,defaults,combine={}){let result={};for(let config of configs)for(let key of Object.keys(config)){let value=config[key],current=result[key];if(void 0===current)result[key]=value;else if(current===value||void 0===value);else{if(!Object.hasOwnProperty.call(combine,key))throw new Error("Config merge conflict for field "+key);result[key]=combine[key](current,value)}}for(let key in defaults)void 0===result[key]&&(result[key]=defaults[key]);return result},exports.countColumn=function(string,tabSize,to=string.length){let n=0;for(let i=0;i<to;)9==string.charCodeAt(i)?(n+=tabSize-n%tabSize,i++):(n++,i=findClusterBreak(string,i));return n},exports.findClusterBreak=findClusterBreak,exports.findColumn=function(string,col,tabSize,strict){for(let i=0,n=0;;){if(n>=col)return i;if(i==string.length)break;n+=9==string.charCodeAt(i)?tabSize-n%tabSize:1,i=findClusterBreak(string,i)}return!0===strict?-1:string.length},exports.fromCodePoint=function(code){return code<=65535?String.fromCharCode(code):(code-=65536,String.fromCharCode(55296+(code>>10),56320+(1023&code)))}},{}],12:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var state=require("@codemirror/state"),styleMod=require("style-mod"),w3cKeyname=require("w3c-keyname");function getSelection(root){let target;return target=11==root.nodeType?root.getSelection?root:root.ownerDocument:root,target.getSelection()}function contains(dom,node){return!!node&&(dom==node||dom.contains(1!=node.nodeType?node.parentNode:node))}function hasSelection(dom,selection){if(!selection.anchorNode)return!1;try{return contains(dom,selection.anchorNode)}catch(_){return!1}}function clientRectsFor(dom){return 3==dom.nodeType?textRange(dom,0,dom.nodeValue.length).getClientRects():1==dom.nodeType?dom.getClientRects():[]}function isEquivalentPosition(node,off,targetNode,targetOff){return!!targetNode&&(scanFor(node,off,targetNode,targetOff,-1)||scanFor(node,off,targetNode,targetOff,1))}function domIndex(node){for(var index=0;;index++)if(!(node=node.previousSibling))return index}function scanFor(node,off,targetNode,targetOff,dir){for(;;){if(node==targetNode&&off==targetOff)return!0;if(off==(dir<0?0:maxOffset(node))){if("DIV"==node.nodeName)return!1;let parent=node.parentNode;if(!parent||1!=parent.nodeType)return!1;off=domIndex(node)+(dir<0?0:1),node=parent}else{if(1!=node.nodeType)return!1;if(1==(node=node.childNodes[off+(dir<0?-1:0)]).nodeType&&"false"==node.contentEditable)return!1;off=dir<0?maxOffset(node):0}}}function maxOffset(node){return 3==node.nodeType?node.nodeValue.length:node.childNodes.length}const Rect0={left:0,right:0,top:0,bottom:0};function flattenRect(rect,left){let x=left?rect.left:rect.right;return{left:x,right:x,top:rect.top,bottom:rect.bottom}}function windowRect(win){return{left:0,right:win.innerWidth,top:0,bottom:win.innerHeight}}class DOMSelectionState{constructor(){this.anchorNode=null,this.anchorOffset=0,this.focusNode=null,this.focusOffset=0}eq(domSel){return this.anchorNode==domSel.anchorNode&&this.anchorOffset==domSel.anchorOffset&&this.focusNode==domSel.focusNode&&this.focusOffset==domSel.focusOffset}setRange(range){this.set(range.anchorNode,range.anchorOffset,range.focusNode,range.focusOffset)}set(anchorNode,anchorOffset,focusNode,focusOffset){this.anchorNode=anchorNode,this.anchorOffset=anchorOffset,this.focusNode=focusNode,this.focusOffset=focusOffset}}let scratchRange,preventScrollSupported=null;function focusPreventScroll(dom){if(dom.setActive)return dom.setActive();if(preventScrollSupported)return dom.focus(preventScrollSupported);let stack=[];for(let cur=dom;cur&&(stack.push(cur,cur.scrollTop,cur.scrollLeft),cur!=cur.ownerDocument);cur=cur.parentNode);if(dom.focus(null==preventScrollSupported?{get preventScroll(){return preventScrollSupported={preventScroll:!0},!0}}:void 0),!preventScrollSupported){preventScrollSupported=!1;for(let i=0;i<stack.length;){let elt=stack[i++],top=stack[i++],left=stack[i++];elt.scrollTop!=top&&(elt.scrollTop=top),elt.scrollLeft!=left&&(elt.scrollLeft=left)}}}function textRange(node,from,to=from){let range=scratchRange||(scratchRange=document.createRange());return range.setEnd(node,to),range.setStart(node,from),range}function dispatchKey(elt,name,code){let options={key:name,code:name,keyCode:code,which:code,cancelable:!0},down=new KeyboardEvent("keydown",options);down.synthetic=!0,elt.dispatchEvent(down);let up=new KeyboardEvent("keyup",options);return up.synthetic=!0,elt.dispatchEvent(up),down.defaultPrevented||up.defaultPrevented}function clearAttributes(node){for(;node.attributes.length;)node.removeAttributeNode(node.attributes[0])}class DOMPos{constructor(node,offset,precise=!0){this.node=node,this.offset=offset,this.precise=precise}static before(dom,precise){return new DOMPos(dom.parentNode,domIndex(dom),precise)}static after(dom,precise){return new DOMPos(dom.parentNode,domIndex(dom)+1,precise)}}const noChildren=[];class ContentView{constructor(){this.parent=null,this.dom=null,this.dirty=2}get editorView(){if(!this.parent)throw new Error("Accessing view in orphan content view");return this.parent.editorView}get overrideDOMText(){return null}get posAtStart(){return this.parent?this.parent.posBefore(this):0}get posAtEnd(){return this.posAtStart+this.length}posBefore(view){let pos=this.posAtStart;for(let child of this.children){if(child==view)return pos;pos+=child.length+child.breakAfter}throw new RangeError("Invalid child in posBefore")}posAfter(view){return this.posBefore(view)+view.length}coordsAt(_pos,_side){return null}sync(track){if(2&this.dirty){let next,parent=this.dom,prev=null;for(let child of this.children){if(child.dirty){if(!child.dom&&(next=prev?prev.nextSibling:parent.firstChild)){let contentView=ContentView.get(next);(!contentView||!contentView.parent&&contentView.canReuseDOM(child))&&child.reuseDOM(next)}child.sync(track),child.dirty=0}if(next=prev?prev.nextSibling:parent.firstChild,track&&!track.written&&track.node==parent&&next!=child.dom&&(track.written=!0),child.dom.parentNode==parent)for(;next&&next!=child.dom;)next=rm$1(next);else parent.insertBefore(child.dom,next);prev=child.dom}for(next=prev?prev.nextSibling:parent.firstChild,next&&track&&track.node==parent&&(track.written=!0);next;)next=rm$1(next)}else if(1&this.dirty)for(let child of this.children)child.dirty&&(child.sync(track),child.dirty=0)}reuseDOM(_dom){}localPosFromDOM(node,offset){let after;if(node==this.dom)after=this.dom.childNodes[offset];else{let bias=0==maxOffset(node)?0:0==offset?-1:1;for(;;){let parent=node.parentNode;if(parent==this.dom)break;0==bias&&parent.firstChild!=parent.lastChild&&(bias=node==parent.firstChild?-1:1),node=parent}after=bias<0?node:node.nextSibling}if(after==this.dom.firstChild)return 0;for(;after&&!ContentView.get(after);)after=after.nextSibling;if(!after)return this.length;for(let i=0,pos=0;;i++){let child=this.children[i];if(child.dom==after)return pos;pos+=child.length+child.breakAfter}}domBoundsAround(from,to,offset=0){let fromI=-1,fromStart=-1,toI=-1,toEnd=-1;for(let i=0,pos=offset,prevEnd=offset;i<this.children.length;i++){let child=this.children[i],end=pos+child.length;if(pos<from&&end>to)return child.domBoundsAround(from,to,pos);if(end>=from&&-1==fromI&&(fromI=i,fromStart=pos),pos>to&&child.dom.parentNode==this.dom){toI=i,toEnd=prevEnd;break}prevEnd=end,pos=end+child.breakAfter}return{from:fromStart,to:toEnd<0?offset+this.length:toEnd,startDOM:(fromI?this.children[fromI-1].dom.nextSibling:null)||this.dom.firstChild,endDOM:toI<this.children.length&&toI>=0?this.children[toI].dom:null}}markDirty(andParent=!1){this.dirty|=2,this.markParentsDirty(andParent)}markParentsDirty(childList){for(let parent=this.parent;parent;parent=parent.parent){if(childList&&(parent.dirty|=2),1&parent.dirty)return;parent.dirty|=1,childList=!1}}setParent(parent){this.parent!=parent&&(this.parent=parent,this.dirty&&this.markParentsDirty(!0))}setDOM(dom){this.dom&&(this.dom.cmView=null),this.dom=dom,dom.cmView=this}get rootView(){for(let v=this;;){let parent=v.parent;if(!parent)return v;v=parent}}replaceChildren(from,to,children=noChildren){this.markDirty();for(let i=from;i<to;i++){let child=this.children[i];child.parent==this&&child.destroy()}this.children.splice(from,to-from,...children);for(let i=0;i<children.length;i++)children[i].setParent(this)}ignoreMutation(_rec){return!1}ignoreEvent(_event){return!1}childCursor(pos=this.length){return new ChildCursor(this.children,pos,this.children.length)}childPos(pos,bias=1){return this.childCursor().findPos(pos,bias)}toString(){let name=this.constructor.name.replace("View","");return name+(this.children.length?"("+this.children.join()+")":this.length?"["+("Text"==name?this.text:this.length)+"]":"")+(this.breakAfter?"#":"")}static get(node){return node.cmView}get isEditable(){return!0}merge(from,to,source,hasStart,openStart,openEnd){return!1}become(other){return!1}canReuseDOM(other){return other.constructor==this.constructor}getSide(){return 0}destroy(){this.parent=null}}function rm$1(dom){let next=dom.nextSibling;return dom.parentNode.removeChild(dom),next}ContentView.prototype.breakAfter=0;class ChildCursor{constructor(children,pos,i){this.children=children,this.pos=pos,this.i=i,this.off=0}findPos(pos,bias=1){for(;;){if(pos>this.pos||pos==this.pos&&(bias>0||0==this.i||this.children[this.i-1].breakAfter))return this.off=pos-this.pos,this;let next=this.children[--this.i];this.pos-=next.length+next.breakAfter}}}function replaceRange(parent,fromI,fromOff,toI,toOff,insert,breakAtStart,openStart,openEnd){let{children:children}=parent,before=children.length?children[fromI]:null,last=insert.length?insert[insert.length-1]:null,breakAtEnd=last?last.breakAfter:breakAtStart;if(!(fromI==toI&&before&&!breakAtStart&&!breakAtEnd&&insert.length<2&&before.merge(fromOff,toOff,insert.length?last:null,0==fromOff,openStart,openEnd))){if(toI<children.length){let after=children[toI];after&&toOff<after.length?(fromI==toI&&(after=after.split(toOff),toOff=0),!breakAtEnd&&last&&after.merge(0,toOff,last,!0,0,openEnd)?insert[insert.length-1]=after:(toOff&&after.merge(0,toOff,null,!1,0,openEnd),insert.push(after))):(null==after?void 0:after.breakAfter)&&(last?last.breakAfter=1:breakAtStart=1),toI++}for(before&&(before.breakAfter=breakAtStart,fromOff>0&&(!breakAtStart&&insert.length&&before.merge(fromOff,before.length,insert[0],!1,openStart,0)?before.breakAfter=insert.shift().breakAfter:(fromOff<before.length||before.children.length&&0==before.children[before.children.length-1].length)&&before.merge(fromOff,before.length,null,!1,openStart,0),fromI++));fromI<toI&&insert.length;)if(children[toI-1].become(insert[insert.length-1]))toI--,insert.pop(),openEnd=insert.length?0:openStart;else{if(!children[fromI].become(insert[0]))break;fromI++,insert.shift(),openStart=insert.length?0:openEnd}!insert.length&&fromI&&toI<children.length&&!children[fromI-1].breakAfter&&children[toI].merge(0,0,children[fromI-1],!1,openStart,openEnd)&&fromI--,(fromI<toI||insert.length)&&parent.replaceChildren(fromI,toI,insert)}}function mergeChildrenInto(parent,from,to,insert,openStart,openEnd){let cur=parent.childCursor(),{i:toI,off:toOff}=cur.findPos(to,1),{i:fromI,off:fromOff}=cur.findPos(from,-1),dLen=from-to;for(let view of insert)dLen+=view.length;parent.length+=dLen,replaceRange(parent,fromI,fromOff,toI,toOff,insert,0,openStart,openEnd)}let nav="undefined"!=typeof navigator?navigator:{userAgent:"",vendor:"",platform:""},doc="undefined"!=typeof document?document:{documentElement:{style:{}}};const ie_edge=/Edge\/(\d+)/.exec(nav.userAgent),ie_upto10=/MSIE \d/.test(nav.userAgent),ie_11up=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent),ie=!!(ie_upto10||ie_11up||ie_edge),gecko=!ie&&/gecko\/(\d+)/i.test(nav.userAgent),chrome=!ie&&/Chrome\/(\d+)/.exec(nav.userAgent),webkit="webkitFontSmoothing"in doc.documentElement.style,safari=!ie&&/Apple Computer/.test(nav.vendor),ios=safari&&(/Mobile\/\w+/.test(nav.userAgent)||nav.maxTouchPoints>2);var browser={mac:ios||/Mac/.test(nav.platform),windows:/Win/.test(nav.platform),linux:/Linux|X11/.test(nav.platform),ie:ie,ie_version:ie_upto10?doc.documentMode||6:ie_11up?+ie_11up[1]:ie_edge?+ie_edge[1]:0,gecko:gecko,gecko_version:gecko?+(/Firefox\/(\d+)/.exec(nav.userAgent)||[0,0])[1]:0,chrome:!!chrome,chrome_version:chrome?+chrome[1]:0,ios:ios,android:/Android\b/.test(nav.userAgent),webkit:webkit,safari:safari,webkit_version:webkit?+(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent)||[0,0])[1]:0,tabSize:null!=doc.documentElement.style.tabSize?"tab-size":"-moz-tab-size"};class TextView extends ContentView{constructor(text){super(),this.text=text}get length(){return this.text.length}createDOM(textDOM){this.setDOM(textDOM||document.createTextNode(this.text))}sync(track){this.dom||this.createDOM(),this.dom.nodeValue!=this.text&&(track&&track.node==this.dom&&(track.written=!0),this.dom.nodeValue=this.text)}reuseDOM(dom){3==dom.nodeType&&this.createDOM(dom)}merge(from,to,source){return(!source||source instanceof TextView&&!(this.length-(to-from)+source.length>256))&&(this.text=this.text.slice(0,from)+(source?source.text:"")+this.text.slice(to),this.markDirty(),!0)}split(from){let result=new TextView(this.text.slice(from));return this.text=this.text.slice(0,from),this.markDirty(),result}localPosFromDOM(node,offset){return node==this.dom?offset:offset?this.text.length:0}domAtPos(pos){return new DOMPos(this.dom,pos)}domBoundsAround(_from,_to,offset){return{from:offset,to:offset+this.length,startDOM:this.dom,endDOM:this.dom.nextSibling}}coordsAt(pos,side){return textCoords(this.dom,pos,side)}}class MarkView extends ContentView{constructor(mark,children=[],length=0){super(),this.mark=mark,this.children=children,this.length=length;for(let ch of children)ch.setParent(this)}setAttrs(dom){if(clearAttributes(dom),this.mark.class&&(dom.className=this.mark.class),this.mark.attrs)for(let name in this.mark.attrs)dom.setAttribute(name,this.mark.attrs[name]);return dom}reuseDOM(node){node.nodeName==this.mark.tagName.toUpperCase()&&(this.setDOM(node),this.dirty|=6)}sync(track){this.dom?4&this.dirty&&this.setAttrs(this.dom):this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))),super.sync(track)}merge(from,to,source,_hasStart,openStart,openEnd){return(!source||!(!(source instanceof MarkView&&source.mark.eq(this.mark))||from&&openStart<=0||to<this.length&&openEnd<=0))&&(mergeChildrenInto(this,from,to,source?source.children:[],openStart-1,openEnd-1),this.markDirty(),!0)}split(from){let result=[],off=0,detachFrom=-1,i=0;for(let elt of this.children){let end=off+elt.length;end>from&&result.push(off<from?elt.split(from-off):elt),detachFrom<0&&off>=from&&(detachFrom=i),off=end,i++}let length=this.length-from;return this.length=from,detachFrom>-1&&(this.children.length=detachFrom,this.markDirty()),new MarkView(this.mark,result,length)}domAtPos(pos){return inlineDOMAtPos(this,pos)}coordsAt(pos,side){return coordsInChildren(this,pos,side)}}function textCoords(text,pos,side){let length=text.nodeValue.length;pos>length&&(pos=length);let from=pos,to=pos,flatten=0;0==pos&&side<0||pos==length&&side>=0?browser.chrome||browser.gecko||(pos?(from--,flatten=1):to<length&&(to++,flatten=-1)):side<0?from--:to<length&&to++;let rects=textRange(text,from,to).getClientRects();if(!rects.length)return Rect0;let rect=rects[(flatten?flatten<0:side>=0)?0:rects.length-1];return browser.safari&&!flatten&&0==rect.width&&(rect=Array.prototype.find.call(rects,(r=>r.width))||rect),flatten?flattenRect(rect,flatten<0):rect||null}class WidgetView extends ContentView{constructor(widget,length,side){super(),this.widget=widget,this.length=length,this.side=side,this.prevWidget=null}static create(widget,length,side){return new(widget.customView||WidgetView)(widget,length,side)}split(from){let result=WidgetView.create(this.widget,this.length-from,this.side);return this.length-=from,result}sync(){this.dom&&this.widget.updateDOM(this.dom)||(this.dom&&this.prevWidget&&this.prevWidget.destroy(this.dom),this.prevWidget=null,this.setDOM(this.widget.toDOM(this.editorView)),this.dom.contentEditable="false")}getSide(){return this.side}merge(from,to,source,hasStart,openStart,openEnd){return!(source&&(!(source instanceof WidgetView&&this.widget.compare(source.widget))||from>0&&openStart<=0||to<this.length&&openEnd<=0))&&(this.length=from+(source?source.length:0)+(this.length-to),!0)}become(other){return other.length==this.length&&other instanceof WidgetView&&other.side==this.side&&this.widget.constructor==other.widget.constructor&&(this.widget.eq(other.widget)||this.markDirty(!0),this.dom&&!this.prevWidget&&(this.prevWidget=this.widget),this.widget=other.widget,!0)}ignoreMutation(){return!0}ignoreEvent(event){return this.widget.ignoreEvent(event)}get overrideDOMText(){if(0==this.length)return state.Text.empty;let top=this;for(;top.parent;)top=top.parent;let view=top.editorView,text=view&&view.state.doc,start=this.posAtStart;return text?text.slice(start,start+this.length):state.Text.empty}domAtPos(pos){return 0==pos?DOMPos.before(this.dom):DOMPos.after(this.dom,pos==this.length)}domBoundsAround(){return null}coordsAt(pos,side){let rects=this.dom.getClientRects(),rect=null;if(!rects.length)return Rect0;for(let i=pos>0?rects.length-1:0;rect=rects[i],!(pos>0?0==i:i==rects.length-1||rect.top<rect.bottom);i+=pos>0?-1:1);return this.length?rect:flattenRect(rect,this.side>0)}get isEditable(){return!1}destroy(){super.destroy(),this.dom&&this.widget.destroy(this.dom)}}class CompositionView extends WidgetView{domAtPos(pos){let{topView:topView,text:text}=this.widget;return topView?scanCompositionTree(pos,0,topView,text,((v,p)=>v.domAtPos(p)),(p=>new DOMPos(text,Math.min(p,text.nodeValue.length)))):new DOMPos(text,Math.min(pos,text.nodeValue.length))}sync(){this.setDOM(this.widget.toDOM())}localPosFromDOM(node,offset){let{topView:topView,text:text}=this.widget;return topView?posFromDOMInCompositionTree(node,offset,topView,text):Math.min(offset,this.length)}ignoreMutation(){return!1}get overrideDOMText(){return null}coordsAt(pos,side){let{topView:topView,text:text}=this.widget;return topView?scanCompositionTree(pos,side,topView,text,((v,pos,side)=>v.coordsAt(pos,side)),((pos,side)=>textCoords(text,pos,side))):textCoords(text,pos,side)}destroy(){var _a;super.destroy(),null===(_a=this.widget.topView)||void 0===_a||_a.destroy()}get isEditable(){return!0}canReuseDOM(){return!0}}function scanCompositionTree(pos,side,view,text,enterView,fromText){if(view instanceof MarkView){for(let child=view.dom.firstChild;child;child=child.nextSibling){let desc=ContentView.get(child);if(!desc)return fromText(pos,side);let hasComp=contains(child,text),len=desc.length+(hasComp?text.nodeValue.length:0);if(pos<len||pos==len&&desc.getSide()<=0)return hasComp?scanCompositionTree(pos,side,desc,text,enterView,fromText):enterView(desc,pos,side);pos-=len}return enterView(view,view.length,-1)}return view.dom==text?fromText(pos,side):enterView(view,pos,side)}function posFromDOMInCompositionTree(node,offset,view,text){if(view instanceof MarkView)for(let child of view.children){let pos=0,hasComp=contains(child.dom,text);if(contains(child.dom,node))return pos+(hasComp?posFromDOMInCompositionTree(node,offset,child,text):child.localPosFromDOM(node,offset));pos+=hasComp?text.nodeValue.length:child.length}else if(view.dom==text)return Math.min(offset,text.nodeValue.length);return view.localPosFromDOM(node,offset)}class WidgetBufferView extends ContentView{constructor(side){super(),this.side=side}get length(){return 0}merge(){return!1}become(other){return other instanceof WidgetBufferView&&other.side==this.side}split(){return new WidgetBufferView(this.side)}sync(){if(!this.dom){let dom=document.createElement("img");dom.className="cm-widgetBuffer",dom.setAttribute("aria-hidden","true"),this.setDOM(dom)}}getSide(){return this.side}domAtPos(pos){return DOMPos.before(this.dom)}localPosFromDOM(){return 0}domBoundsAround(){return null}coordsAt(pos){let imgRect=this.dom.getBoundingClientRect(),siblingRect=function(view,side){let parent=view.parent,index=parent?parent.children.indexOf(view):-1;for(;parent&&index>=0;)if(side<0?index>0:index<parent.children.length){let next=parent.children[index+side];if(next instanceof TextView){let nextRect=next.coordsAt(side<0?next.length:0,side);if(nextRect)return nextRect}index+=side}else{if(!(parent instanceof MarkView&&parent.parent)){let last=parent.dom.lastChild;if(last&&"BR"==last.nodeName)return last.getClientRects()[0];break}index=parent.parent.children.indexOf(parent)+(side<0?0:1),parent=parent.parent}return}(this,this.side>0?-1:1);return siblingRect&&siblingRect.top<imgRect.bottom&&siblingRect.bottom>imgRect.top?{left:imgRect.left,right:imgRect.right,top:siblingRect.top,bottom:siblingRect.bottom}:imgRect}get overrideDOMText(){return state.Text.empty}}function inlineDOMAtPos(parent,pos){let dom=parent.dom,{children:children}=parent,i=0;for(let off=0;i<children.length;i++){let child=children[i],end=off+child.length;if(!(end==off&&child.getSide()<=0)){if(pos>off&&pos<end&&child.dom.parentNode==dom)return child.domAtPos(pos-off);if(pos<=off)break;off=end}}for(let j=i;j>0;j--){let prev=children[j-1];if(prev.dom.parentNode==dom)return prev.domAtPos(prev.length)}for(let j=i;j<children.length;j++){let next=children[j];if(next.dom.parentNode==dom)return next.domAtPos(0)}return new DOMPos(dom,0)}function joinInlineInto(parent,view,open){let last,{children:children}=parent;open>0&&view instanceof MarkView&&children.length&&(last=children[children.length-1])instanceof MarkView&&last.mark.eq(view.mark)?joinInlineInto(last,view.children[0],open-1):(children.push(view),view.setParent(parent)),parent.length+=view.length}function coordsInChildren(view,pos,side){let before=null,beforePos=-1,after=null,afterPos=-1;!function scan(view,pos){for(let i=0,off=0;i<view.children.length&&off<=pos;i++){let child=view.children[i],end=off+child.length;end>=pos&&(child.children.length?scan(child,pos-off):!after&&(end>pos||off==end&&child.getSide()>0)?(after=child,afterPos=pos-off):(off<pos||off==end&&child.getSide()<0)&&(before=child,beforePos=pos-off)),off=end}}(view,pos);let target=(side<0?before:after)||before||after;return target?target.coordsAt(Math.max(0,target==before?beforePos:afterPos),side):function(view){let last=view.dom.lastChild;if(!last)return view.dom.getBoundingClientRect();let rects=clientRectsFor(last);return rects[rects.length-1]||null}(view)}function combineAttrs(source,target){for(let name in source)"class"==name&&target.class?target.class+=" "+source.class:"style"==name&&target.style?target.style+=";"+source.style:target[name]=source[name];return target}function attrsEq(a,b){if(a==b)return!0;if(!a||!b)return!1;let keysA=Object.keys(a),keysB=Object.keys(b);if(keysA.length!=keysB.length)return!1;for(let key of keysA)if(-1==keysB.indexOf(key)||a[key]!==b[key])return!1;return!0}function updateAttrs(dom,prev,attrs){let changed=null;if(prev)for(let name in prev)attrs&&name in attrs||dom.removeAttribute(changed=name);if(attrs)for(let name in attrs)prev&&prev[name]==attrs[name]||dom.setAttribute(changed=name,attrs[name]);return!!changed}TextView.prototype.children=WidgetView.prototype.children=WidgetBufferView.prototype.children=noChildren;class WidgetType{eq(widget){return!1}updateDOM(dom){return!1}compare(other){return this==other||this.constructor==other.constructor&&this.eq(other)}get estimatedHeight(){return-1}ignoreEvent(event){return!0}get customView(){return null}destroy(dom){}}var BlockType;exports.BlockType=void 0,(BlockType=exports.BlockType||(exports.BlockType={}))[BlockType.Text=0]="Text",BlockType[BlockType.WidgetBefore=1]="WidgetBefore",BlockType[BlockType.WidgetAfter=2]="WidgetAfter",BlockType[BlockType.WidgetRange=3]="WidgetRange";class Decoration extends state.RangeValue{constructor(startSide,endSide,widget,spec){super(),this.startSide=startSide,this.endSide=endSide,this.widget=widget,this.spec=spec}get heightRelevant(){return!1}static mark(spec){return new MarkDecoration(spec)}static widget(spec){let side=spec.side||0,block=!!spec.block;return side+=block?side>0?3e8:-4e8:side>0?1e8:-1e8,new PointDecoration(spec,side,side,block,spec.widget||null,!1)}static replace(spec){let startSide,endSide,block=!!spec.block;if(spec.isBlockGap)startSide=-5e8,endSide=4e8;else{let{start:start,end:end}=getInclusive(spec,block);startSide=(start?block?-3e8:-1:5e8)-1,endSide=1+(end?block?2e8:1:-6e8)}return new PointDecoration(spec,startSide,endSide,block,spec.widget||null,!0)}static line(spec){return new LineDecoration(spec)}static set(of,sort=!1){return state.RangeSet.of(of,sort)}hasHeight(){return!!this.widget&&this.widget.estimatedHeight>-1}}Decoration.none=state.RangeSet.empty;class MarkDecoration extends Decoration{constructor(spec){let{start:start,end:end}=getInclusive(spec);super(start?-1:5e8,end?1:-6e8,null,spec),this.tagName=spec.tagName||"span",this.class=spec.class||"",this.attrs=spec.attributes||null}eq(other){return this==other||other instanceof MarkDecoration&&this.tagName==other.tagName&&this.class==other.class&&attrsEq(this.attrs,other.attrs)}range(from,to=from){if(from>=to)throw new RangeError("Mark decorations may not be empty");return super.range(from,to)}}MarkDecoration.prototype.point=!1;class LineDecoration extends Decoration{constructor(spec){super(-2e8,-2e8,null,spec)}eq(other){return other instanceof LineDecoration&&this.spec.class==other.spec.class&&attrsEq(this.spec.attributes,other.spec.attributes)}range(from,to=from){if(to!=from)throw new RangeError("Line decoration ranges must be zero-length");return super.range(from,to)}}LineDecoration.prototype.mapMode=state.MapMode.TrackBefore,LineDecoration.prototype.point=!0;class PointDecoration extends Decoration{constructor(spec,startSide,endSide,block,widget,isReplace){super(startSide,endSide,widget,spec),this.block=block,this.isReplace=isReplace,this.mapMode=block?startSide<=0?state.MapMode.TrackBefore:state.MapMode.TrackAfter:state.MapMode.TrackDel}get type(){return this.startSide<this.endSide?exports.BlockType.WidgetRange:this.startSide<=0?exports.BlockType.WidgetBefore:exports.BlockType.WidgetAfter}get heightRelevant(){return this.block||!!this.widget&&this.widget.estimatedHeight>=5}eq(other){return other instanceof PointDecoration&&(a=this.widget,b=other.widget,a==b||!!(a&&b&&a.compare(b)))&&this.block==other.block&&this.startSide==other.startSide&&this.endSide==other.endSide;var a,b}range(from,to=from){if(this.isReplace&&(from>to||from==to&&this.startSide>0&&this.endSide<=0))throw new RangeError("Invalid range for replacement decoration");if(!this.isReplace&&to!=from)throw new RangeError("Widget decorations can only have zero-length ranges");return super.range(from,to)}}function getInclusive(spec,block=!1){let{inclusiveStart:start,inclusiveEnd:end}=spec;return null==start&&(start=spec.inclusive),null==end&&(end=spec.inclusive),{start:null!=start?start:block,end:null!=end?end:block}}function addRange(from,to,ranges,margin=0){let last=ranges.length-1;last>=0&&ranges[last]+margin>=from?ranges[last]=Math.max(ranges[last],to):ranges.push(from,to)}PointDecoration.prototype.point=!0;class LineView extends ContentView{constructor(){super(...arguments),this.children=[],this.length=0,this.prevAttrs=void 0,this.attrs=null,this.breakAfter=0}merge(from,to,source,hasStart,openStart,openEnd){if(source){if(!(source instanceof LineView))return!1;this.dom||source.transferDOM(this)}return hasStart&&this.setDeco(source?source.attrs:null),mergeChildrenInto(this,from,to,source?source.children:[],openStart,openEnd),!0}split(at){let end=new LineView;if(end.breakAfter=this.breakAfter,0==this.length)return end;let{i:i,off:off}=this.childPos(at);off&&(end.append(this.children[i].split(off),0),this.children[i].merge(off,this.children[i].length,null,!1,0,0),i++);for(let j=i;j<this.children.length;j++)end.append(this.children[j],0);for(;i>0&&0==this.children[i-1].length;)this.children[--i].destroy();return this.children.length=i,this.markDirty(),this.length=at,end}transferDOM(other){this.dom&&(this.markDirty(),other.setDOM(this.dom),other.prevAttrs=void 0===this.prevAttrs?this.attrs:this.prevAttrs,this.prevAttrs=void 0,this.dom=null)}setDeco(attrs){attrsEq(this.attrs,attrs)||(this.dom&&(this.prevAttrs=this.attrs,this.markDirty()),this.attrs=attrs)}append(child,openStart){joinInlineInto(this,child,openStart)}addLineDeco(deco){let attrs=deco.spec.attributes,cls=deco.spec.class;attrs&&(this.attrs=combineAttrs(attrs,this.attrs||{})),cls&&(this.attrs=combineAttrs({class:cls},this.attrs||{}))}domAtPos(pos){return inlineDOMAtPos(this,pos)}reuseDOM(node){"DIV"==node.nodeName&&(this.setDOM(node),this.dirty|=6)}sync(track){var _a;this.dom?4&this.dirty&&(clearAttributes(this.dom),this.dom.className="cm-line",this.prevAttrs=this.attrs?null:void 0):(this.setDOM(document.createElement("div")),this.dom.className="cm-line",this.prevAttrs=this.attrs?null:void 0),void 0!==this.prevAttrs&&(updateAttrs(this.dom,this.prevAttrs,this.attrs),this.dom.classList.add("cm-line"),this.prevAttrs=void 0),super.sync(track);let last=this.dom.lastChild;for(;last&&ContentView.get(last)instanceof MarkView;)last=last.lastChild;if(!(last&&this.length&&("BR"==last.nodeName||0!=(null===(_a=ContentView.get(last))||void 0===_a?void 0:_a.isEditable)||browser.ios&&this.children.some((ch=>ch instanceof TextView))))){let hack=document.createElement("BR");hack.cmIgnore=!0,this.dom.appendChild(hack)}}measureTextSize(){if(0==this.children.length||this.length>20)return null;let totalWidth=0;for(let child of this.children){if(!(child instanceof TextView)||/[^ -~]/.test(child.text))return null;let rects=clientRectsFor(child.dom);if(1!=rects.length)return null;totalWidth+=rects[0].width}return totalWidth?{lineHeight:this.dom.getBoundingClientRect().height,charWidth:totalWidth/this.length}:null}coordsAt(pos,side){return coordsInChildren(this,pos,side)}become(_other){return!1}get type(){return exports.BlockType.Text}static find(docView,pos){for(let i=0,off=0;i<docView.children.length;i++){let block=docView.children[i],end=off+block.length;if(end>=pos){if(block instanceof LineView)return block;if(end>pos)break}off=end+block.breakAfter}return null}}class BlockWidgetView extends ContentView{constructor(widget,length,type){super(),this.widget=widget,this.length=length,this.type=type,this.breakAfter=0,this.prevWidget=null}merge(from,to,source,_takeDeco,openStart,openEnd){return!(source&&(!(source instanceof BlockWidgetView&&this.widget.compare(source.widget))||from>0&&openStart<=0||to<this.length&&openEnd<=0))&&(this.length=from+(source?source.length:0)+(this.length-to),!0)}domAtPos(pos){return 0==pos?DOMPos.before(this.dom):DOMPos.after(this.dom,pos==this.length)}split(at){let len=this.length-at;this.length=at;let end=new BlockWidgetView(this.widget,len,this.type);return end.breakAfter=this.breakAfter,end}get children(){return noChildren}sync(){this.dom&&this.widget.updateDOM(this.dom)||(this.dom&&this.prevWidget&&this.prevWidget.destroy(this.dom),this.prevWidget=null,this.setDOM(this.widget.toDOM(this.editorView)),this.dom.contentEditable="false")}get overrideDOMText(){return this.parent?this.parent.view.state.doc.slice(this.posAtStart,this.posAtEnd):state.Text.empty}domBoundsAround(){return null}become(other){return other instanceof BlockWidgetView&&other.type==this.type&&other.widget.constructor==this.widget.constructor&&(other.widget.eq(this.widget)||this.markDirty(!0),this.dom&&!this.prevWidget&&(this.prevWidget=this.widget),this.widget=other.widget,this.length=other.length,this.breakAfter=other.breakAfter,!0)}ignoreMutation(){return!0}ignoreEvent(event){return this.widget.ignoreEvent(event)}destroy(){super.destroy(),this.dom&&this.widget.destroy(this.dom)}}class ContentBuilder{constructor(doc,pos,end,disallowBlockEffectsFor){this.doc=doc,this.pos=pos,this.end=end,this.disallowBlockEffectsFor=disallowBlockEffectsFor,this.content=[],this.curLine=null,this.breakAtStart=0,this.pendingBuffer=0,this.bufferMarks=[],this.atCursorPos=!0,this.openStart=-1,this.openEnd=-1,this.text="",this.textOff=0,this.cursor=doc.iter(),this.skip=pos}posCovered(){if(0==this.content.length)return!this.breakAtStart&&this.doc.lineAt(this.pos).from!=this.pos;let last=this.content[this.content.length-1];return!(last.breakAfter||last instanceof BlockWidgetView&&last.type==exports.BlockType.WidgetBefore)}getLine(){return this.curLine||(this.content.push(this.curLine=new LineView),this.atCursorPos=!0),this.curLine}flushBuffer(active=this.bufferMarks){this.pendingBuffer&&(this.curLine.append(wrapMarks(new WidgetBufferView(-1),active),active.length),this.pendingBuffer=0)}addBlockWidget(view){this.flushBuffer(),this.curLine=null,this.content.push(view)}finish(openEnd){this.pendingBuffer&&openEnd<=this.bufferMarks.length?this.flushBuffer():this.pendingBuffer=0,this.posCovered()||this.getLine()}buildText(length,active,openStart){for(;length>0;){if(this.textOff==this.text.length){let{value:value,lineBreak:lineBreak,done:done}=this.cursor.next(this.skip);if(this.skip=0,done)throw new Error("Ran out of text content when drawing inline views");if(lineBreak){this.posCovered()||this.getLine(),this.content.length?this.content[this.content.length-1].breakAfter=1:this.breakAtStart=1,this.flushBuffer(),this.curLine=null,this.atCursorPos=!0,length--;continue}this.text=value,this.textOff=0}let take=Math.min(this.text.length-this.textOff,length,512);this.flushBuffer(active.slice(active.length-openStart)),this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff,this.textOff+take)),active),openStart),this.atCursorPos=!0,this.textOff+=take,length-=take,openStart=0}}span(from,to,active,openStart){this.buildText(to-from,active,openStart),this.pos=to,this.openStart<0&&(this.openStart=openStart)}point(from,to,deco,active,openStart,index){if(this.disallowBlockEffectsFor[index]&&deco instanceof PointDecoration){if(deco.block)throw new RangeError("Block decorations may not be specified via plugins");if(to>this.doc.lineAt(this.pos).to)throw new RangeError("Decorations that replace line breaks may not be specified via plugins")}let len=to-from;if(deco instanceof PointDecoration)if(deco.block){let{type:type}=deco;type!=exports.BlockType.WidgetAfter||this.posCovered()||this.getLine(),this.addBlockWidget(new BlockWidgetView(deco.widget||new NullWidget("div"),len,type))}else{let view=WidgetView.create(deco.widget||new NullWidget("span"),len,len?0:deco.startSide),cursorBefore=this.atCursorPos&&!view.isEditable&&openStart<=active.length&&(from<to||deco.startSide>0),cursorAfter=!view.isEditable&&(from<to||openStart>active.length||deco.startSide<=0),line=this.getLine();2!=this.pendingBuffer||cursorBefore||(this.pendingBuffer=0),this.flushBuffer(active),cursorBefore&&(line.append(wrapMarks(new WidgetBufferView(1),active),openStart),openStart=active.length+Math.max(0,openStart-active.length)),line.append(wrapMarks(view,active),openStart),this.atCursorPos=cursorAfter,this.pendingBuffer=cursorAfter?from<to||openStart>active.length?1:2:0,this.pendingBuffer&&(this.bufferMarks=active.slice())}else this.doc.lineAt(this.pos).from==this.pos&&this.getLine().addLineDeco(deco);len&&(this.textOff+len<=this.text.length?this.textOff+=len:(this.skip+=len-(this.text.length-this.textOff),this.text="",this.textOff=0),this.pos=to),this.openStart<0&&(this.openStart=openStart)}static build(text,from,to,decorations,dynamicDecorationMap){let builder=new ContentBuilder(text,from,to,dynamicDecorationMap);return builder.openEnd=state.RangeSet.spans(decorations,from,to,builder),builder.openStart<0&&(builder.openStart=builder.openEnd),builder.finish(builder.openEnd),builder}}function wrapMarks(view,active){for(let mark of active)view=new MarkView(mark,[view],view.length);return view}class NullWidget extends WidgetType{constructor(tag){super(),this.tag=tag}eq(other){return other.tag==this.tag}toDOM(){return document.createElement(this.tag)}updateDOM(elt){return elt.nodeName.toLowerCase()==this.tag}}const clickAddsSelectionRange=state.Facet.define(),dragMovesSelection$1=state.Facet.define(),mouseSelectionStyle=state.Facet.define(),exceptionSink=state.Facet.define(),updateListener=state.Facet.define(),inputHandler=state.Facet.define(),perLineTextDirection=state.Facet.define({combine:values=>values.some((x=>x))}),nativeSelectionHidden=state.Facet.define({combine:values=>values.some((x=>x))});class ScrollTarget{constructor(range,y="nearest",x="nearest",yMargin=5,xMargin=5){this.range=range,this.y=y,this.x=x,this.yMargin=yMargin,this.xMargin=xMargin}map(changes){return changes.empty?this:new ScrollTarget(this.range.map(changes),this.y,this.x,this.yMargin,this.xMargin)}}const scrollIntoView=state.StateEffect.define({map:(t,ch)=>t.map(ch)});function logException(state,exception,context){let handler=state.facet(exceptionSink);handler.length?handler[0](exception):window.onerror?window.onerror(String(exception),context,void 0,void 0,exception):context?console.error(context+":",exception):console.error(exception)}const editable=state.Facet.define({combine:values=>!values.length||values[0]});let nextPluginID=0;const viewPlugin=state.Facet.define();class ViewPlugin{constructor(id,create,domEventHandlers,buildExtensions){this.id=id,this.create=create,this.domEventHandlers=domEventHandlers,this.extension=buildExtensions(this)}static define(create,spec){const{eventHandlers:eventHandlers,provide:provide,decorations:deco}=spec||{};return new ViewPlugin(nextPluginID++,create,eventHandlers,(plugin=>{let ext=[viewPlugin.of(plugin)];return deco&&ext.push(decorations.of((view=>{let pluginInst=view.plugin(plugin);return pluginInst?deco(pluginInst):Decoration.none}))),provide&&ext.push(provide(plugin)),ext}))}static fromClass(cls,spec){return ViewPlugin.define((view=>new cls(view)),spec)}}class PluginInstance{constructor(spec){this.spec=spec,this.mustUpdate=null,this.value=null}update(view){if(this.value){if(this.mustUpdate){let update=this.mustUpdate;if(this.mustUpdate=null,this.value.update)try{this.value.update(update)}catch(e){if(logException(update.state,e,"CodeMirror plugin crashed"),this.value.destroy)try{this.value.destroy()}catch(_){}this.deactivate()}}}else if(this.spec)try{this.value=this.spec.create(view)}catch(e){logException(view.state,e,"CodeMirror plugin crashed"),this.deactivate()}return this}destroy(view){var _a;if(null===(_a=this.value)||void 0===_a?void 0:_a.destroy)try{this.value.destroy()}catch(e){logException(view.state,e,"CodeMirror plugin crashed")}}deactivate(){this.spec=this.value=null}}const editorAttributes=state.Facet.define(),contentAttributes=state.Facet.define(),decorations=state.Facet.define(),atomicRanges=state.Facet.define(),scrollMargins=state.Facet.define(),styleModule=state.Facet.define();class ChangedRange{constructor(fromA,toA,fromB,toB){this.fromA=fromA,this.toA=toA,this.fromB=fromB,this.toB=toB}join(other){return new ChangedRange(Math.min(this.fromA,other.fromA),Math.max(this.toA,other.toA),Math.min(this.fromB,other.fromB),Math.max(this.toB,other.toB))}addToSet(set){let i=set.length,me=this;for(;i>0;i--){let range=set[i-1];if(!(range.fromA>me.toA)){if(range.toA<me.fromA)break;me=me.join(range),set.splice(i-1,1)}}return set.splice(i,0,me),set}static extendWithRanges(diff,ranges){if(0==ranges.length)return diff;let result=[];for(let dI=0,rI=0,posA=0,posB=0;;dI++){let next=dI==diff.length?null:diff[dI],off=posA-posB,end=next?next.fromB:1e9;for(;rI<ranges.length&&ranges[rI]<end;){let from=ranges[rI],to=ranges[rI+1],fromB=Math.max(posB,from),toB=Math.min(end,to);if(fromB<=toB&&new ChangedRange(fromB+off,toB+off,fromB,toB).addToSet(result),to>end)break;rI+=2}if(!next)return result;new ChangedRange(next.fromA,next.toA,next.fromB,next.toB).addToSet(result),posA=next.toA,posB=next.toB}}}class ViewUpdate{constructor(view,state$1,transactions){this.view=view,this.state=state$1,this.transactions=transactions,this.flags=0,this.startState=view.state,this.changes=state.ChangeSet.empty(this.startState.doc.length);for(let tr of transactions)this.changes=this.changes.compose(tr.changes);let changedRanges=[];this.changes.iterChangedRanges(((fromA,toA,fromB,toB)=>changedRanges.push(new ChangedRange(fromA,toA,fromB,toB)))),this.changedRanges=changedRanges;let focus=view.hasFocus;focus!=view.inputState.notifiedFocused&&(view.inputState.notifiedFocused=focus,this.flags|=1)}static create(view,state,transactions){return new ViewUpdate(view,state,transactions)}get viewportChanged(){return(4&this.flags)>0}get heightChanged(){return(2&this.flags)>0}get geometryChanged(){return this.docChanged||(10&this.flags)>0}get focusChanged(){return(1&this.flags)>0}get docChanged(){return!this.changes.empty}get selectionSet(){return this.transactions.some((tr=>tr.selection))}get empty(){return 0==this.flags&&0==this.transactions.length}}var Direction;exports.Direction=void 0,(Direction=exports.Direction||(exports.Direction={}))[Direction.LTR=0]="LTR",Direction[Direction.RTL=1]="RTL";const LTR=exports.Direction.LTR,RTL=exports.Direction.RTL;function dec(str){let result=[];for(let i=0;i<str.length;i++)result.push(1<<+str[i]);return result}const LowTypes=dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"),ArabicTypes=dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"),Brackets=Object.create(null),BracketStack=[];for(let p of["()","[]","{}"]){let l=p.charCodeAt(0),r=p.charCodeAt(1);Brackets[l]=r,Brackets[r]=-l}const BidiRE=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;class BidiSpan{constructor(from,to,level){this.from=from,this.to=to,this.level=level}get dir(){return this.level%2?RTL:LTR}side(end,dir){return this.dir==dir==end?this.to:this.from}static find(order,index,level,assoc){let maybe=-1;for(let i=0;i<order.length;i++){let span=order[i];if(span.from<=index&&span.to>=index){if(span.level==level)return i;(maybe<0||(0!=assoc?assoc<0?span.from<index:span.to>index:order[maybe].level>span.level))&&(maybe=i)}}if(maybe<0)throw new RangeError("Index out of range");return maybe}}const types=[];function computeOrder(line,direction){let len=line.length,outerType=direction==LTR?1:2,oppositeType=direction==LTR?2:1;if(!line||1==outerType&&!BidiRE.test(line))return trivialOrder(len);for(let i=0,prev=outerType,prevStrong=outerType;i<len;i++){let type=(ch=line.charCodeAt(i))<=247?LowTypes[ch]:1424<=ch&&ch<=1524?2:1536<=ch&&ch<=1785?ArabicTypes[ch-1536]:1774<=ch&&ch<=2220?4:8192<=ch&&ch<=8203?256:64336<=ch&&ch<=65023?4:8204==ch?256:1;512==type?type=prev:8==type&&4==prevStrong&&(type=16),types[i]=4==type?2:type,7&type&&(prevStrong=type),prev=type}var ch;for(let i=0,prev=outerType,prevStrong=outerType;i<len;i++){let type=types[i];if(128==type)i<len-1&&prev==types[i+1]&&24&prev?type=types[i]=prev:types[i]=256;else if(64==type){let end=i+1;for(;end<len&&64==types[end];)end++;let replace=i&&8==prev||end<len&&8==types[end]?1==prevStrong?1:8:256;for(let j=i;j<end;j++)types[j]=replace;i=end-1}else 8==type&&1==prevStrong&&(types[i]=1);prev=type,7&type&&(prevStrong=type)}for(let ch,br,type,i=0,sI=0,context=0;i<len;i++)if(br=Brackets[ch=line.charCodeAt(i)])if(br<0){for(let sJ=sI-3;sJ>=0;sJ-=3)if(BracketStack[sJ+1]==-br){let flags=BracketStack[sJ+2],type=2&flags?outerType:4&flags?1&flags?oppositeType:outerType:0;type&&(types[i]=types[BracketStack[sJ]]=type),sI=sJ;break}}else{if(189==BracketStack.length)break;BracketStack[sI++]=i,BracketStack[sI++]=ch,BracketStack[sI++]=context}else if(2==(type=types[i])||1==type){let embed=type==outerType;context=embed?0:1;for(let sJ=sI-3;sJ>=0;sJ-=3){let cur=BracketStack[sJ+2];if(2&cur)break;if(embed)BracketStack[sJ+2]|=2;else{if(4&cur)break;BracketStack[sJ+2]|=4}}}for(let i=0;i<len;i++)if(256==types[i]){let end=i+1;for(;end<len&&256==types[end];)end++;let beforeL=1==(i?types[i-1]:outerType),replace=beforeL==(1==(end<len?types[end]:outerType))?beforeL?1:2:outerType;for(let j=i;j<end;j++)types[j]=replace;i=end-1}let order=[];if(1==outerType)for(let i=0;i<len;){let start=i,rtl=1!=types[i++];for(;i<len&&rtl==(1!=types[i]);)i++;if(rtl)for(let j=i;j>start;){let end=j,l=2!=types[--j];for(;j>start&&l==(2!=types[j-1]);)j--;order.push(new BidiSpan(j,end,l?2:1))}else order.push(new BidiSpan(start,i,0))}else for(let i=0;i<len;){let start=i,rtl=2==types[i++];for(;i<len&&rtl==(2==types[i]);)i++;order.push(new BidiSpan(start,i,rtl?1:2))}return order}function trivialOrder(length){return[new BidiSpan(0,length,0)]}let movedOver="";function moveVisually(line,order,dir,start,forward){var _a;let startIndex=start.head-line.from,spanI=-1;if(0==startIndex){if(!forward||!line.length)return null;order[0].level!=dir&&(startIndex=order[0].side(!1,dir),spanI=0)}else if(startIndex==line.length){if(forward)return null;let last=order[order.length-1];last.level!=dir&&(startIndex=last.side(!0,dir),spanI=order.length-1)}spanI<0&&(spanI=BidiSpan.find(order,startIndex,null!==(_a=start.bidiLevel)&&void 0!==_a?_a:-1,start.assoc));let span=order[spanI];startIndex==span.side(forward,dir)&&(span=order[spanI+=forward?1:-1],startIndex=span.side(!forward,dir));let indexForward=forward==(span.dir==dir),nextIndex=state.findClusterBreak(line.text,startIndex,indexForward);if(movedOver=line.text.slice(Math.min(startIndex,nextIndex),Math.max(startIndex,nextIndex)),nextIndex!=span.side(forward,dir))return state.EditorSelection.cursor(nextIndex+line.from,indexForward?-1:1,span.level);let nextSpan=spanI==(forward?order.length-1:0)?null:order[spanI+(forward?1:-1)];return nextSpan||span.level==dir?nextSpan&&nextSpan.level<span.level?state.EditorSelection.cursor(nextSpan.side(!forward,dir)+line.from,forward?1:-1,nextSpan.level):state.EditorSelection.cursor(nextIndex+line.from,forward?-1:1,span.level):state.EditorSelection.cursor(forward?line.to:line.from,forward?-1:1,dir)}class DOMReader{constructor(points,state$1){this.points=points,this.text="",this.lineSeparator=state$1.facet(state.EditorState.lineSeparator)}append(text){this.text+=text}lineBreak(){this.text+=""}readRange(start,end){if(!start)return this;let parent=start.parentNode;for(let cur=start;;){this.findPointBefore(parent,cur),this.readNode(cur);let next=cur.nextSibling;if(next==end)break;let view=ContentView.get(cur),nextView=ContentView.get(next);(view&&nextView?view.breakAfter:(view?view.breakAfter:isBlockElement(cur))||isBlockElement(next)&&("BR"!=cur.nodeName||cur.cmIgnore))&&this.lineBreak(),cur=next}return this.findPointBefore(parent,end),this}readTextNode(node){let text=node.nodeValue;for(let point of this.points)point.node==node&&(point.pos=this.text.length+Math.min(point.offset,text.length));for(let off=0,re=this.lineSeparator?null:/\r\n?|\n/g;;){let m,nextBreak=-1,breakSize=1;if(this.lineSeparator?(nextBreak=text.indexOf(this.lineSeparator,off),breakSize=this.lineSeparator.length):(m=re.exec(text))&&(nextBreak=m.index,breakSize=m[0].length),this.append(text.slice(off,nextBreak<0?text.length:nextBreak)),nextBreak<0)break;if(this.lineBreak(),breakSize>1)for(let point of this.points)point.node==node&&point.pos>this.text.length&&(point.pos-=breakSize-1);off=nextBreak+breakSize}}readNode(node){if(node.cmIgnore)return;let view=ContentView.get(node),fromView=view&&view.overrideDOMText;if(null!=fromView){this.findPointInside(node,fromView.length);for(let i=fromView.iter();!i.next().done;)i.lineBreak?this.lineBreak():this.append(i.value)}else 3==node.nodeType?this.readTextNode(node):"BR"==node.nodeName?node.nextSibling&&this.lineBreak():1==node.nodeType&&this.readRange(node.firstChild,null)}findPointBefore(node,next){for(let point of this.points)point.node==node&&node.childNodes[point.offset]==next&&(point.pos=this.text.length)}findPointInside(node,maxLen){for(let point of this.points)(3==node.nodeType?point.node==node:node.contains(point.node))&&(point.pos=this.text.length+Math.min(maxLen,point.offset))}}function isBlockElement(node){return 1==node.nodeType&&/^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName)}class DOMPoint{constructor(node,offset){this.node=node,this.offset=offset,this.pos=-1}}class DocView extends ContentView{constructor(view){super(),this.view=view,this.compositionDeco=Decoration.none,this.decorations=[],this.dynamicDecorationMap=[],this.minWidth=0,this.minWidthFrom=0,this.minWidthTo=0,this.impreciseAnchor=null,this.impreciseHead=null,this.forceSelection=!1,this.lastUpdate=Date.now(),this.setDOM(view.contentDOM),this.children=[new LineView],this.children[0].setParent(this),this.updateDeco(),this.updateInner([new ChangedRange(0,0,0,view.state.doc.length)],0)}get editorView(){return this.view}get length(){return this.view.state.doc.length}update(update){let changedRanges=update.changedRanges;this.minWidth>0&&changedRanges.length&&(changedRanges.every((({fromA:fromA,toA:toA})=>toA<this.minWidthFrom||fromA>this.minWidthTo))?(this.minWidthFrom=update.changes.mapPos(this.minWidthFrom,1),this.minWidthTo=update.changes.mapPos(this.minWidthTo,1)):this.minWidth=this.minWidthFrom=this.minWidthTo=0),this.view.inputState.composing<0?this.compositionDeco=Decoration.none:(update.transactions.length||this.dirty)&&(this.compositionDeco=function(view,changes){let surrounding=compositionSurroundingNode(view);if(!surrounding)return Decoration.none;let{from:from,to:to,node:node,text:textNode}=surrounding,newFrom=changes.mapPos(from,1),newTo=Math.max(newFrom,changes.mapPos(to,-1)),{state:state}=view,text=3==node.nodeType?node.nodeValue:new DOMReader([],state).readRange(node.firstChild,null).text;if(newTo-newFrom<text.length)if(state.doc.sliceString(newFrom,Math.min(state.doc.length,newFrom+text.length),"")==text)newTo=newFrom+text.length;else{if(state.doc.sliceString(Math.max(0,newTo-text.length),newTo,"")!=text)return Decoration.none;newFrom=newTo-text.length}else if(state.doc.sliceString(newFrom,newTo,"")!=text)return Decoration.none;let topView=ContentView.get(node);topView instanceof CompositionView?topView=topView.widget.topView:topView&&(topView.parent=null);return Decoration.set(Decoration.replace({widget:new CompositionWidget(node,textNode,topView),inclusive:!0}).range(newFrom,newTo))}(this.view,update.changes)),(browser.ie||browser.chrome)&&!this.compositionDeco.size&&update&&update.state.doc.lines!=update.startState.doc.lines&&(this.forceSelection=!0);let decoDiff=function(a,b,diff){let comp=new DecorationComparator$1;return state.RangeSet.compare(a,b,diff,comp),comp.changes}(this.decorations,this.updateDeco(),update.changes);return changedRanges=ChangedRange.extendWithRanges(changedRanges,decoDiff),(0!=this.dirty||0!=changedRanges.length)&&(this.updateInner(changedRanges,update.startState.doc.length),update.transactions.length&&(this.lastUpdate=Date.now()),!0)}updateInner(changes,oldLength){this.view.viewState.mustMeasureContent=!0,this.updateChildren(changes,oldLength);let{observer:observer}=this.view;observer.ignore((()=>{this.dom.style.height=this.view.viewState.contentHeight+"px",this.dom.style.flexBasis=this.minWidth?this.minWidth+"px":"";let track=browser.chrome||browser.ios?{node:observer.selectionRange.focusNode,written:!1}:void 0;this.sync(track),this.dirty=0,track&&(track.written||observer.selectionRange.focusNode!=track.node)&&(this.forceSelection=!0),this.dom.style.height=""}));let gaps=[];if(this.view.viewport.from||this.view.viewport.to<this.view.state.doc.length)for(let child of this.children)child instanceof BlockWidgetView&&child.widget instanceof BlockGapWidget&&gaps.push(child.dom);observer.updateGaps(gaps)}updateChildren(changes,oldLength){let cursor=this.childCursor(oldLength);for(let i=changes.length-1;;i--){let next=i>=0?changes[i]:null;if(!next)break;let{fromA:fromA,toA:toA,fromB:fromB,toB:toB}=next,{content:content,breakAtStart:breakAtStart,openStart:openStart,openEnd:openEnd}=ContentBuilder.build(this.view.state.doc,fromB,toB,this.decorations,this.dynamicDecorationMap),{i:toI,off:toOff}=cursor.findPos(toA,1),{i:fromI,off:fromOff}=cursor.findPos(fromA,-1);replaceRange(this,fromI,fromOff,toI,toOff,content,breakAtStart,openStart,openEnd)}}updateSelection(mustRead=!1,fromPointer=!1){if(!mustRead&&this.view.observer.selectionRange.focusNode||this.view.observer.readSelectionRange(),!fromPointer&&!this.mayControlSelection())return;let force=this.forceSelection;this.forceSelection=!1;let main=this.view.state.selection.main,anchor=this.domAtPos(main.anchor),head=main.empty?anchor:this.domAtPos(main.head);if(browser.gecko&&main.empty&&(1==(pos=anchor).node.nodeType&&pos.node.firstChild&&(0==pos.offset||"false"==pos.node.childNodes[pos.offset-1].contentEditable)&&(pos.offset==pos.node.childNodes.length||"false"==pos.node.childNodes[pos.offset].contentEditable))){let dummy=document.createTextNode("");this.view.observer.ignore((()=>anchor.node.insertBefore(dummy,anchor.node.childNodes[anchor.offset]||null))),anchor=head=new DOMPos(dummy,0),force=!0}var pos;let domSel=this.view.observer.selectionRange;!force&&domSel.focusNode&&isEquivalentPosition(anchor.node,anchor.offset,domSel.anchorNode,domSel.anchorOffset)&&isEquivalentPosition(head.node,head.offset,domSel.focusNode,domSel.focusOffset)||(this.view.observer.ignore((()=>{browser.android&&browser.chrome&&this.dom.contains(domSel.focusNode)&&function(node,inside){for(let cur=node;cur&&cur!=inside;cur=cur.assignedSlot||cur.parentNode)if(1==cur.nodeType&&"false"==cur.contentEditable)return!0;return!1}(domSel.focusNode,this.dom)&&(this.dom.blur(),this.dom.focus({preventScroll:!0}));let rawSel=getSelection(this.view.root);if(rawSel)if(main.empty){if(browser.gecko){let nextTo=(node=anchor.node,offset=anchor.offset,1!=node.nodeType?0:(offset&&"false"==node.childNodes[offset-1].contentEditable?1:0)|(offset<node.childNodes.length&&"false"==node.childNodes[offset].contentEditable?2:0));if(nextTo&&3!=nextTo){let text=nearbyTextNode(anchor.node,anchor.offset,1==nextTo?1:-1);text&&(anchor=new DOMPos(text,1==nextTo?0:text.nodeValue.length))}}rawSel.collapse(anchor.node,anchor.offset),null!=main.bidiLevel&&null!=domSel.cursorBidiLevel&&(domSel.cursorBidiLevel=main.bidiLevel)}else if(rawSel.extend){rawSel.collapse(anchor.node,anchor.offset);try{rawSel.extend(head.node,head.offset)}catch(_){}}else{let range=document.createRange();main.anchor>main.head&&([anchor,head]=[head,anchor]),range.setEnd(head.node,head.offset),range.setStart(anchor.node,anchor.offset),rawSel.removeAllRanges(),rawSel.addRange(range)}else;var node,offset})),this.view.observer.setSelectionRange(anchor,head)),this.impreciseAnchor=anchor.precise?null:new DOMPos(domSel.anchorNode,domSel.anchorOffset),this.impreciseHead=head.precise?null:new DOMPos(domSel.focusNode,domSel.focusOffset)}enforceCursorAssoc(){if(this.compositionDeco.size)return;let{view:view}=this,cursor=view.state.selection.main,sel=getSelection(view.root),{anchorNode:anchorNode,anchorOffset:anchorOffset}=view.observer.selectionRange;if(!(sel&&cursor.empty&&cursor.assoc&&sel.modify))return;let line=LineView.find(this,cursor.head);if(!line)return;let lineStart=line.posAtStart;if(cursor.head==lineStart||cursor.head==lineStart+line.length)return;let before=this.coordsAt(cursor.head,-1),after=this.coordsAt(cursor.head,1);if(!before||!after||before.bottom>after.top)return;let dom=this.domAtPos(cursor.head+cursor.assoc);sel.collapse(dom.node,dom.offset),sel.modify("move",cursor.assoc<0?"forward":"backward","lineboundary"),view.observer.readSelectionRange();let newRange=view.observer.selectionRange;view.docView.posFromDOM(newRange.anchorNode,newRange.anchorOffset)!=cursor.from&&sel.collapse(anchorNode,anchorOffset)}mayControlSelection(){let active=this.view.root.activeElement;return active==this.dom||hasSelection(this.dom,this.view.observer.selectionRange)&&!(active&&this.dom.contains(active))}nearest(dom){for(let cur=dom;cur;){let domView=ContentView.get(cur);if(domView&&domView.rootView==this)return domView;cur=cur.parentNode}return null}posFromDOM(node,offset){let view=this.nearest(node);if(!view)throw new RangeError("Trying to find position for a DOM position outside of the document");return view.localPosFromDOM(node,offset)+view.posAtStart}domAtPos(pos){let{i:i,off:off}=this.childCursor().findPos(pos,-1);for(;i<this.children.length-1;){let child=this.children[i];if(off<child.length||child instanceof LineView)break;i++,off=0}return this.children[i].domAtPos(off)}coordsAt(pos,side){for(let off=this.length,i=this.children.length-1;;i--){let child=this.children[i],start=off-child.breakAfter-child.length;if(pos>start||pos==start&&child.type!=exports.BlockType.WidgetBefore&&child.type!=exports.BlockType.WidgetAfter&&(!i||2==side||this.children[i-1].breakAfter||this.children[i-1].type==exports.BlockType.WidgetBefore&&side>-2))return child.coordsAt(pos-start,side);off=start}}measureVisibleLineHeights(viewport){let result=[],{from:from,to:to}=viewport,contentWidth=this.view.contentDOM.clientWidth,isWider=contentWidth>Math.max(this.view.scrollDOM.clientWidth,this.minWidth)+1,widest=-1,ltr=this.view.textDirection==exports.Direction.LTR;for(let pos=0,i=0;i<this.children.length;i++){let child=this.children[i],end=pos+child.length;if(end>to)break;if(pos>=from){let childRect=child.dom.getBoundingClientRect();if(result.push(childRect.height),isWider){let last=child.dom.lastChild,rects=last?clientRectsFor(last):[];if(rects.length){let rect=rects[rects.length-1],width=ltr?rect.right-childRect.left:childRect.right-rect.left;width>widest&&(widest=width,this.minWidth=contentWidth,this.minWidthFrom=pos,this.minWidthTo=end)}}}pos=end+child.breakAfter}return result}textDirectionAt(pos){let{i:i}=this.childPos(pos,1);return"rtl"==getComputedStyle(this.children[i].dom).direction?exports.Direction.RTL:exports.Direction.LTR}measureTextSize(){for(let child of this.children)if(child instanceof LineView){let measure=child.measureTextSize();if(measure)return measure}let lineHeight,charWidth,dummy=document.createElement("div");return dummy.className="cm-line",dummy.style.width="99999px",dummy.textContent="abc def ghi jkl mno pqr stu",this.view.observer.ignore((()=>{this.dom.appendChild(dummy);let rect=clientRectsFor(dummy.firstChild)[0];lineHeight=dummy.getBoundingClientRect().height,charWidth=rect?rect.width/27:7,dummy.remove()})),{lineHeight:lineHeight,charWidth:charWidth}}childCursor(pos=this.length){let i=this.children.length;return i&&(pos-=this.children[--i].length),new ChildCursor(this.children,pos,i)}computeBlockGapDeco(){let deco=[],vs=this.view.viewState;for(let pos=0,i=0;;i++){let next=i==vs.viewports.length?null:vs.viewports[i],end=next?next.from-1:this.length;if(end>pos){let height=vs.lineBlockAt(end).bottom-vs.lineBlockAt(pos).top;deco.push(Decoration.replace({widget:new BlockGapWidget(height),block:!0,inclusive:!0,isBlockGap:!0}).range(pos,end))}if(!next)break;pos=next.to+1}return Decoration.set(deco)}updateDeco(){let allDeco=this.view.state.facet(decorations).map(((d,i)=>(this.dynamicDecorationMap[i]="function"==typeof d)?d(this.view):d));for(let i=allDeco.length;i<allDeco.length+3;i++)this.dynamicDecorationMap[i]=!1;return this.decorations=[...allDeco,this.compositionDeco,this.computeBlockGapDeco(),this.view.viewState.lineGapDeco]}scrollIntoView(target){let other,{range:range}=target,rect=this.coordsAt(range.head,range.empty?range.assoc:range.head>range.anchor?-1:1);if(!rect)return;!range.empty&&(other=this.coordsAt(range.anchor,range.anchor>range.head?-1:1))&&(rect={left:Math.min(rect.left,other.left),top:Math.min(rect.top,other.top),right:Math.max(rect.right,other.right),bottom:Math.max(rect.bottom,other.bottom)});let mLeft=0,mRight=0,mTop=0,mBottom=0;for(let margins of this.view.state.facet(scrollMargins).map((f=>f(this.view))))if(margins){let{left:left,right:right,top:top,bottom:bottom}=margins;null!=left&&(mLeft=Math.max(mLeft,left)),null!=right&&(mRight=Math.max(mRight,right)),null!=top&&(mTop=Math.max(mTop,top)),null!=bottom&&(mBottom=Math.max(mBottom,bottom))}let targetRect={left:rect.left-mLeft,top:rect.top-mTop,right:rect.right+mRight,bottom:rect.bottom+mBottom};!function(dom,rect,side,x,y,xMargin,yMargin,ltr){let doc=dom.ownerDocument,win=doc.defaultView||window;for(let cur=dom;cur;)if(1==cur.nodeType){let bounding,top=cur==doc.body;if(top)bounding=windowRect(win);else{if(cur.scrollHeight<=cur.clientHeight&&cur.scrollWidth<=cur.clientWidth){cur=cur.assignedSlot||cur.parentNode;continue}let rect=cur.getBoundingClientRect();bounding={left:rect.left,right:rect.left+cur.clientWidth,top:rect.top,bottom:rect.top+cur.clientHeight}}let moveX=0,moveY=0;if("nearest"==y)rect.top<bounding.top?(moveY=-(bounding.top-rect.top+yMargin),side>0&&rect.bottom>bounding.bottom+moveY&&(moveY=rect.bottom-bounding.bottom+moveY+yMargin)):rect.bottom>bounding.bottom&&(moveY=rect.bottom-bounding.bottom+yMargin,side<0&&rect.top-moveY<bounding.top&&(moveY=-(bounding.top+moveY-rect.top+yMargin)));else{let rectHeight=rect.bottom-rect.top,boundingHeight=bounding.bottom-bounding.top;moveY=("center"==y&&rectHeight<=boundingHeight?rect.top+rectHeight/2-boundingHeight/2:"start"==y||"center"==y&&side<0?rect.top-yMargin:rect.bottom-boundingHeight+yMargin)-bounding.top}if("nearest"==x?rect.left<bounding.left?(moveX=-(bounding.left-rect.left+xMargin),side>0&&rect.right>bounding.right+moveX&&(moveX=rect.right-bounding.right+moveX+xMargin)):rect.right>bounding.right&&(moveX=rect.right-bounding.right+xMargin,side<0&&rect.left<bounding.left+moveX&&(moveX=-(bounding.left+moveX-rect.left+xMargin))):moveX=("center"==x?rect.left+(rect.right-rect.left)/2-(bounding.right-bounding.left)/2:"start"==x==ltr?rect.left-xMargin:rect.right-(bounding.right-bounding.left)+xMargin)-bounding.left,moveX||moveY)if(top)win.scrollBy(moveX,moveY);else{let movedX=0,movedY=0;if(moveY){let start=cur.scrollTop;cur.scrollTop+=moveY,movedY=cur.scrollTop-start}if(moveX){let start=cur.scrollLeft;cur.scrollLeft+=moveX,movedX=cur.scrollLeft-start}rect={left:rect.left-movedX,top:rect.top-movedY,right:rect.right-movedX,bottom:rect.bottom-movedY},movedX&&Math.abs(movedX-moveX)<1&&(x="nearest"),movedY&&Math.abs(movedY-moveY)<1&&(y="nearest")}if(top)break;cur=cur.assignedSlot||cur.parentNode}else{if(11!=cur.nodeType)break;cur=cur.host}}(this.view.scrollDOM,targetRect,range.head<range.anchor?-1:1,target.x,target.y,target.xMargin,target.yMargin,this.view.textDirection==exports.Direction.LTR)}}class BlockGapWidget extends WidgetType{constructor(height){super(),this.height=height}toDOM(){let elt=document.createElement("div");return this.updateDOM(elt),elt}eq(other){return other.height==this.height}updateDOM(elt){return elt.style.height=this.height+"px",!0}get estimatedHeight(){return this.height}}function compositionSurroundingNode(view){let sel=view.observer.selectionRange,textNode=sel.focusNode&&nearbyTextNode(sel.focusNode,sel.focusOffset,0);if(!textNode)return null;let cView=view.docView.nearest(textNode);if(!cView)return null;if(cView instanceof LineView){let topNode=textNode;for(;topNode.parentNode!=cView.dom;)topNode=topNode.parentNode;let prev=topNode.previousSibling;for(;prev&&!ContentView.get(prev);)prev=prev.previousSibling;let pos=prev?ContentView.get(prev).posAtEnd:cView.posAtStart;return{from:pos,to:pos,node:topNode,text:textNode}}{for(;;){let{parent:parent}=cView;if(!parent)return null;if(parent instanceof LineView)break;cView=parent}let from=cView.posAtStart;return{from:from,to:from+cView.length,node:cView.dom,text:textNode}}}class CompositionWidget extends WidgetType{constructor(top,text,topView){super(),this.top=top,this.text=text,this.topView=topView}eq(other){return this.top==other.top&&this.text==other.text}toDOM(){return this.top}ignoreEvent(){return!1}get customView(){return CompositionView}}function nearbyTextNode(node,offset,side){for(;;){if(3==node.nodeType)return node;if(1==node.nodeType&&offset>0&&side<=0)offset=maxOffset(node=node.childNodes[offset-1]);else{if(!(1==node.nodeType&&offset<node.childNodes.length&&side>=0))return null;node=node.childNodes[offset],offset=0}}}class DecorationComparator$1{constructor(){this.changes=[]}compareRange(from,to){addRange(from,to,this.changes)}comparePoint(from,to){addRange(from,to,this.changes)}}function getdx(x,rect){return rect.left>x?rect.left-x:Math.max(0,x-rect.right)}function getdy(y,rect){return rect.top>y?rect.top-y:Math.max(0,y-rect.bottom)}function yOverlap(a,b){return a.top<b.bottom-1&&a.bottom>b.top+1}function upTop(rect,top){return top<rect.top?{top:top,left:rect.left,right:rect.right,bottom:rect.bottom}:rect}function upBot(rect,bottom){return bottom>rect.bottom?{top:rect.top,left:rect.left,right:rect.right,bottom:bottom}:rect}function domPosAtCoords(parent,x,y){let closest,closestRect,closestX,closestY,above,below,aboveRect,belowRect,closestOverlap=!1;for(let child=parent.firstChild;child;child=child.nextSibling){let rects=clientRectsFor(child);for(let i=0;i<rects.length;i++){let rect=rects[i];closestRect&&yOverlap(closestRect,rect)&&(rect=upTop(upBot(rect,closestRect.bottom),closestRect.top));let dx=getdx(x,rect),dy=getdy(y,rect);if(0==dx&&0==dy)return 3==child.nodeType?domPosInText(child,x,y):domPosAtCoords(child,x,y);if(!closest||closestY>dy||closestY==dy&&closestX>dx){closest=child,closestRect=rect,closestX=dx,closestY=dy;let side=dy?y<rect.top?-1:1:dx?x<rect.left?-1:1:0;closestOverlap=!side||(side>0?i<rects.length-1:i>0)}0==dx?y>rect.bottom&&(!aboveRect||aboveRect.bottom<rect.bottom)?(above=child,aboveRect=rect):y<rect.top&&(!belowRect||belowRect.top>rect.top)&&(below=child,belowRect=rect):aboveRect&&yOverlap(aboveRect,rect)?aboveRect=upBot(aboveRect,rect.bottom):belowRect&&yOverlap(belowRect,rect)&&(belowRect=upTop(belowRect,rect.top))}}if(aboveRect&&aboveRect.bottom>=y?(closest=above,closestRect=aboveRect):belowRect&&belowRect.top<=y&&(closest=below,closestRect=belowRect),!closest)return{node:parent,offset:0};let clipX=Math.max(closestRect.left,Math.min(closestRect.right,x));return 3==closest.nodeType?domPosInText(closest,clipX,y):closestOverlap&&"false"!=closest.contentEditable?domPosAtCoords(closest,clipX,y):{node:parent,offset:Array.prototype.indexOf.call(parent.childNodes,closest)+(x>=(closestRect.left+closestRect.right)/2?1:0)}}function domPosInText(node,x,y){let len=node.nodeValue.length,closestOffset=-1,closestDY=1e9,generalSide=0;for(let i=0;i<len;i++){let rects=textRange(node,i,i+1).getClientRects();for(let j=0;j<rects.length;j++){let rect=rects[j];if(rect.top==rect.bottom)continue;generalSide||(generalSide=x-rect.left);let dy=(rect.top>y?rect.top-y:y-rect.bottom)-1;if(rect.left-1<=x&&rect.right+1>=x&&dy<closestDY){let right=x>=(rect.left+rect.right)/2,after=right;if(browser.chrome||browser.gecko){textRange(node,i).getBoundingClientRect().left==rect.right&&(after=!right)}if(dy<=0)return{node:node,offset:i+(after?1:0)};closestOffset=i+(after?1:0),closestDY=dy}}}return{node:node,offset:closestOffset>-1?closestOffset:generalSide>0?node.nodeValue.length:0}}function posAtCoords(view,{x:x,y:y},precise,bias=-1){var _a;let block,content=view.contentDOM.getBoundingClientRect(),docTop=content.top+view.viewState.paddingTop,{docHeight:docHeight}=view.viewState,yOffset=y-docTop;if(yOffset<0)return 0;if(yOffset>docHeight)return view.state.doc.length;for(let halfLine=view.defaultLineHeight/2,bounced=!1;block=view.elementAtHeight(yOffset),block.type!=exports.BlockType.Text;)for(;yOffset=bias>0?block.bottom+halfLine:block.top-halfLine,!(yOffset>=0&&yOffset<=docHeight);){if(bounced)return precise?null:0;bounced=!0,bias=-bias}y=docTop+yOffset;let lineStart=block.from;if(lineStart<view.viewport.from)return 0==view.viewport.from?0:precise?null:posAtCoordsImprecise(view,content,block,x,y);if(lineStart>view.viewport.to)return view.viewport.to==view.state.doc.length?view.state.doc.length:precise?null:posAtCoordsImprecise(view,content,block,x,y);let doc=view.dom.ownerDocument,root=view.root.elementFromPoint?view.root:doc,element=root.elementFromPoint(x,y);element&&!view.contentDOM.contains(element)&&(element=null),element||(x=Math.max(content.left+1,Math.min(content.right-1,x)),element=root.elementFromPoint(x,y),element&&!view.contentDOM.contains(element)&&(element=null));let node,offset=-1;if(element&&0!=(null===(_a=view.docView.nearest(element))||void 0===_a?void 0:_a.isEditable))if(doc.caretPositionFromPoint){let pos=doc.caretPositionFromPoint(x,y);pos&&({offsetNode:node,offset:offset}=pos)}else if(doc.caretRangeFromPoint){let range=doc.caretRangeFromPoint(x,y);range&&(({startContainer:node,startOffset:offset}=range),(!view.contentDOM.contains(node)||browser.safari&&function(node,offset,x){let len;if(3!=node.nodeType||offset!=(len=node.nodeValue.length))return!1;for(let next=node.nextSibling;next;next=next.nextSibling)if(1!=next.nodeType||"BR"!=next.nodeName)return!1;return textRange(node,len-1,len).getBoundingClientRect().left>x}(node,offset,x)||browser.chrome&&function(node,offset,x){if(0!=offset)return!1;for(let cur=node;;){let parent=cur.parentNode;if(!parent||1!=parent.nodeType||parent.firstChild!=cur)return!1;if(parent.classList.contains("cm-line"))break;cur=parent}let rect=1==node.nodeType?node.getBoundingClientRect():textRange(node,0,Math.max(node.nodeValue.length,1)).getBoundingClientRect();return x-rect.left>5}(node,offset,x))&&(node=void 0))}if(!node||!view.docView.dom.contains(node)){let line=LineView.find(view.docView,lineStart);if(!line)return yOffset>block.top+block.height/2?block.to:block.from;({node:node,offset:offset}=domPosAtCoords(line.dom,x,y))}return view.docView.posFromDOM(node,offset)}function posAtCoordsImprecise(view,contentRect,block,x,y){let into=Math.round((x-contentRect.left)*view.defaultCharacterWidth);if(view.lineWrapping&&block.height>1.5*view.defaultLineHeight){into+=Math.floor((y-block.top)/view.defaultLineHeight)*view.viewState.heightOracle.lineLength}let content=view.state.sliceDoc(block.from,block.to);return block.from+state.findColumn(content,into,view.state.tabSize)}function moveByChar(view,start,forward,by){let line=view.state.doc.lineAt(start.head),spans=view.bidiSpans(line),direction=view.textDirectionAt(line.from);for(let cur=start,check=null;;){let next=moveVisually(line,spans,direction,cur,forward),char=movedOver;if(!next){if(line.number==(forward?view.state.doc.lines:1))return cur;char="\n",line=view.state.doc.line(line.number+(forward?1:-1)),spans=view.bidiSpans(line),next=state.EditorSelection.cursor(forward?line.from:line.to)}if(check){if(!check(char))return cur}else{if(!by)return next;check=by(char)}cur=next}}function skipAtoms(view,oldPos,pos){let atoms=view.state.facet(atomicRanges).map((f=>f(view)));for(;;){let moved=!1;for(let set of atoms)set.between(pos.from-1,pos.from+1,((from,to,value)=>{pos.from>from&&pos.from<to&&(pos=oldPos.head>pos.from?state.EditorSelection.cursor(from,1):state.EditorSelection.cursor(to,-1),moved=!0)}));if(!moved)return pos}}class InputState{constructor(view){this.lastKeyCode=0,this.lastKeyTime=0,this.lastTouchTime=0,this.lastFocusTime=0,this.lastScrollTop=0,this.lastScrollLeft=0,this.chromeScrollHack=-1,this.pendingIOSKey=void 0,this.lastSelectionOrigin=null,this.lastSelectionTime=0,this.lastEscPress=0,this.lastContextMenu=0,this.scrollHandlers=[],this.registeredEvents=[],this.customHandlers=[],this.composing=-1,this.compositionFirstChange=null,this.compositionEndedAt=0,this.mouseSelection=null;let handleEvent=(handler,event)=>{this.ignoreDuringComposition(event)||"keydown"==event.type&&this.keydown(view,event)||(this.mustFlushObserver(event)&&view.observer.forceFlush(),this.runCustomHandlers(event.type,view,event)?event.preventDefault():handler(view,event))};for(let type in handlers){let handler=handlers[type];view.contentDOM.addEventListener(type,(event=>{eventBelongsToEditor(view,event)&&handleEvent(handler,event)}),handlerOptions[type]),this.registeredEvents.push(type)}view.scrollDOM.addEventListener("mousedown",(event=>{event.target==view.scrollDOM&&handleEvent(handlers.mousedown,event)})),browser.chrome&&102==browser.chrome_version&&view.scrollDOM.addEventListener("wheel",(()=>{this.chromeScrollHack<0?view.contentDOM.style.pointerEvents="none":window.clearTimeout(this.chromeScrollHack),this.chromeScrollHack=setTimeout((()=>{this.chromeScrollHack=-1,view.contentDOM.style.pointerEvents=""}),100)}),{passive:!0}),this.notifiedFocused=view.hasFocus,browser.safari&&view.contentDOM.addEventListener("input",(()=>null))}setSelectionOrigin(origin){this.lastSelectionOrigin=origin,this.lastSelectionTime=Date.now()}ensureHandlers(view,plugins){var _a;let handlers;this.customHandlers=[];for(let plugin of plugins)if(handlers=null===(_a=plugin.update(view).spec)||void 0===_a?void 0:_a.domEventHandlers){this.customHandlers.push({plugin:plugin.value,handlers:handlers});for(let type in handlers)this.registeredEvents.indexOf(type)<0&&"scroll"!=type&&(this.registeredEvents.push(type),view.contentDOM.addEventListener(type,(event=>{eventBelongsToEditor(view,event)&&this.runCustomHandlers(type,view,event)&&event.preventDefault()})))}}runCustomHandlers(type,view,event){for(let set of this.customHandlers){let handler=set.handlers[type];if(handler)try{if(handler.call(set.plugin,event,view)||event.defaultPrevented)return!0}catch(e){logException(view.state,e)}}return!1}runScrollHandlers(view,event){this.lastScrollTop=view.scrollDOM.scrollTop,this.lastScrollLeft=view.scrollDOM.scrollLeft;for(let set of this.customHandlers){let handler=set.handlers.scroll;if(handler)try{handler.call(set.plugin,event,view)}catch(e){logException(view.state,e)}}}keydown(view,event){if(this.lastKeyCode=event.keyCode,this.lastKeyTime=Date.now(),9==event.keyCode&&Date.now()<this.lastEscPress+2e3)return!0;if(browser.android&&browser.chrome&&!event.synthetic&&(13==event.keyCode||8==event.keyCode))return view.observer.delayAndroidKey(event.key,event.keyCode),!0;let pending;return!(!browser.ios||event.synthetic||event.altKey||event.metaKey||!((pending=PendingKeys.find((key=>key.keyCode==event.keyCode)))&&!event.ctrlKey||EmacsyPendingKeys.indexOf(event.key)>-1&&event.ctrlKey&&!event.shiftKey))&&(this.pendingIOSKey=pending||event,setTimeout((()=>this.flushIOSKey(view)),250),!0)}flushIOSKey(view){let key=this.pendingIOSKey;return!!key&&(this.pendingIOSKey=void 0,dispatchKey(view.contentDOM,key.key,key.keyCode))}ignoreDuringComposition(event){return!!/^key/.test(event.type)&&(this.composing>0||!!(browser.safari&&!browser.ios&&Date.now()-this.compositionEndedAt<100)&&(this.compositionEndedAt=0,!0))}mustFlushObserver(event){return"keydown"==event.type&&229!=event.keyCode}startMouseSelection(mouseSelection){this.mouseSelection&&this.mouseSelection.destroy(),this.mouseSelection=mouseSelection}update(update){this.mouseSelection&&this.mouseSelection.update(update),update.transactions.length&&(this.lastKeyCode=this.lastSelectionTime=0)}destroy(){this.mouseSelection&&this.mouseSelection.destroy()}}const PendingKeys=[{key:"Backspace",keyCode:8,inputType:"deleteContentBackward"},{key:"Enter",keyCode:13,inputType:"insertParagraph"},{key:"Delete",keyCode:46,inputType:"deleteContentForward"}],EmacsyPendingKeys="dthko",modifierCodes=[16,17,18,20,91,92,224,225];function dragScrollSpeed(dist){return.7*dist+8}class MouseSelection{constructor(view,startEvent,style,mustSelect){this.view=view,this.style=style,this.mustSelect=mustSelect,this.scrollSpeed={x:0,y:0},this.scrolling=-1,this.lastEvent=startEvent,this.scrollParent=function(dom){let doc=dom.ownerDocument;for(let cur=dom.parentNode;cur&&cur!=doc.body;)if(1==cur.nodeType){if(cur.scrollHeight>cur.clientHeight||cur.scrollWidth>cur.clientWidth)return cur;cur=cur.assignedSlot||cur.parentNode}else{if(11!=cur.nodeType)break;cur=cur.host}return null}(view.contentDOM);let doc=view.contentDOM.ownerDocument;doc.addEventListener("mousemove",this.move=this.move.bind(this)),doc.addEventListener("mouseup",this.up=this.up.bind(this)),this.extend=startEvent.shiftKey,this.multiple=view.state.facet(state.EditorState.allowMultipleSelections)&&function(view,event){let facet=view.state.facet(clickAddsSelectionRange);return facet.length?facet[0](event):browser.mac?event.metaKey:event.ctrlKey}(view,startEvent),this.dragMove=function(view,event){let facet=view.state.facet(dragMovesSelection$1);return facet.length?facet[0](event):browser.mac?!event.altKey:!event.ctrlKey}(view,startEvent),this.dragging=!(!function(view,event){let{main:main}=view.state.selection;if(main.empty)return!1;let sel=getSelection(view.root);if(!sel||0==sel.rangeCount)return!0;let rects=sel.getRangeAt(0).getClientRects();for(let i=0;i<rects.length;i++){let rect=rects[i];if(rect.left<=event.clientX&&rect.right>=event.clientX&&rect.top<=event.clientY&&rect.bottom>=event.clientY)return!0}return!1}(view,startEvent)||1!=getClickType(startEvent))&&null,!1===this.dragging&&(startEvent.preventDefault(),this.select(startEvent))}move(event){var _a;if(0==event.buttons)return this.destroy();if(!1!==this.dragging)return;this.select(this.lastEvent=event);let sx=0,sy=0,rect=(null===(_a=this.scrollParent)||void 0===_a?void 0:_a.getBoundingClientRect())||{left:0,top:0,right:this.view.win.innerWidth,bottom:this.view.win.innerHeight};event.clientX<=rect.left?sx=-dragScrollSpeed(rect.left-event.clientX):event.clientX>=rect.right&&(sx=dragScrollSpeed(event.clientX-rect.right)),event.clientY<=rect.top?sy=-dragScrollSpeed(rect.top-event.clientY):event.clientY>=rect.bottom&&(sy=dragScrollSpeed(event.clientY-rect.bottom)),this.setScrollSpeed(sx,sy)}up(event){null==this.dragging&&this.select(this.lastEvent),this.dragging||event.preventDefault(),this.destroy()}destroy(){this.setScrollSpeed(0,0);let doc=this.view.contentDOM.ownerDocument;doc.removeEventListener("mousemove",this.move),doc.removeEventListener("mouseup",this.up),this.view.inputState.mouseSelection=null}setScrollSpeed(sx,sy){this.scrollSpeed={x:sx,y:sy},sx||sy?this.scrolling<0&&(this.scrolling=setInterval((()=>this.scroll()),50)):this.scrolling>-1&&(clearInterval(this.scrolling),this.scrolling=-1)}scroll(){this.scrollParent?(this.scrollParent.scrollLeft+=this.scrollSpeed.x,this.scrollParent.scrollTop+=this.scrollSpeed.y):this.view.win.scrollBy(this.scrollSpeed.x,this.scrollSpeed.y),!1===this.dragging&&this.select(this.lastEvent)}select(event){let selection=this.style.get(event,this.extend,this.multiple);!this.mustSelect&&selection.eq(this.view.state.selection)&&selection.main.assoc==this.view.state.selection.main.assoc||this.view.dispatch({selection:selection,userEvent:"select.pointer"}),this.mustSelect=!1}update(update){update.docChanged&&this.dragging&&(this.dragging=this.dragging.map(update.changes)),this.style.update(update)&&setTimeout((()=>this.select(this.lastEvent)),20)}}function eventBelongsToEditor(view,event){if(!event.bubbles)return!0;if(event.defaultPrevented)return!1;for(let cView,node=event.target;node!=view.contentDOM;node=node.parentNode)if(!node||11==node.nodeType||(cView=ContentView.get(node))&&cView.ignoreEvent(event))return!1;return!0}const handlers=Object.create(null),handlerOptions=Object.create(null),brokenClipboardAPI=browser.ie&&browser.ie_version<15||browser.ios&&browser.webkit_version<604;function doPaste(view,input){let changes,{state:state$1}=view,i=1,text=state$1.toText(input),byLine=text.lines==state$1.selection.ranges.length;if(null!=lastLinewiseCopy&&state$1.selection.ranges.every((r=>r.empty))&&lastLinewiseCopy==text.toString()){let lastLine=-1;changes=state$1.changeByRange((range=>{let line=state$1.doc.lineAt(range.from);if(line.from==lastLine)return{range:range};lastLine=line.from;let insert=state$1.toText((byLine?text.line(i++).text:input)+state$1.lineBreak);return{changes:{from:line.from,insert:insert},range:state.EditorSelection.cursor(range.from+insert.length)}}))}else changes=byLine?state$1.changeByRange((range=>{let line=text.line(i++);return{changes:{from:range.from,to:range.to,insert:line.text},range:state.EditorSelection.cursor(range.from+line.length)}})):state$1.replaceSelection(text);view.dispatch(changes,{userEvent:"input.paste",scrollIntoView:!0})}function rangeForClick(view,pos,bias,type){if(1==type)return state.EditorSelection.cursor(pos,bias);if(2==type)return function(state$1,pos,bias=1){let categorize=state$1.charCategorizer(pos),line=state$1.doc.lineAt(pos),linePos=pos-line.from;if(0==line.length)return state.EditorSelection.cursor(pos);0==linePos?bias=1:linePos==line.length&&(bias=-1);let from=linePos,to=linePos;bias<0?from=state.findClusterBreak(line.text,linePos,!1):to=state.findClusterBreak(line.text,linePos);let cat=categorize(line.text.slice(from,to));for(;from>0;){let prev=state.findClusterBreak(line.text,from,!1);if(categorize(line.text.slice(prev,from))!=cat)break;from=prev}for(;to<line.length;){let next=state.findClusterBreak(line.text,to);if(categorize(line.text.slice(to,next))!=cat)break;to=next}return state.EditorSelection.range(from+line.from,to+line.from)}(view.state,pos,bias);{let visual=LineView.find(view.docView,pos),line=view.state.doc.lineAt(visual?visual.posAtEnd:pos),from=visual?visual.posAtStart:line.from,to=visual?visual.posAtEnd:line.to;return to<view.state.doc.length&&to==line.to&&to++,state.EditorSelection.range(from,to)}}handlers.keydown=(view,event)=>{view.inputState.setSelectionOrigin("select"),27==event.keyCode?view.inputState.lastEscPress=Date.now():modifierCodes.indexOf(event.keyCode)<0&&(view.inputState.lastEscPress=0)},handlers.touchstart=(view,e)=>{view.inputState.lastTouchTime=Date.now(),view.inputState.setSelectionOrigin("select.pointer")},handlers.touchmove=view=>{view.inputState.setSelectionOrigin("select.pointer")},handlerOptions.touchstart=handlerOptions.touchmove={passive:!0},handlers.mousedown=(view,event)=>{if(view.observer.flush(),view.inputState.lastTouchTime>Date.now()-2e3)return;let style=null;for(let makeStyle of view.state.facet(mouseSelectionStyle))if(style=makeStyle(view,event),style)break;if(style||0!=event.button||(style=function(view,event){let start=queryPos(view,event),type=getClickType(event),startSel=view.state.selection;return{update(update){update.docChanged&&(start.pos=update.changes.mapPos(start.pos),startSel=startSel.map(update.changes))},get(event,extend,multiple){let cur=queryPos(view,event),range=rangeForClick(view,cur.pos,cur.bias,type);if(start.pos!=cur.pos&&!extend){let startRange=rangeForClick(view,start.pos,start.bias,type),from=Math.min(startRange.from,range.from),to=Math.max(startRange.to,range.to);range=from<range.from?state.EditorSelection.range(from,to):state.EditorSelection.range(to,from)}return extend?startSel.replaceRange(startSel.main.extend(range.from,range.to)):multiple&&startSel.ranges.length>1&&startSel.ranges.some((r=>r.eq(range)))?function(sel,range){for(let i=0;;i++)if(sel.ranges[i].eq(range))return state.EditorSelection.create(sel.ranges.slice(0,i).concat(sel.ranges.slice(i+1)),sel.mainIndex==i?0:sel.mainIndex-(sel.mainIndex>i?1:0))}(startSel,range):multiple?startSel.addRange(range):state.EditorSelection.create([range])}}}(view,event)),style){let mustFocus=view.root.activeElement!=view.contentDOM;mustFocus&&view.observer.ignore((()=>focusPreventScroll(view.contentDOM))),view.inputState.startMouseSelection(new MouseSelection(view,event,style,mustFocus))}};let insideY=(y,rect)=>y>=rect.top&&y<=rect.bottom,inside=(x,y,rect)=>insideY(y,rect)&&x>=rect.left&&x<=rect.right;function findPositionSide(view,pos,x,y){let line=LineView.find(view.docView,pos);if(!line)return 1;let off=pos-line.posAtStart;if(0==off)return 1;if(off==line.length)return-1;let before=line.coordsAt(off,-1);if(before&&inside(x,y,before))return-1;let after=line.coordsAt(off,1);return after&&inside(x,y,after)?1:before&&insideY(y,before)?-1:1}function queryPos(view,event){let pos=view.posAtCoords({x:event.clientX,y:event.clientY},!1);return{pos:pos,bias:findPositionSide(view,pos,event.clientX,event.clientY)}}const BadMouseDetail=browser.ie&&browser.ie_version<=11;let lastMouseDown=null,lastMouseDownCount=0,lastMouseDownTime=0;function getClickType(event){if(!BadMouseDetail)return event.detail;let last=lastMouseDown,lastTime=lastMouseDownTime;return lastMouseDown=event,lastMouseDownTime=Date.now(),lastMouseDownCount=!last||lastTime>Date.now()-400&&Math.abs(last.clientX-event.clientX)<2&&Math.abs(last.clientY-event.clientY)<2?(lastMouseDownCount+1)%3:1}function dropText(view,event,text,direct){if(!text)return;let dropPos=view.posAtCoords({x:event.clientX,y:event.clientY},!1);event.preventDefault();let{mouseSelection:mouseSelection}=view.inputState,del=direct&&mouseSelection&&mouseSelection.dragging&&mouseSelection.dragMove?{from:mouseSelection.dragging.from,to:mouseSelection.dragging.to}:null,ins={from:dropPos,insert:text},changes=view.state.changes(del?[del,ins]:ins);view.focus(),view.dispatch({changes:changes,selection:{anchor:changes.mapPos(dropPos,-1),head:changes.mapPos(dropPos,1)},userEvent:del?"move.drop":"input.drop"})}handlers.dragstart=(view,event)=>{let{selection:{main:main}}=view.state,{mouseSelection:mouseSelection}=view.inputState;mouseSelection&&(mouseSelection.dragging=main),event.dataTransfer&&(event.dataTransfer.setData("Text",view.state.sliceDoc(main.from,main.to)),event.dataTransfer.effectAllowed="copyMove")},handlers.drop=(view,event)=>{if(!event.dataTransfer)return;if(view.state.readOnly)return event.preventDefault();let files=event.dataTransfer.files;if(files&&files.length){event.preventDefault();let text=Array(files.length),read=0,finishFile=()=>{++read==files.length&&dropText(view,event,text.filter((s=>null!=s)).join(view.state.lineBreak),!1)};for(let i=0;i<files.length;i++){let reader=new FileReader;reader.onerror=finishFile,reader.onload=()=>{/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result)||(text[i]=reader.result),finishFile()},reader.readAsText(files[i])}}else dropText(view,event,event.dataTransfer.getData("Text"),!0)},handlers.paste=(view,event)=>{if(view.state.readOnly)return event.preventDefault();view.observer.flush();let data=brokenClipboardAPI?null:event.clipboardData;data?(doPaste(view,data.getData("text/plain")),event.preventDefault()):function(view){let parent=view.dom.parentNode;if(!parent)return;let target=parent.appendChild(document.createElement("textarea"));target.style.cssText="position: fixed; left: -10000px; top: 10px",target.focus(),setTimeout((()=>{view.focus(),target.remove(),doPaste(view,target.value)}),50)}(view)};let lastLinewiseCopy=null;function updateForFocusChange(view){setTimeout((()=>{view.hasFocus!=view.inputState.notifiedFocused&&view.update([])}),10)}handlers.copy=handlers.cut=(view,event)=>{let{text:text,ranges:ranges,linewise:linewise}=function(state){let content=[],ranges=[],linewise=!1;for(let range of state.selection.ranges)range.empty||(content.push(state.sliceDoc(range.from,range.to)),ranges.push(range));if(!content.length){let upto=-1;for(let{from:from}of state.selection.ranges){let line=state.doc.lineAt(from);line.number>upto&&(content.push(line.text),ranges.push({from:line.from,to:Math.min(state.doc.length,line.to+1)})),upto=line.number}linewise=!0}return{text:content.join(state.lineBreak),ranges:ranges,linewise:linewise}}(view.state);if(!text&&!linewise)return;lastLinewiseCopy=linewise?text:null;let data=brokenClipboardAPI?null:event.clipboardData;data?(event.preventDefault(),data.clearData(),data.setData("text/plain",text)):function(view,text){let parent=view.dom.parentNode;if(!parent)return;let target=parent.appendChild(document.createElement("textarea"));target.style.cssText="position: fixed; left: -10000px; top: 10px",target.value=text,target.focus(),target.selectionEnd=text.length,target.selectionStart=0,setTimeout((()=>{target.remove(),view.focus()}),50)}(view,text),"cut"!=event.type||view.state.readOnly||view.dispatch({changes:ranges,scrollIntoView:!0,userEvent:"delete.cut"})},handlers.focus=view=>{view.inputState.lastFocusTime=Date.now(),view.scrollDOM.scrollTop||!view.inputState.lastScrollTop&&!view.inputState.lastScrollLeft||(view.scrollDOM.scrollTop=view.inputState.lastScrollTop,view.scrollDOM.scrollLeft=view.inputState.lastScrollLeft),updateForFocusChange(view)},handlers.blur=view=>{view.observer.clearSelectionRange(),updateForFocusChange(view)},handlers.compositionstart=handlers.compositionupdate=view=>{null==view.inputState.compositionFirstChange&&(view.inputState.compositionFirstChange=!0),view.inputState.composing<0&&(view.inputState.composing=0)},handlers.compositionend=view=>{view.inputState.composing=-1,view.inputState.compositionEndedAt=Date.now(),view.inputState.compositionFirstChange=null,browser.chrome&&browser.android&&view.observer.flushSoon(),setTimeout((()=>{view.inputState.composing<0&&view.docView.compositionDeco.size&&view.update([])}),50)},handlers.contextmenu=view=>{view.inputState.lastContextMenu=Date.now()},handlers.beforeinput=(view,event)=>{var _a;let pending;if(browser.chrome&&browser.android&&(pending=PendingKeys.find((key=>key.inputType==event.inputType)))&&(view.observer.delayAndroidKey(pending.key,pending.keyCode),"Backspace"==pending.key||"Delete"==pending.key)){let startViewHeight=(null===(_a=window.visualViewport)||void 0===_a?void 0:_a.height)||0;setTimeout((()=>{var _a;((null===(_a=window.visualViewport)||void 0===_a?void 0:_a.height)||0)>startViewHeight+10&&view.hasFocus&&(view.contentDOM.blur(),view.focus())}),100)}};const wrappingWhiteSpace=["pre-wrap","normal","pre-line","break-spaces"];class HeightOracle{constructor(lineWrapping){this.lineWrapping=lineWrapping,this.doc=state.Text.empty,this.heightSamples={},this.lineHeight=14,this.charWidth=7,this.lineLength=30,this.heightChanged=!1}heightForGap(from,to){let lines=this.doc.lineAt(to).number-this.doc.lineAt(from).number+1;return this.lineWrapping&&(lines+=Math.ceil((to-from-lines*this.lineLength*.5)/this.lineLength)),this.lineHeight*lines}heightForLine(length){if(!this.lineWrapping)return this.lineHeight;return(1+Math.max(0,Math.ceil((length-this.lineLength)/(this.lineLength-5))))*this.lineHeight}setDoc(doc){return this.doc=doc,this}mustRefreshForWrapping(whiteSpace){return wrappingWhiteSpace.indexOf(whiteSpace)>-1!=this.lineWrapping}mustRefreshForHeights(lineHeights){let newHeight=!1;for(let i=0;i<lineHeights.length;i++){let h=lineHeights[i];h<0?i++:this.heightSamples[Math.floor(10*h)]||(newHeight=!0,this.heightSamples[Math.floor(10*h)]=!0)}return newHeight}refresh(whiteSpace,lineHeight,charWidth,lineLength,knownHeights){let lineWrapping=wrappingWhiteSpace.indexOf(whiteSpace)>-1,changed=Math.round(lineHeight)!=Math.round(this.lineHeight)||this.lineWrapping!=lineWrapping;if(this.lineWrapping=lineWrapping,this.lineHeight=lineHeight,this.charWidth=charWidth,this.lineLength=lineLength,changed){this.heightSamples={};for(let i=0;i<knownHeights.length;i++){let h=knownHeights[i];h<0?i++:this.heightSamples[Math.floor(10*h)]=!0}}return changed}}class MeasuredHeights{constructor(from,heights){this.from=from,this.heights=heights,this.index=0}get more(){return this.index<this.heights.length}}class BlockInfo{constructor(from,length,top,height,type){this.from=from,this.length=length,this.top=top,this.height=height,this.type=type}get to(){return this.from+this.length}get bottom(){return this.top+this.height}join(other){let detail=(Array.isArray(this.type)?this.type:[this]).concat(Array.isArray(other.type)?other.type:[other]);return new BlockInfo(this.from,this.length+other.length,this.top,this.height+other.height,detail)}}var QueryType;!function(QueryType){QueryType[QueryType.ByPos=0]="ByPos",QueryType[QueryType.ByHeight=1]="ByHeight",QueryType[QueryType.ByPosNoHeight=2]="ByPosNoHeight"}(QueryType||(QueryType={}));class HeightMap{constructor(length,height,flags=2){this.length=length,this.height=height,this.flags=flags}get outdated(){return(2&this.flags)>0}set outdated(value){this.flags=(value?2:0)|-3&this.flags}setHeight(oracle,height){this.height!=height&&(Math.abs(this.height-height)>.001&&(oracle.heightChanged=!0),this.height=height)}replace(_from,_to,nodes){return HeightMap.of(nodes)}decomposeLeft(_to,result){result.push(this)}decomposeRight(_from,result){result.push(this)}applyChanges(decorations,oldDoc,oracle,changes){let me=this;for(let i=changes.length-1;i>=0;i--){let{fromA:fromA,toA:toA,fromB:fromB,toB:toB}=changes[i],start=me.lineAt(fromA,QueryType.ByPosNoHeight,oldDoc,0,0),end=start.to>=toA?start:me.lineAt(toA,QueryType.ByPosNoHeight,oldDoc,0,0);for(toB+=end.to-toA,toA=end.to;i>0&&start.from<=changes[i-1].toA;)fromA=changes[i-1].fromA,fromB=changes[i-1].fromB,i--,fromA<start.from&&(start=me.lineAt(fromA,QueryType.ByPosNoHeight,oldDoc,0,0));fromB+=start.from-fromA,fromA=start.from;let nodes=NodeBuilder.build(oracle,decorations,fromB,toB);me=me.replace(fromA,toA,nodes)}return me.updateHeight(oracle,0)}static empty(){return new HeightMapText(0,0)}static of(nodes){if(1==nodes.length)return nodes[0];let i=0,j=nodes.length,before=0,after=0;for(;;)if(i==j)if(before>2*after){let split=nodes[i-1];split.break?nodes.splice(--i,1,split.left,null,split.right):nodes.splice(--i,1,split.left,split.right),j+=1+split.break,before-=split.size}else{if(!(after>2*before))break;{let split=nodes[j];split.break?nodes.splice(j,1,split.left,null,split.right):nodes.splice(j,1,split.left,split.right),j+=2+split.break,after-=split.size}}else if(before<after){let next=nodes[i++];next&&(before+=next.size)}else{let next=nodes[--j];next&&(after+=next.size)}let brk=0;return null==nodes[i-1]?(brk=1,i--):null==nodes[i]&&(brk=1,j++),new HeightMapBranch(HeightMap.of(nodes.slice(0,i)),brk,HeightMap.of(nodes.slice(j)))}}HeightMap.prototype.size=1;class HeightMapBlock extends HeightMap{constructor(length,height,type){super(length,height),this.type=type}blockAt(_height,_doc,top,offset){return new BlockInfo(offset,this.length,top,this.height,this.type)}lineAt(_value,_type,doc,top,offset){return this.blockAt(0,doc,top,offset)}forEachLine(from,to,doc,top,offset,f){from<=offset+this.length&&to>=offset&&f(this.blockAt(0,doc,top,offset))}updateHeight(oracle,offset=0,_force=!1,measured){return measured&&measured.from<=offset&&measured.more&&this.setHeight(oracle,measured.heights[measured.index++]),this.outdated=!1,this}toString(){return`block(${this.length})`}}class HeightMapText extends HeightMapBlock{constructor(length,height){super(length,height,exports.BlockType.Text),this.collapsed=0,this.widgetHeight=0}replace(_from,_to,nodes){let node=nodes[0];return 1==nodes.length&&(node instanceof HeightMapText||node instanceof HeightMapGap&&4&node.flags)&&Math.abs(this.length-node.length)<10?(node instanceof HeightMapGap?node=new HeightMapText(node.length,this.height):node.height=this.height,this.outdated||(node.outdated=!1),node):HeightMap.of(nodes)}updateHeight(oracle,offset=0,force=!1,measured){return measured&&measured.from<=offset&&measured.more?this.setHeight(oracle,measured.heights[measured.index++]):(force||this.outdated)&&this.setHeight(oracle,Math.max(this.widgetHeight,oracle.heightForLine(this.length-this.collapsed))),this.outdated=!1,this}toString(){return`line(${this.length}${this.collapsed?-this.collapsed:""}${this.widgetHeight?":"+this.widgetHeight:""})`}}class HeightMapGap extends HeightMap{constructor(length){super(length,0)}lines(doc,offset){let firstLine=doc.lineAt(offset).number,lastLine=doc.lineAt(offset+this.length).number;return{firstLine:firstLine,lastLine:lastLine,lineHeight:this.height/(lastLine-firstLine+1)}}blockAt(height,doc,top,offset){let{firstLine:firstLine,lastLine:lastLine,lineHeight:lineHeight}=this.lines(doc,offset),line=Math.max(0,Math.min(lastLine-firstLine,Math.floor((height-top)/lineHeight))),{from:from,length:length}=doc.line(firstLine+line);return new BlockInfo(from,length,top+lineHeight*line,lineHeight,exports.BlockType.Text)}lineAt(value,type,doc,top,offset){if(type==QueryType.ByHeight)return this.blockAt(value,doc,top,offset);if(type==QueryType.ByPosNoHeight){let{from:from,to:to}=doc.lineAt(value);return new BlockInfo(from,to-from,0,0,exports.BlockType.Text)}let{firstLine:firstLine,lineHeight:lineHeight}=this.lines(doc,offset),{from:from,length:length,number:number}=doc.lineAt(value);return new BlockInfo(from,length,top+lineHeight*(number-firstLine),lineHeight,exports.BlockType.Text)}forEachLine(from,to,doc,top,offset,f){let{firstLine:firstLine,lineHeight:lineHeight}=this.lines(doc,offset);for(let pos=Math.max(from,offset),end=Math.min(offset+this.length,to);pos<=end;){let line=doc.lineAt(pos);pos==from&&(top+=lineHeight*(line.number-firstLine)),f(new BlockInfo(line.from,line.length,top,lineHeight,exports.BlockType.Text)),top+=lineHeight,pos=line.to+1}}replace(from,to,nodes){let after=this.length-to;if(after>0){let last=nodes[nodes.length-1];last instanceof HeightMapGap?nodes[nodes.length-1]=new HeightMapGap(last.length+after):nodes.push(null,new HeightMapGap(after-1))}if(from>0){let first=nodes[0];first instanceof HeightMapGap?nodes[0]=new HeightMapGap(from+first.length):nodes.unshift(new HeightMapGap(from-1),null)}return HeightMap.of(nodes)}decomposeLeft(to,result){result.push(new HeightMapGap(to-1),null)}decomposeRight(from,result){result.push(null,new HeightMapGap(this.length-from-1))}updateHeight(oracle,offset=0,force=!1,measured){let end=offset+this.length;if(measured&&measured.from<=offset+this.length&&measured.more){let nodes=[],pos=Math.max(offset,measured.from),singleHeight=-1,wasChanged=oracle.heightChanged;for(measured.from>offset&&nodes.push(new HeightMapGap(measured.from-offset-1).updateHeight(oracle,offset));pos<=end&&measured.more;){let len=oracle.doc.lineAt(pos).length;nodes.length&&nodes.push(null);let height=measured.heights[measured.index++];-1==singleHeight?singleHeight=height:Math.abs(height-singleHeight)>=.001&&(singleHeight=-2);let line=new HeightMapText(len,height);line.outdated=!1,nodes.push(line),pos+=len+1}pos<=end&&nodes.push(null,new HeightMapGap(end-pos).updateHeight(oracle,pos));let result=HeightMap.of(nodes);return oracle.heightChanged=wasChanged||singleHeight<0||Math.abs(result.height-this.height)>=.001||Math.abs(singleHeight-this.lines(oracle.doc,offset).lineHeight)>=.001,result}return(force||this.outdated)&&(this.setHeight(oracle,oracle.heightForGap(offset,offset+this.length)),this.outdated=!1),this}toString(){return`gap(${this.length})`}}class HeightMapBranch extends HeightMap{constructor(left,brk,right){super(left.length+brk+right.length,left.height+right.height,brk|(left.outdated||right.outdated?2:0)),this.left=left,this.right=right,this.size=left.size+right.size}get break(){return 1&this.flags}blockAt(height,doc,top,offset){let mid=top+this.left.height;return height<mid?this.left.blockAt(height,doc,top,offset):this.right.blockAt(height,doc,mid,offset+this.left.length+this.break)}lineAt(value,type,doc,top,offset){let rightTop=top+this.left.height,rightOffset=offset+this.left.length+this.break,left=type==QueryType.ByHeight?value<rightTop:value<rightOffset,base=left?this.left.lineAt(value,type,doc,top,offset):this.right.lineAt(value,type,doc,rightTop,rightOffset);if(this.break||(left?base.to<rightOffset:base.from>rightOffset))return base;let subQuery=type==QueryType.ByPosNoHeight?QueryType.ByPosNoHeight:QueryType.ByPos;return left?base.join(this.right.lineAt(rightOffset,subQuery,doc,rightTop,rightOffset)):this.left.lineAt(rightOffset,subQuery,doc,top,offset).join(base)}forEachLine(from,to,doc,top,offset,f){let rightTop=top+this.left.height,rightOffset=offset+this.left.length+this.break;if(this.break)from<rightOffset&&this.left.forEachLine(from,to,doc,top,offset,f),to>=rightOffset&&this.right.forEachLine(from,to,doc,rightTop,rightOffset,f);else{let mid=this.lineAt(rightOffset,QueryType.ByPos,doc,top,offset);from<mid.from&&this.left.forEachLine(from,mid.from-1,doc,top,offset,f),mid.to>=from&&mid.from<=to&&f(mid),to>mid.to&&this.right.forEachLine(mid.to+1,to,doc,rightTop,rightOffset,f)}}replace(from,to,nodes){let rightStart=this.left.length+this.break;if(to<rightStart)return this.balanced(this.left.replace(from,to,nodes),this.right);if(from>this.left.length)return this.balanced(this.left,this.right.replace(from-rightStart,to-rightStart,nodes));let result=[];from>0&&this.decomposeLeft(from,result);let left=result.length;for(let node of nodes)result.push(node);if(from>0&&mergeGaps(result,left-1),to<this.length){let right=result.length;this.decomposeRight(to,result),mergeGaps(result,right)}return HeightMap.of(result)}decomposeLeft(to,result){let left=this.left.length;if(to<=left)return this.left.decomposeLeft(to,result);result.push(this.left),this.break&&(left++,to>=left&&result.push(null)),to>left&&this.right.decomposeLeft(to-left,result)}decomposeRight(from,result){let left=this.left.length,right=left+this.break;if(from>=right)return this.right.decomposeRight(from-right,result);from<left&&this.left.decomposeRight(from,result),this.break&&from<right&&result.push(null),result.push(this.right)}balanced(left,right){return left.size>2*right.size||right.size>2*left.size?HeightMap.of(this.break?[left,null,right]:[left,right]):(this.left=left,this.right=right,this.height=left.height+right.height,this.outdated=left.outdated||right.outdated,this.size=left.size+right.size,this.length=left.length+this.break+right.length,this)}updateHeight(oracle,offset=0,force=!1,measured){let{left:left,right:right}=this,rightStart=offset+left.length+this.break,rebalance=null;return measured&&measured.from<=offset+left.length&&measured.more?rebalance=left=left.updateHeight(oracle,offset,force,measured):left.updateHeight(oracle,offset,force),measured&&measured.from<=rightStart+right.length&&measured.more?rebalance=right=right.updateHeight(oracle,rightStart,force,measured):right.updateHeight(oracle,rightStart,force),rebalance?this.balanced(left,right):(this.height=this.left.height+this.right.height,this.outdated=!1,this)}toString(){return this.left+(this.break?" ":"-")+this.right}}function mergeGaps(nodes,around){let before,after;null==nodes[around]&&(before=nodes[around-1])instanceof HeightMapGap&&(after=nodes[around+1])instanceof HeightMapGap&&nodes.splice(around-1,3,new HeightMapGap(before.length+1+after.length))}class NodeBuilder{constructor(pos,oracle){this.pos=pos,this.oracle=oracle,this.nodes=[],this.lineStart=-1,this.lineEnd=-1,this.covering=null,this.writtenTo=pos}get isCovered(){return this.covering&&this.nodes[this.nodes.length-1]==this.covering}span(_from,to){if(this.lineStart>-1){let end=Math.min(to,this.lineEnd),last=this.nodes[this.nodes.length-1];last instanceof HeightMapText?last.length+=end-this.pos:(end>this.pos||!this.isCovered)&&this.nodes.push(new HeightMapText(end-this.pos,-1)),this.writtenTo=end,to>end&&(this.nodes.push(null),this.writtenTo++,this.lineStart=-1)}this.pos=to}point(from,to,deco){if(from<to||deco.heightRelevant){let height=deco.widget?deco.widget.estimatedHeight:0;height<0&&(height=this.oracle.lineHeight);let len=to-from;deco.block?this.addBlock(new HeightMapBlock(len,height,deco.type)):(len||height>=5)&&this.addLineDeco(height,len)}else to>from&&this.span(from,to);this.lineEnd>-1&&this.lineEnd<this.pos&&(this.lineEnd=this.oracle.doc.lineAt(this.pos).to)}enterLine(){if(this.lineStart>-1)return;let{from:from,to:to}=this.oracle.doc.lineAt(this.pos);this.lineStart=from,this.lineEnd=to,this.writtenTo<from&&((this.writtenTo<from-1||null==this.nodes[this.nodes.length-1])&&this.nodes.push(this.blankContent(this.writtenTo,from-1)),this.nodes.push(null)),this.pos>from&&this.nodes.push(new HeightMapText(this.pos-from,-1)),this.writtenTo=this.pos}blankContent(from,to){let gap=new HeightMapGap(to-from);return this.oracle.doc.lineAt(from).to==to&&(gap.flags|=4),gap}ensureLine(){this.enterLine();let last=this.nodes.length?this.nodes[this.nodes.length-1]:null;if(last instanceof HeightMapText)return last;let line=new HeightMapText(0,-1);return this.nodes.push(line),line}addBlock(block){this.enterLine(),block.type!=exports.BlockType.WidgetAfter||this.isCovered||this.ensureLine(),this.nodes.push(block),this.writtenTo=this.pos=this.pos+block.length,block.type!=exports.BlockType.WidgetBefore&&(this.covering=block)}addLineDeco(height,length){let line=this.ensureLine();line.length+=length,line.collapsed+=length,line.widgetHeight=Math.max(line.widgetHeight,height),this.writtenTo=this.pos=this.pos+length}finish(from){let last=0==this.nodes.length?null:this.nodes[this.nodes.length-1];!(this.lineStart>-1)||last instanceof HeightMapText||this.isCovered?(this.writtenTo<this.pos||null==last)&&this.nodes.push(this.blankContent(this.writtenTo,this.pos)):this.nodes.push(new HeightMapText(0,-1));let pos=from;for(let node of this.nodes)node instanceof HeightMapText&&node.updateHeight(this.oracle,pos),pos+=node?node.length:1;return this.nodes}static build(oracle,decorations,from,to){let builder=new NodeBuilder(from,oracle);return state.RangeSet.spans(decorations,from,to,builder,0),builder.finish(from)}}class DecorationComparator{constructor(){this.changes=[]}compareRange(){}comparePoint(from,to,a,b){(from<to||a&&a.heightRelevant||b&&b.heightRelevant)&&addRange(from,to,this.changes,5)}}function visiblePixelRange(dom,paddingTop){let rect=dom.getBoundingClientRect(),doc=dom.ownerDocument,win=doc.defaultView||window,left=Math.max(0,rect.left),right=Math.min(win.innerWidth,rect.right),top=Math.max(0,rect.top),bottom=Math.min(win.innerHeight,rect.bottom);for(let parent=dom.parentNode;parent&&parent!=doc.body;)if(1==parent.nodeType){let elt=parent,style=window.getComputedStyle(elt);if((elt.scrollHeight>elt.clientHeight||elt.scrollWidth>elt.clientWidth)&&"visible"!=style.overflow){let parentRect=elt.getBoundingClientRect();left=Math.max(left,parentRect.left),right=Math.min(right,parentRect.right),top=Math.max(top,parentRect.top),bottom=parent==dom.parentNode?parentRect.bottom:Math.min(bottom,parentRect.bottom)}parent="absolute"==style.position||"fixed"==style.position?elt.offsetParent:elt.parentNode}else{if(11!=parent.nodeType)break;parent=parent.host}return{left:left-rect.left,right:Math.max(left,right)-rect.left,top:top-(rect.top+paddingTop),bottom:Math.max(top,bottom)-(rect.top+paddingTop)}}function fullPixelRange(dom,paddingTop){let rect=dom.getBoundingClientRect();return{left:0,right:rect.right-rect.left,top:paddingTop,bottom:rect.bottom-(rect.top+paddingTop)}}class LineGap{constructor(from,to,size){this.from=from,this.to=to,this.size=size}static same(a,b){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++){let gA=a[i],gB=b[i];if(gA.from!=gB.from||gA.to!=gB.to||gA.size!=gB.size)return!1}return!0}draw(wrapping){return Decoration.replace({widget:new LineGapWidget(this.size,wrapping)}).range(this.from,this.to)}}class LineGapWidget extends WidgetType{constructor(size,vertical){super(),this.size=size,this.vertical=vertical}eq(other){return other.size==this.size&&other.vertical==this.vertical}toDOM(){let elt=document.createElement("div");return this.vertical?elt.style.height=this.size+"px":(elt.style.width=this.size+"px",elt.style.height="2px",elt.style.display="inline-block"),elt}get estimatedHeight(){return this.vertical?this.size:-1}}class ViewState{constructor(state$1){this.state=state$1,this.pixelViewport={left:0,right:window.innerWidth,top:0,bottom:0},this.inView=!0,this.paddingTop=0,this.paddingBottom=0,this.contentDOMWidth=0,this.contentDOMHeight=0,this.editorHeight=0,this.editorWidth=0,this.scaler=IdScaler,this.scrollTarget=null,this.printing=!1,this.mustMeasureContent=!0,this.defaultTextDirection=exports.Direction.LTR,this.visibleRanges=[],this.mustEnforceCursorAssoc=!1;let guessWrapping=state$1.facet(contentAttributes).some((v=>"function"!=typeof v&&"cm-lineWrapping"==v.class));this.heightOracle=new HeightOracle(guessWrapping),this.stateDeco=state$1.facet(decorations).filter((d=>"function"!=typeof d)),this.heightMap=HeightMap.empty().applyChanges(this.stateDeco,state.Text.empty,this.heightOracle.setDoc(state$1.doc),[new ChangedRange(0,0,0,state$1.doc.length)]),this.viewport=this.getViewport(0,null),this.updateViewportLines(),this.updateForViewport(),this.lineGaps=this.ensureLineGaps([]),this.lineGapDeco=Decoration.set(this.lineGaps.map((gap=>gap.draw(!1)))),this.computeVisibleRanges()}updateForViewport(){let viewports=[this.viewport],{main:main}=this.state.selection;for(let i=0;i<=1;i++){let pos=i?main.head:main.anchor;if(!viewports.some((({from:from,to:to})=>pos>=from&&pos<=to))){let{from:from,to:to}=this.lineBlockAt(pos);viewports.push(new Viewport(from,to))}}this.viewports=viewports.sort(((a,b)=>a.from-b.from)),this.scaler=this.heightMap.height<=7e6?IdScaler:new BigScaler(this.heightOracle.doc,this.heightMap,this.viewports)}updateViewportLines(){this.viewportLines=[],this.heightMap.forEachLine(this.viewport.from,this.viewport.to,this.state.doc,0,0,(block=>{this.viewportLines.push(1==this.scaler.scale?block:scaleBlock(block,this.scaler))}))}update(update,scrollTarget=null){this.state=update.state;let prevDeco=this.stateDeco;this.stateDeco=this.state.facet(decorations).filter((d=>"function"!=typeof d));let contentChanges=update.changedRanges,heightChanges=ChangedRange.extendWithRanges(contentChanges,function(a,b,diff){let comp=new DecorationComparator;return state.RangeSet.compare(a,b,diff,comp,0),comp.changes}(prevDeco,this.stateDeco,update?update.changes:state.ChangeSet.empty(this.state.doc.length))),prevHeight=this.heightMap.height;this.heightMap=this.heightMap.applyChanges(this.stateDeco,update.startState.doc,this.heightOracle.setDoc(this.state.doc),heightChanges),this.heightMap.height!=prevHeight&&(update.flags|=2);let viewport=heightChanges.length?this.mapViewport(this.viewport,update.changes):this.viewport;(scrollTarget&&(scrollTarget.range.head<viewport.from||scrollTarget.range.head>viewport.to)||!this.viewportIsAppropriate(viewport))&&(viewport=this.getViewport(0,scrollTarget));let updateLines=!update.changes.empty||2&update.flags||viewport.from!=this.viewport.from||viewport.to!=this.viewport.to;this.viewport=viewport,this.updateForViewport(),updateLines&&this.updateViewportLines(),(this.lineGaps.length||this.viewport.to-this.viewport.from>4e3)&&this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps,update.changes))),update.flags|=this.computeVisibleRanges(),scrollTarget&&(this.scrollTarget=scrollTarget),!this.mustEnforceCursorAssoc&&update.selectionSet&&update.view.lineWrapping&&update.state.selection.main.empty&&update.state.selection.main.assoc&&!update.state.facet(nativeSelectionHidden)&&(this.mustEnforceCursorAssoc=!0)}measure(view){let dom=view.contentDOM,style=window.getComputedStyle(dom),oracle=this.heightOracle,whiteSpace=style.whiteSpace;this.defaultTextDirection="rtl"==style.direction?exports.Direction.RTL:exports.Direction.LTR;let refresh=this.heightOracle.mustRefreshForWrapping(whiteSpace),measureContent=refresh||this.mustMeasureContent||this.contentDOMHeight!=dom.clientHeight;this.contentDOMHeight=dom.clientHeight,this.mustMeasureContent=!1;let result=0,bias=0,paddingTop=parseInt(style.paddingTop)||0,paddingBottom=parseInt(style.paddingBottom)||0;this.paddingTop==paddingTop&&this.paddingBottom==paddingBottom||(this.paddingTop=paddingTop,this.paddingBottom=paddingBottom,result|=10),this.editorWidth!=view.scrollDOM.clientWidth&&(oracle.lineWrapping&&(measureContent=!0),this.editorWidth=view.scrollDOM.clientWidth,result|=8);let pixelViewport=(this.printing?fullPixelRange:visiblePixelRange)(dom,this.paddingTop),dTop=pixelViewport.top-this.pixelViewport.top,dBottom=pixelViewport.bottom-this.pixelViewport.bottom;this.pixelViewport=pixelViewport;let inView=this.pixelViewport.bottom>this.pixelViewport.top&&this.pixelViewport.right>this.pixelViewport.left;if(inView!=this.inView&&(this.inView=inView,inView&&(measureContent=!0)),!this.inView&&!this.scrollTarget)return 0;let contentWidth=dom.clientWidth;if(this.contentDOMWidth==contentWidth&&this.editorHeight==view.scrollDOM.clientHeight||(this.contentDOMWidth=contentWidth,this.editorHeight=view.scrollDOM.clientHeight,result|=8),measureContent){let lineHeights=view.docView.measureVisibleLineHeights(this.viewport);if(oracle.mustRefreshForHeights(lineHeights)&&(refresh=!0),refresh||oracle.lineWrapping&&Math.abs(contentWidth-this.contentDOMWidth)>oracle.charWidth){let{lineHeight:lineHeight,charWidth:charWidth}=view.docView.measureTextSize();refresh=lineHeight>0&&oracle.refresh(whiteSpace,lineHeight,charWidth,contentWidth/charWidth,lineHeights),refresh&&(view.docView.minWidth=0,result|=8)}dTop>0&&dBottom>0?bias=Math.max(dTop,dBottom):dTop<0&&dBottom<0&&(bias=Math.min(dTop,dBottom)),oracle.heightChanged=!1;for(let vp of this.viewports){let heights=vp.from==this.viewport.from?lineHeights:view.docView.measureVisibleLineHeights(vp);this.heightMap=(refresh?HeightMap.empty().applyChanges(this.stateDeco,state.Text.empty,this.heightOracle,[new ChangedRange(0,0,0,view.state.doc.length)]):this.heightMap).updateHeight(oracle,0,refresh,new MeasuredHeights(vp.from,heights))}oracle.heightChanged&&(result|=2)}let viewportChange=!this.viewportIsAppropriate(this.viewport,bias)||this.scrollTarget&&(this.scrollTarget.range.head<this.viewport.from||this.scrollTarget.range.head>this.viewport.to);return viewportChange&&(this.viewport=this.getViewport(bias,this.scrollTarget)),this.updateForViewport(),(2&result||viewportChange)&&this.updateViewportLines(),(this.lineGaps.length||this.viewport.to-this.viewport.from>4e3)&&this.updateLineGaps(this.ensureLineGaps(refresh?[]:this.lineGaps,view)),result|=this.computeVisibleRanges(),this.mustEnforceCursorAssoc&&(this.mustEnforceCursorAssoc=!1,view.docView.enforceCursorAssoc()),result}get visibleTop(){return this.scaler.fromDOM(this.pixelViewport.top)}get visibleBottom(){return this.scaler.fromDOM(this.pixelViewport.bottom)}getViewport(bias,scrollTarget){let marginTop=.5-Math.max(-.5,Math.min(.5,bias/1e3/2)),map=this.heightMap,doc=this.state.doc,{visibleTop:visibleTop,visibleBottom:visibleBottom}=this,viewport=new Viewport(map.lineAt(visibleTop-1e3*marginTop,QueryType.ByHeight,doc,0,0).from,map.lineAt(visibleBottom+1e3*(1-marginTop),QueryType.ByHeight,doc,0,0).to);if(scrollTarget){let{head:head}=scrollTarget.range;if(head<viewport.from||head>viewport.to){let topPos,viewHeight=Math.min(this.editorHeight,this.pixelViewport.bottom-this.pixelViewport.top),block=map.lineAt(head,QueryType.ByPos,doc,0,0);topPos="center"==scrollTarget.y?(block.top+block.bottom)/2-viewHeight/2:"start"==scrollTarget.y||"nearest"==scrollTarget.y&&head<viewport.from?block.top:block.bottom-viewHeight,viewport=new Viewport(map.lineAt(topPos-500,QueryType.ByHeight,doc,0,0).from,map.lineAt(topPos+viewHeight+500,QueryType.ByHeight,doc,0,0).to)}}return viewport}mapViewport(viewport,changes){let from=changes.mapPos(viewport.from,-1),to=changes.mapPos(viewport.to,1);return new Viewport(this.heightMap.lineAt(from,QueryType.ByPos,this.state.doc,0,0).from,this.heightMap.lineAt(to,QueryType.ByPos,this.state.doc,0,0).to)}viewportIsAppropriate({from:from,to:to},bias=0){if(!this.inView)return!0;let{top:top}=this.heightMap.lineAt(from,QueryType.ByPos,this.state.doc,0,0),{bottom:bottom}=this.heightMap.lineAt(to,QueryType.ByPos,this.state.doc,0,0),{visibleTop:visibleTop,visibleBottom:visibleBottom}=this;return(0==from||top<=visibleTop-Math.max(10,Math.min(-bias,250)))&&(to==this.state.doc.length||bottom>=visibleBottom+Math.max(10,Math.min(bias,250)))&&top>visibleTop-2e3&&bottom<visibleBottom+2e3}mapLineGaps(gaps,changes){if(!gaps.length||changes.empty)return gaps;let mapped=[];for(let gap of gaps)changes.touchesRange(gap.from,gap.to)||mapped.push(new LineGap(changes.mapPos(gap.from),changes.mapPos(gap.to),gap.size));return mapped}ensureLineGaps(current,mayMeasure){let wrapping=this.heightOracle.lineWrapping,margin=wrapping?1e4:2e3,halfMargin=margin>>1,doubleMargin=margin<<1;if(this.defaultTextDirection!=exports.Direction.LTR&&!wrapping)return[];let gaps=[],addGap=(from,to,line,structure)=>{if(to-from<halfMargin)return;let sel=this.state.selection.main,avoid=[sel.from];sel.empty||avoid.push(sel.to);for(let pos of avoid)if(pos>from&&pos<to)return addGap(from,pos-10,line,structure),void addGap(pos+10,to,line,structure);let gap=function(array,f){for(let val of array)if(f(val))return val;return}(current,(gap=>gap.from>=line.from&&gap.to<=line.to&&Math.abs(gap.from-from)<halfMargin&&Math.abs(gap.to-to)<halfMargin&&!avoid.some((pos=>gap.from<pos&&gap.to>pos))));if(!gap){if(to<line.to&&mayMeasure&&wrapping&&mayMeasure.visibleRanges.some((r=>r.from<=to&&r.to>=to))){let lineStart=mayMeasure.moveToLineBoundary(state.EditorSelection.cursor(to),!1,!0).head;lineStart>from&&(to=lineStart)}gap=new LineGap(from,to,this.gapSize(line,from,to,structure))}gaps.push(gap)};for(let line of this.viewportLines){if(line.length<doubleMargin)continue;let structure=lineStructure(line.from,line.to,this.stateDeco);if(structure.total<doubleMargin)continue;let viewFrom,viewTo,target=this.scrollTarget?this.scrollTarget.range.head:null;if(wrapping){let top,bot,marginHeight=margin/this.heightOracle.lineLength*this.heightOracle.lineHeight;if(null!=target){let targetFrac=findFraction(structure,target),spaceFrac=((this.visibleBottom-this.visibleTop)/2+marginHeight)/line.height;top=targetFrac-spaceFrac,bot=targetFrac+spaceFrac}else top=(this.visibleTop-line.top-marginHeight)/line.height,bot=(this.visibleBottom-line.top+marginHeight)/line.height;viewFrom=findPosition(structure,top),viewTo=findPosition(structure,bot)}else{let left,right,totalWidth=structure.total*this.heightOracle.charWidth,marginWidth=margin*this.heightOracle.charWidth;if(null!=target){let targetFrac=findFraction(structure,target),spaceFrac=((this.pixelViewport.right-this.pixelViewport.left)/2+marginWidth)/totalWidth;left=targetFrac-spaceFrac,right=targetFrac+spaceFrac}else left=(this.pixelViewport.left-marginWidth)/totalWidth,right=(this.pixelViewport.right+marginWidth)/totalWidth;viewFrom=findPosition(structure,left),viewTo=findPosition(structure,right)}viewFrom>line.from&&addGap(line.from,viewFrom,line,structure),viewTo<line.to&&addGap(viewTo,line.to,line,structure)}return gaps}gapSize(line,from,to,structure){let fraction=findFraction(structure,to)-findFraction(structure,from);return this.heightOracle.lineWrapping?line.height*fraction:structure.total*this.heightOracle.charWidth*fraction}updateLineGaps(gaps){LineGap.same(gaps,this.lineGaps)||(this.lineGaps=gaps,this.lineGapDeco=Decoration.set(gaps.map((gap=>gap.draw(this.heightOracle.lineWrapping)))))}computeVisibleRanges(){let deco=this.stateDeco;this.lineGaps.length&&(deco=deco.concat(this.lineGapDeco));let ranges=[];state.RangeSet.spans(deco,this.viewport.from,this.viewport.to,{span(from,to){ranges.push({from:from,to:to})},point(){}},20);let changed=ranges.length!=this.visibleRanges.length||this.visibleRanges.some(((r,i)=>r.from!=ranges[i].from||r.to!=ranges[i].to));return this.visibleRanges=ranges,changed?4:0}lineBlockAt(pos){return pos>=this.viewport.from&&pos<=this.viewport.to&&this.viewportLines.find((b=>b.from<=pos&&b.to>=pos))||scaleBlock(this.heightMap.lineAt(pos,QueryType.ByPos,this.state.doc,0,0),this.scaler)}lineBlockAtHeight(height){return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height),QueryType.ByHeight,this.state.doc,0,0),this.scaler)}elementAtHeight(height){return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height),this.state.doc,0,0),this.scaler)}get docHeight(){return this.scaler.toDOM(this.heightMap.height)}get contentHeight(){return this.docHeight+this.paddingTop+this.paddingBottom}}class Viewport{constructor(from,to){this.from=from,this.to=to}}function lineStructure(from,to,stateDeco){let ranges=[],pos=from,total=0;return state.RangeSet.spans(stateDeco,from,to,{span(){},point(from,to){from>pos&&(ranges.push({from:pos,to:from}),total+=from-pos),pos=to}},20),pos<to&&(ranges.push({from:pos,to:to}),total+=to-pos),{total:total,ranges:ranges}}function findPosition({total:total,ranges:ranges},ratio){if(ratio<=0)return ranges[0].from;if(ratio>=1)return ranges[ranges.length-1].to;let dist=Math.floor(total*ratio);for(let i=0;;i++){let{from:from,to:to}=ranges[i],size=to-from;if(dist<=size)return from+dist;dist-=size}}function findFraction(structure,pos){let counted=0;for(let{from:from,to:to}of structure.ranges){if(pos<=to){counted+=pos-from;break}counted+=to-from}return counted/structure.total}const IdScaler={toDOM:n=>n,fromDOM:n=>n,scale:1};class BigScaler{constructor(doc,heightMap,viewports){let vpHeight=0,base=0,domBase=0;this.viewports=viewports.map((({from:from,to:to})=>{let top=heightMap.lineAt(from,QueryType.ByPos,doc,0,0).top,bottom=heightMap.lineAt(to,QueryType.ByPos,doc,0,0).bottom;return vpHeight+=bottom-top,{from:from,to:to,top:top,bottom:bottom,domTop:0,domBottom:0}})),this.scale=(7e6-vpHeight)/(heightMap.height-vpHeight);for(let obj of this.viewports)obj.domTop=domBase+(obj.top-base)*this.scale,domBase=obj.domBottom=obj.domTop+(obj.bottom-obj.top),base=obj.bottom}toDOM(n){for(let i=0,base=0,domBase=0;;i++){let vp=i<this.viewports.length?this.viewports[i]:null;if(!vp||n<vp.top)return domBase+(n-base)*this.scale;if(n<=vp.bottom)return vp.domTop+(n-vp.top);base=vp.bottom,domBase=vp.domBottom}}fromDOM(n){for(let i=0,base=0,domBase=0;;i++){let vp=i<this.viewports.length?this.viewports[i]:null;if(!vp||n<vp.domTop)return base+(n-domBase)/this.scale;if(n<=vp.domBottom)return vp.top+(n-vp.domTop);base=vp.bottom,domBase=vp.domBottom}}}function scaleBlock(block,scaler){if(1==scaler.scale)return block;let bTop=scaler.toDOM(block.top),bBottom=scaler.toDOM(block.bottom);return new BlockInfo(block.from,block.length,bTop,bBottom-bTop,Array.isArray(block.type)?block.type.map((b=>scaleBlock(b,scaler))):block.type)}const theme=state.Facet.define({combine:strs=>strs.join(" ")}),darkTheme=state.Facet.define({combine:values=>values.indexOf(!0)>-1}),baseThemeID=styleMod.StyleModule.newName(),baseLightID=styleMod.StyleModule.newName(),baseDarkID=styleMod.StyleModule.newName(),lightDarkIDs={"&light":"."+baseLightID,"&dark":"."+baseDarkID};function buildTheme(main,spec,scopes){return new styleMod.StyleModule(spec,{finish:sel=>/&/.test(sel)?sel.replace(/&\w*/,(m=>{if("&"==m)return main;if(!scopes||!scopes[m])throw new RangeError(`Unsupported selector: ${m}`);return scopes[m]})):main+" "+sel})}const baseTheme$1=buildTheme("."+baseThemeID,{"&":{position:"relative !important",boxSizing:"border-box","&.cm-focused":{outline:"1px dotted #212121"},display:"flex !important",flexDirection:"column"},".cm-scroller":{display:"flex !important",alignItems:"flex-start !important",fontFamily:"monospace",lineHeight:1.4,height:"100%",overflowX:"auto",position:"relative",zIndex:0},".cm-content":{margin:0,flexGrow:2,flexShrink:0,display:"block",whiteSpace:"pre",wordWrap:"normal",boxSizing:"border-box",padding:"4px 0",outline:"none","&[contenteditable=true]":{WebkitUserModify:"read-write-plaintext-only"}},".cm-lineWrapping":{whiteSpace_fallback:"pre-wrap",whiteSpace:"break-spaces",wordBreak:"break-word",overflowWrap:"anywhere",flexShrink:1},"&light .cm-content":{caretColor:"black"},"&dark .cm-content":{caretColor:"white"},".cm-line":{display:"block",padding:"0 2px 0 6px"},".cm-layer":{contain:"size style","& > *":{position:"absolute"}},"&light .cm-selectionBackground":{background:"#d9d9d9"},"&dark .cm-selectionBackground":{background:"#222"},"&light.cm-focused .cm-selectionBackground":{background:"#d7d4f0"},"&dark.cm-focused .cm-selectionBackground":{background:"#233"},".cm-cursorLayer":{pointerEvents:"none"},"&.cm-focused .cm-cursorLayer":{animation:"steps(1) cm-blink 1.2s infinite"},"@keyframes cm-blink":{"0%":{},"50%":{opacity:0},"100%":{}},"@keyframes cm-blink2":{"0%":{},"50%":{opacity:0},"100%":{}},".cm-cursor, .cm-dropCursor":{borderLeft:"1.2px solid black",marginLeft:"-0.6px",pointerEvents:"none"},".cm-cursor":{display:"none"},"&dark .cm-cursor":{borderLeftColor:"#444"},"&.cm-focused .cm-cursor":{display:"block"},"&light .cm-activeLine":{backgroundColor:"#cceeff44"},"&dark .cm-activeLine":{backgroundColor:"#99eeff33"},"&light .cm-specialChar":{color:"red"},"&dark .cm-specialChar":{color:"#f78"},".cm-gutters":{flexShrink:0,display:"flex",height:"100%",boxSizing:"border-box",left:0,zIndex:200},"&light .cm-gutters":{backgroundColor:"#f5f5f5",color:"#6c6c6c",borderRight:"1px solid #ddd"},"&dark .cm-gutters":{backgroundColor:"#333338",color:"#ccc"},".cm-gutter":{display:"flex !important",flexDirection:"column",flexShrink:0,boxSizing:"border-box",minHeight:"100%",overflow:"hidden"},".cm-gutterElement":{boxSizing:"border-box"},".cm-lineNumbers .cm-gutterElement":{padding:"0 3px 0 5px",minWidth:"20px",textAlign:"right",whiteSpace:"nowrap"},"&light .cm-activeLineGutter":{backgroundColor:"#e2f2ff"},"&dark .cm-activeLineGutter":{backgroundColor:"#222227"},".cm-panels":{boxSizing:"border-box",position:"sticky",left:0,right:0},"&light .cm-panels":{backgroundColor:"#f5f5f5",color:"black"},"&light .cm-panels-top":{borderBottom:"1px solid #ddd"},"&light .cm-panels-bottom":{borderTop:"1px solid #ddd"},"&dark .cm-panels":{backgroundColor:"#333338",color:"white"},".cm-tab":{display:"inline-block",overflow:"hidden",verticalAlign:"bottom"},".cm-widgetBuffer":{verticalAlign:"text-top",height:"1em",width:0,display:"inline"},".cm-placeholder":{color:"#888",display:"inline-block",verticalAlign:"top"},".cm-highlightSpace:before":{content:"attr(data-display)",position:"absolute",pointerEvents:"none",color:"#888"},".cm-highlightTab":{backgroundImage:'url(\'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>\')',backgroundSize:"auto 100%",backgroundPosition:"right 90%",backgroundRepeat:"no-repeat"},".cm-trailingSpace":{backgroundColor:"#ff332255"},".cm-button":{verticalAlign:"middle",color:"inherit",fontSize:"70%",padding:".2em 1em",borderRadius:"1px"},"&light .cm-button":{backgroundImage:"linear-gradient(#eff1f5, #d9d9df)",border:"1px solid #888","&:active":{backgroundImage:"linear-gradient(#b4b4b4, #d0d3d6)"}},"&dark .cm-button":{backgroundImage:"linear-gradient(#393939, #111)",border:"1px solid #888","&:active":{backgroundImage:"linear-gradient(#111, #333)"}},".cm-textfield":{verticalAlign:"middle",color:"inherit",fontSize:"70%",border:"1px solid silver",padding:".2em .5em"},"&light .cm-textfield":{backgroundColor:"white"},"&dark .cm-textfield":{border:"1px solid #555",backgroundColor:"inherit"}},lightDarkIDs);class DOMChange{constructor(view,start,end,typeOver){this.typeOver=typeOver,this.bounds=null,this.text="";let{impreciseHead:iHead,impreciseAnchor:iAnchor}=view.docView;if(view.state.readOnly&&start>-1)this.newSel=null;else if(start>-1&&(this.bounds=view.docView.domBoundsAround(start,end,0))){let selPoints=iHead||iAnchor?[]:function(view){let result=[];if(view.root.activeElement!=view.contentDOM)return result;let{anchorNode:anchorNode,anchorOffset:anchorOffset,focusNode:focusNode,focusOffset:focusOffset}=view.observer.selectionRange;anchorNode&&(result.push(new DOMPoint(anchorNode,anchorOffset)),focusNode==anchorNode&&focusOffset==anchorOffset||result.push(new DOMPoint(focusNode,focusOffset)));return result}(view),reader=new DOMReader(selPoints,view.state);reader.readRange(this.bounds.startDOM,this.bounds.endDOM),this.text=reader.text,this.newSel=function(points,base){if(0==points.length)return null;let anchor=points[0].pos,head=2==points.length?points[1].pos:anchor;return anchor>-1&&head>-1?state.EditorSelection.single(anchor+base,head+base):null}(selPoints,this.bounds.from)}else{let domSel=view.observer.selectionRange,head=iHead&&iHead.node==domSel.focusNode&&iHead.offset==domSel.focusOffset||!contains(view.contentDOM,domSel.focusNode)?view.state.selection.main.head:view.docView.posFromDOM(domSel.focusNode,domSel.focusOffset),anchor=iAnchor&&iAnchor.node==domSel.anchorNode&&iAnchor.offset==domSel.anchorOffset||!contains(view.contentDOM,domSel.anchorNode)?view.state.selection.main.anchor:view.docView.posFromDOM(domSel.anchorNode,domSel.anchorOffset);this.newSel=state.EditorSelection.single(anchor,head)}}}function applyDOMChange(view,domChange){let change,{newSel:newSel}=domChange,sel=view.state.selection.main;if(domChange.bounds){let{from:from,to:to}=domChange.bounds,preferredPos=sel.from,preferredSide=null;(8===view.inputState.lastKeyCode&&view.inputState.lastKeyTime>Date.now()-100||browser.android&&domChange.text.length<to-from)&&(preferredPos=sel.to,preferredSide="end");let diff=function(a,b,preferredPos,preferredSide){let minLen=Math.min(a.length,b.length),from=0;for(;from<minLen&&a.charCodeAt(from)==b.charCodeAt(from);)from++;if(from==minLen&&a.length==b.length)return null;let toA=a.length,toB=b.length;for(;toA>0&&toB>0&&a.charCodeAt(toA-1)==b.charCodeAt(toB-1);)toA--,toB--;if("end"==preferredSide){preferredPos-=toA+Math.max(0,from-Math.min(toA,toB))-from}if(toA<from&&a.length<b.length){from-=preferredPos<=from&&preferredPos>=toA?from-preferredPos:0,toB=from+(toB-toA),toA=from}else if(toB<from){from-=preferredPos<=from&&preferredPos>=toB?from-preferredPos:0,toA=from+(toA-toB),toB=from}return{from:from,toA:toA,toB:toB}}(view.state.doc.sliceString(from,to,""),domChange.text,preferredPos-from,preferredSide);diff&&(browser.chrome&&13==view.inputState.lastKeyCode&&diff.toB==diff.from+2&&""==domChange.text.slice(diff.from,diff.toB)&&diff.toB--,change={from:from+diff.from,to:from+diff.toA,insert:state.Text.of(domChange.text.slice(diff.from,diff.toB).split(""))})}else newSel&&(!view.hasFocus&&view.state.facet(editable)||newSel.main.eq(sel))&&(newSel=null);if(!change&&!newSel)return!1;if(!change&&domChange.typeOver&&!sel.empty&&newSel&&newSel.main.empty?change={from:sel.from,to:sel.to,insert:view.state.doc.slice(sel.from,sel.to)}:change&&change.from>=sel.from&&change.to<=sel.to&&(change.from!=sel.from||change.to!=sel.to)&&sel.to-sel.from-(change.to-change.from)<=4?change={from:sel.from,to:sel.to,insert:view.state.doc.slice(sel.from,change.from).append(change.insert).append(view.state.doc.slice(change.to,sel.to))}:(browser.mac||browser.android)&&change&&change.from==change.to&&change.from==sel.head-1&&/^\. ?$/.test(change.insert.toString())?(newSel&&2==change.insert.length&&(newSel=state.EditorSelection.single(newSel.main.anchor-1,newSel.main.head-1)),change={from:sel.from,to:sel.to,insert:state.Text.of([" "])}):browser.chrome&&change&&change.from==change.to&&change.from==sel.head&&"\n "==change.insert.toString()&&view.lineWrapping&&(newSel&&(newSel=state.EditorSelection.single(newSel.main.anchor-1,newSel.main.head-1)),change={from:sel.from,to:sel.to,insert:state.Text.of([" "])}),change){let startState=view.state;if(browser.ios&&view.inputState.flushIOSKey(view))return!0;if(browser.android&&(change.from==sel.from&&change.to==sel.to&&1==change.insert.length&&2==change.insert.lines&&dispatchKey(view.contentDOM,"Enter",13)||change.from==sel.from-1&&change.to==sel.to&&0==change.insert.length&&dispatchKey(view.contentDOM,"Backspace",8)||change.from==sel.from&&change.to==sel.to+1&&0==change.insert.length&&dispatchKey(view.contentDOM,"Delete",46)))return!0;let tr,text=change.insert.toString();if(view.state.facet(inputHandler).some((h=>h(view,change.from,change.to,text))))return!0;if(view.inputState.composing>=0&&view.inputState.composing++,change.from>=sel.from&&change.to<=sel.to&&change.to-change.from>=(sel.to-sel.from)/3&&(!newSel||newSel.main.empty&&newSel.main.from==change.from+change.insert.length)&&view.inputState.composing<0){let before=sel.from<change.from?startState.sliceDoc(sel.from,change.from):"",after=sel.to>change.to?startState.sliceDoc(change.to,sel.to):"";tr=startState.replaceSelection(view.state.toText(before+change.insert.sliceString(0,void 0,view.state.lineBreak)+after))}else{let changes=startState.changes(change),mainSel=newSel&&!startState.selection.main.eq(newSel.main)&&newSel.main.to<=changes.newLength?newSel.main:void 0;if(startState.selection.ranges.length>1&&view.inputState.composing>=0&&change.to<=sel.to&&change.to>=sel.to-10){let replaced=view.state.sliceDoc(change.from,change.to),compositionRange=compositionSurroundingNode(view)||view.state.doc.lineAt(sel.head),offset=sel.to-change.to,size=sel.to-sel.from;tr=startState.changeByRange((range=>{if(range.from==sel.from&&range.to==sel.to)return{changes:changes,range:mainSel||range.map(changes)};let to=range.to-offset,from=to-replaced.length;if(range.to-range.from!=size||view.state.sliceDoc(from,to)!=replaced||compositionRange&&range.to>=compositionRange.from&&range.from<=compositionRange.to)return{range:range};let rangeChanges=startState.changes({from:from,to:to,insert:change.insert}),selOff=range.to-sel.to;return{changes:rangeChanges,range:mainSel?state.EditorSelection.range(Math.max(0,mainSel.anchor+selOff),Math.max(0,mainSel.head+selOff)):range.map(rangeChanges)}}))}else tr={changes:changes,selection:mainSel&&startState.selection.replaceRange(mainSel)}}let userEvent="input.type";return view.composing&&(userEvent+=".compose",view.inputState.compositionFirstChange&&(userEvent+=".start",view.inputState.compositionFirstChange=!1)),view.dispatch(tr,{scrollIntoView:!0,userEvent:userEvent}),!0}if(newSel&&!newSel.main.eq(sel)){let scrollIntoView=!1,userEvent="select";return view.inputState.lastSelectionTime>Date.now()-50&&("select"==view.inputState.lastSelectionOrigin&&(scrollIntoView=!0),userEvent=view.inputState.lastSelectionOrigin),view.dispatch({selection:newSel,scrollIntoView:scrollIntoView,userEvent:userEvent}),!0}return!1}const observeOptions={childList:!0,characterData:!0,subtree:!0,attributes:!0,characterDataOldValue:!0},useCharData=browser.ie&&browser.ie_version<=11;class DOMObserver{constructor(view){this.view=view,this.active=!1,this.selectionRange=new DOMSelectionState,this.selectionChanged=!1,this.delayedFlush=-1,this.resizeTimeout=-1,this.queue=[],this.delayedAndroidKey=null,this.flushingAndroidKey=-1,this.lastChange=0,this.scrollTargets=[],this.intersection=null,this.resizeScroll=null,this.resizeContent=null,this.intersecting=!1,this.gapIntersection=null,this.gaps=[],this.parentCheck=-1,this.dom=view.contentDOM,this.observer=new MutationObserver((mutations=>{for(let mut of mutations)this.queue.push(mut);(browser.ie&&browser.ie_version<=11||browser.ios&&view.composing)&&mutations.some((m=>"childList"==m.type&&m.removedNodes.length||"characterData"==m.type&&m.oldValue.length>m.target.nodeValue.length))?this.flushSoon():this.flush()})),useCharData&&(this.onCharData=event=>{this.queue.push({target:event.target,type:"characterData",oldValue:event.prevValue}),this.flushSoon()}),this.onSelectionChange=this.onSelectionChange.bind(this),this.onResize=this.onResize.bind(this),this.onPrint=this.onPrint.bind(this),this.onScroll=this.onScroll.bind(this),"function"==typeof ResizeObserver&&(this.resizeScroll=new ResizeObserver((()=>{var _a;(null===(_a=this.view.docView)||void 0===_a?void 0:_a.lastUpdate)<Date.now()-75&&this.onResize()})),this.resizeScroll.observe(view.scrollDOM),this.resizeContent=new ResizeObserver((()=>this.view.requestMeasure())),this.resizeContent.observe(view.contentDOM)),this.addWindowListeners(this.win=view.win),this.start(),"function"==typeof IntersectionObserver&&(this.intersection=new IntersectionObserver((entries=>{this.parentCheck<0&&(this.parentCheck=setTimeout(this.listenForScroll.bind(this),1e3)),entries.length>0&&entries[entries.length-1].intersectionRatio>0!=this.intersecting&&(this.intersecting=!this.intersecting,this.intersecting!=this.view.inView&&this.onScrollChanged(document.createEvent("Event")))}),{}),this.intersection.observe(this.dom),this.gapIntersection=new IntersectionObserver((entries=>{entries.length>0&&entries[entries.length-1].intersectionRatio>0&&this.onScrollChanged(document.createEvent("Event"))}),{})),this.listenForScroll(),this.readSelectionRange()}onScrollChanged(e){this.view.inputState.runScrollHandlers(this.view,e),this.intersecting&&this.view.measure()}onScroll(e){this.intersecting&&this.flush(!1),this.onScrollChanged(e)}onResize(){this.resizeTimeout<0&&(this.resizeTimeout=setTimeout((()=>{this.resizeTimeout=-1,this.view.requestMeasure()}),50))}onPrint(){this.view.viewState.printing=!0,this.view.measure(),setTimeout((()=>{this.view.viewState.printing=!1,this.view.requestMeasure()}),500)}updateGaps(gaps){if(this.gapIntersection&&(gaps.length!=this.gaps.length||this.gaps.some(((g,i)=>g!=gaps[i])))){this.gapIntersection.disconnect();for(let gap of gaps)this.gapIntersection.observe(gap);this.gaps=gaps}}onSelectionChange(event){let wasChanged=this.selectionChanged;if(!this.readSelectionRange()||this.delayedAndroidKey)return;let{view:view}=this,sel=this.selectionRange;if(view.state.facet(editable)?view.root.activeElement!=this.dom:!hasSelection(view.dom,sel))return;let context=sel.anchorNode&&view.docView.nearest(sel.anchorNode);context&&context.ignoreEvent(event)?wasChanged||(this.selectionChanged=!1):(browser.ie&&browser.ie_version<=11||browser.android&&browser.chrome)&&!view.state.selection.main.empty&&sel.focusNode&&isEquivalentPosition(sel.focusNode,sel.focusOffset,sel.anchorNode,sel.anchorOffset)?this.flushSoon():this.flush(!1)}readSelectionRange(){let{view:view}=this,range=browser.safari&&11==view.root.nodeType&&function(doc){let elt=doc.activeElement;for(;elt&&elt.shadowRoot;)elt=elt.shadowRoot.activeElement;return elt}(this.dom.ownerDocument)==this.dom&&function(view){let found=null;function read(event){event.preventDefault(),event.stopImmediatePropagation(),found=event.getTargetRanges()[0]}if(view.contentDOM.addEventListener("beforeinput",read,!0),view.dom.ownerDocument.execCommand("indent"),view.contentDOM.removeEventListener("beforeinput",read,!0),!found)return null;let anchorNode=found.startContainer,anchorOffset=found.startOffset,focusNode=found.endContainer,focusOffset=found.endOffset,curAnchor=view.docView.domAtPos(view.state.selection.main.anchor);isEquivalentPosition(curAnchor.node,curAnchor.offset,focusNode,focusOffset)&&([anchorNode,anchorOffset,focusNode,focusOffset]=[focusNode,focusOffset,anchorNode,anchorOffset]);return{anchorNode:anchorNode,anchorOffset:anchorOffset,focusNode:focusNode,focusOffset:focusOffset}}(this.view)||getSelection(view.root);if(!range||this.selectionRange.eq(range))return!1;let local=hasSelection(this.dom,range);return local&&!this.selectionChanged&&view.inputState.lastFocusTime>Date.now()-200&&view.inputState.lastTouchTime<Date.now()-300&&function(doc,selection){let node=selection.focusNode,offset=selection.focusOffset;if(!node||selection.anchorNode!=node||selection.anchorOffset!=offset)return!1;for(;;)if(offset){if(1!=node.nodeType)return!1;let prev=node.childNodes[offset-1];"false"==prev.contentEditable?offset--:(node=prev,offset=maxOffset(node))}else{if(node==doc)return!0;offset=domIndex(node),node=node.parentNode}}(this.dom,range)?(this.view.inputState.lastFocusTime=0,view.docView.updateSelection(),!1):(this.selectionRange.setRange(range),local&&(this.selectionChanged=!0),!0)}setSelectionRange(anchor,head){this.selectionRange.set(anchor.node,anchor.offset,head.node,head.offset),this.selectionChanged=!1}clearSelectionRange(){this.selectionRange.set(null,0,null,0)}listenForScroll(){this.parentCheck=-1;let i=0,changed=null;for(let dom=this.dom;dom;)if(1==dom.nodeType)!changed&&i<this.scrollTargets.length&&this.scrollTargets[i]==dom?i++:changed||(changed=this.scrollTargets.slice(0,i)),changed&&changed.push(dom),dom=dom.assignedSlot||dom.parentNode;else{if(11!=dom.nodeType)break;dom=dom.host}if(i<this.scrollTargets.length&&!changed&&(changed=this.scrollTargets.slice(0,i)),changed){for(let dom of this.scrollTargets)dom.removeEventListener("scroll",this.onScroll);for(let dom of this.scrollTargets=changed)dom.addEventListener("scroll",this.onScroll)}}ignore(f){if(!this.active)return f();try{return this.stop(),f()}finally{this.start(),this.clear()}}start(){this.active||(this.observer.observe(this.dom,observeOptions),useCharData&&this.dom.addEventListener("DOMCharacterDataModified",this.onCharData),this.active=!0)}stop(){this.active&&(this.active=!1,this.observer.disconnect(),useCharData&&this.dom.removeEventListener("DOMCharacterDataModified",this.onCharData))}clear(){this.processRecords(),this.queue.length=0,this.selectionChanged=!1}delayAndroidKey(key,keyCode){var _a;if(!this.delayedAndroidKey){let flush=()=>{let key=this.delayedAndroidKey;key&&(this.clearDelayedAndroidKey(),!this.flush()&&key.force&&dispatchKey(this.dom,key.key,key.keyCode))};this.flushingAndroidKey=this.view.win.requestAnimationFrame(flush)}this.delayedAndroidKey&&"Enter"!=key||(this.delayedAndroidKey={key:key,keyCode:keyCode,force:this.lastChange<Date.now()-50||!!(null===(_a=this.delayedAndroidKey)||void 0===_a?void 0:_a.force)})}clearDelayedAndroidKey(){this.win.cancelAnimationFrame(this.flushingAndroidKey),this.delayedAndroidKey=null,this.flushingAndroidKey=-1}flushSoon(){this.delayedFlush<0&&(this.delayedFlush=this.view.win.requestAnimationFrame((()=>{this.delayedFlush=-1,this.flush()})))}forceFlush(){this.delayedFlush>=0&&(this.view.win.cancelAnimationFrame(this.delayedFlush),this.delayedFlush=-1),this.flush()}processRecords(){let records=this.queue;for(let mut of this.observer.takeRecords())records.push(mut);records.length&&(this.queue=[]);let from=-1,to=-1,typeOver=!1;for(let record of records){let range=this.readMutation(record);range&&(range.typeOver&&(typeOver=!0),-1==from?({from:from,to:to}=range):(from=Math.min(range.from,from),to=Math.max(range.to,to)))}return{from:from,to:to,typeOver:typeOver}}readChange(){let{from:from,to:to,typeOver:typeOver}=this.processRecords(),newSel=this.selectionChanged&&hasSelection(this.dom,this.selectionRange);return from<0&&!newSel?null:(from>-1&&(this.lastChange=Date.now()),this.view.inputState.lastFocusTime=0,this.selectionChanged=!1,new DOMChange(this.view,from,to,typeOver))}flush(readSelection=!0){if(this.delayedFlush>=0||this.delayedAndroidKey)return!1;readSelection&&this.readSelectionRange();let domChange=this.readChange();if(!domChange)return!1;let startState=this.view.state,handled=applyDOMChange(this.view,domChange);return this.view.state==startState&&this.view.update([]),handled}readMutation(rec){let cView=this.view.docView.nearest(rec.target);if(!cView||cView.ignoreMutation(rec))return null;if(cView.markDirty("attributes"==rec.type),"attributes"==rec.type&&(cView.dirty|=4),"childList"==rec.type){let childBefore=findChild(cView,rec.previousSibling||rec.target.previousSibling,-1),childAfter=findChild(cView,rec.nextSibling||rec.target.nextSibling,1);return{from:childBefore?cView.posAfter(childBefore):cView.posAtStart,to:childAfter?cView.posBefore(childAfter):cView.posAtEnd,typeOver:!1}}return"characterData"==rec.type?{from:cView.posAtStart,to:cView.posAtEnd,typeOver:rec.target.nodeValue==rec.oldValue}:null}setWindow(win){win!=this.win&&(this.removeWindowListeners(this.win),this.win=win,this.addWindowListeners(this.win))}addWindowListeners(win){win.addEventListener("resize",this.onResize),win.addEventListener("beforeprint",this.onPrint),win.addEventListener("scroll",this.onScroll),win.document.addEventListener("selectionchange",this.onSelectionChange)}removeWindowListeners(win){win.removeEventListener("scroll",this.onScroll),win.removeEventListener("resize",this.onResize),win.removeEventListener("beforeprint",this.onPrint),win.document.removeEventListener("selectionchange",this.onSelectionChange)}destroy(){var _a,_b,_c,_d;this.stop(),null===(_a=this.intersection)||void 0===_a||_a.disconnect(),null===(_b=this.gapIntersection)||void 0===_b||_b.disconnect(),null===(_c=this.resizeScroll)||void 0===_c||_c.disconnect(),null===(_d=this.resizeContent)||void 0===_d||_d.disconnect();for(let dom of this.scrollTargets)dom.removeEventListener("scroll",this.onScroll);this.removeWindowListeners(this.win),clearTimeout(this.parentCheck),clearTimeout(this.resizeTimeout),this.win.cancelAnimationFrame(this.delayedFlush),this.win.cancelAnimationFrame(this.flushingAndroidKey)}}function findChild(cView,dom,dir){for(;dom;){let curView=ContentView.get(dom);if(curView&&curView.parent==cView)return curView;let parent=dom.parentNode;dom=parent!=cView.dom?parent:dir>0?dom.nextSibling:dom.previousSibling}return null}class EditorView{constructor(config={}){this.plugins=[],this.pluginMap=new Map,this.editorAttrs={},this.contentAttrs={},this.bidiCache=[],this.destroyed=!1,this.updateState=2,this.measureScheduled=-1,this.measureRequests=[],this.contentDOM=document.createElement("div"),this.scrollDOM=document.createElement("div"),this.scrollDOM.tabIndex=-1,this.scrollDOM.className="cm-scroller",this.scrollDOM.appendChild(this.contentDOM),this.announceDOM=document.createElement("div"),this.announceDOM.style.cssText="position: fixed; top: -10000px",this.announceDOM.setAttribute("aria-live","polite"),this.dom=document.createElement("div"),this.dom.appendChild(this.announceDOM),this.dom.appendChild(this.scrollDOM),this._dispatch=config.dispatch||(tr=>this.update([tr])),this.dispatch=this.dispatch.bind(this),this._root=config.root||function(node){for(;node;){if(node&&(9==node.nodeType||11==node.nodeType&&node.host))return node;node=node.assignedSlot||node.parentNode}return null}(config.parent)||document,this.viewState=new ViewState(config.state||state.EditorState.create(config)),this.plugins=this.state.facet(viewPlugin).map((spec=>new PluginInstance(spec)));for(let plugin of this.plugins)plugin.update(this);this.observer=new DOMObserver(this),this.inputState=new InputState(this),this.inputState.ensureHandlers(this,this.plugins),this.docView=new DocView(this),this.mountStyles(),this.updateAttrs(),this.updateState=0,this.requestMeasure(),config.parent&&config.parent.appendChild(this.dom)}get state(){return this.viewState.state}get viewport(){return this.viewState.viewport}get visibleRanges(){return this.viewState.visibleRanges}get inView(){return this.viewState.inView}get composing(){return this.inputState.composing>0}get compositionStarted(){return this.inputState.composing>=0}get root(){return this._root}get win(){return this.dom.ownerDocument.defaultView||window}dispatch(...input){this._dispatch(1==input.length&&input[0]instanceof state.Transaction?input[0]:this.state.update(...input))}update(transactions){if(0!=this.updateState)throw new Error("Calls to EditorView.update are not allowed while an update is in progress");let update,redrawn=!1,attrsChanged=!1,state$1=this.state;for(let tr of transactions){if(tr.startState!=state$1)throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");state$1=tr.state}if(this.destroyed)return void(this.viewState.state=state$1);let pendingKey=this.observer.delayedAndroidKey,domChange=null;if(pendingKey?(this.observer.clearDelayedAndroidKey(),domChange=this.observer.readChange(),(domChange&&!this.state.doc.eq(state$1.doc)||!this.state.selection.eq(state$1.selection))&&(domChange=null)):this.observer.clear(),state$1.facet(state.EditorState.phrases)!=this.state.facet(state.EditorState.phrases))return this.setState(state$1);update=ViewUpdate.create(this,state$1,transactions);let scrollTarget=this.viewState.scrollTarget;try{this.updateState=2;for(let tr of transactions){if(scrollTarget&&(scrollTarget=scrollTarget.map(tr.changes)),tr.scrollIntoView){let{main:main}=tr.state.selection;scrollTarget=new ScrollTarget(main.empty?main:state.EditorSelection.cursor(main.head,main.head>main.anchor?-1:1))}for(let e of tr.effects)e.is(scrollIntoView)&&(scrollTarget=e.value)}this.viewState.update(update,scrollTarget),this.bidiCache=CachedOrder.update(this.bidiCache,update.changes),update.empty||(this.updatePlugins(update),this.inputState.update(update)),redrawn=this.docView.update(update),this.state.facet(styleModule)!=this.styleModules&&this.mountStyles(),attrsChanged=this.updateAttrs(),this.showAnnouncements(transactions),this.docView.updateSelection(redrawn,transactions.some((tr=>tr.isUserEvent("select.pointer"))))}finally{this.updateState=0}if(update.startState.facet(theme)!=update.state.facet(theme)&&(this.viewState.mustMeasureContent=!0),(redrawn||attrsChanged||scrollTarget||this.viewState.mustEnforceCursorAssoc||this.viewState.mustMeasureContent)&&this.requestMeasure(),!update.empty)for(let listener of this.state.facet(updateListener))listener(update);domChange&&!applyDOMChange(this,domChange)&&pendingKey.force&&dispatchKey(this.contentDOM,pendingKey.key,pendingKey.keyCode)}setState(newState){if(0!=this.updateState)throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");if(this.destroyed)return void(this.viewState.state=newState);this.updateState=2;let hadFocus=this.hasFocus;try{for(let plugin of this.plugins)plugin.destroy(this);this.viewState=new ViewState(newState),this.plugins=newState.facet(viewPlugin).map((spec=>new PluginInstance(spec))),this.pluginMap.clear();for(let plugin of this.plugins)plugin.update(this);this.docView=new DocView(this),this.inputState.ensureHandlers(this,this.plugins),this.mountStyles(),this.updateAttrs(),this.bidiCache=[]}finally{this.updateState=0}hadFocus&&this.focus(),this.requestMeasure()}updatePlugins(update){let prevSpecs=update.startState.facet(viewPlugin),specs=update.state.facet(viewPlugin);if(prevSpecs!=specs){let newPlugins=[];for(let spec of specs){let found=prevSpecs.indexOf(spec);if(found<0)newPlugins.push(new PluginInstance(spec));else{let plugin=this.plugins[found];plugin.mustUpdate=update,newPlugins.push(plugin)}}for(let plugin of this.plugins)plugin.mustUpdate!=update&&plugin.destroy(this);this.plugins=newPlugins,this.pluginMap.clear(),this.inputState.ensureHandlers(this,this.plugins)}else for(let p of this.plugins)p.mustUpdate=update;for(let i=0;i<this.plugins.length;i++)this.plugins[i].update(this)}measure(flush=!0){if(this.destroyed)return;this.measureScheduled>-1&&cancelAnimationFrame(this.measureScheduled),this.measureScheduled=0,flush&&this.observer.forceFlush();let updated=null,{scrollHeight:scrollHeight,scrollTop:scrollTop,clientHeight:clientHeight}=this.scrollDOM,refHeight=scrollTop>scrollHeight-clientHeight-4?scrollHeight:scrollTop;try{for(let i=0;;i++){this.updateState=1;let oldViewport=this.viewport,refBlock=this.viewState.lineBlockAtHeight(refHeight),changed=this.viewState.measure(this);if(!changed&&!this.measureRequests.length&&null==this.viewState.scrollTarget)break;if(i>5){console.warn(this.measureRequests.length?"Measure loop restarted more than 5 times":"Viewport failed to stabilize");break}let measuring=[];4&changed||([this.measureRequests,measuring]=[measuring,this.measureRequests]);let measured=measuring.map((m=>{try{return m.read(this)}catch(e){return logException(this.state,e),BadMeasure}})),update=ViewUpdate.create(this,this.state,[]),redrawn=!1,scrolled=!1;update.flags|=changed,updated?updated.flags|=changed:updated=update,this.updateState=2,update.empty||(this.updatePlugins(update),this.inputState.update(update),this.updateAttrs(),redrawn=this.docView.update(update));for(let i=0;i<measuring.length;i++)if(measured[i]!=BadMeasure)try{let m=measuring[i];m.write&&m.write(measured[i],this)}catch(e){logException(this.state,e)}if(this.viewState.editorHeight)if(this.viewState.scrollTarget)this.docView.scrollIntoView(this.viewState.scrollTarget),this.viewState.scrollTarget=null,scrolled=!0;else{let diff=this.viewState.lineBlockAt(refBlock.from).top-refBlock.top;(diff>1||diff<-1)&&(this.scrollDOM.scrollTop+=diff,scrolled=!0)}if(redrawn&&this.docView.updateSelection(!0),this.viewport.from==oldViewport.from&&this.viewport.to==oldViewport.to&&!scrolled&&0==this.measureRequests.length)break}}finally{this.updateState=0,this.measureScheduled=-1}if(updated&&!updated.empty)for(let listener of this.state.facet(updateListener))listener(updated)}get themeClasses(){return baseThemeID+" "+(this.state.facet(darkTheme)?baseDarkID:baseLightID)+" "+this.state.facet(theme)}updateAttrs(){let editorAttrs=attrsFromFacet(this,editorAttributes,{class:"cm-editor"+(this.hasFocus?" cm-focused ":" ")+this.themeClasses}),contentAttrs={spellcheck:"false",autocorrect:"off",autocapitalize:"off",translate:"no",contenteditable:this.state.facet(editable)?"true":"false",class:"cm-content",style:`${browser.tabSize}: ${this.state.tabSize}`,role:"textbox","aria-multiline":"true"};this.state.readOnly&&(contentAttrs["aria-readonly"]="true"),attrsFromFacet(this,contentAttributes,contentAttrs);let changed=this.observer.ignore((()=>{let changedContent=updateAttrs(this.contentDOM,this.contentAttrs,contentAttrs),changedEditor=updateAttrs(this.dom,this.editorAttrs,editorAttrs);return changedContent||changedEditor}));return this.editorAttrs=editorAttrs,this.contentAttrs=contentAttrs,changed}showAnnouncements(trs){let first=!0;for(let tr of trs)for(let effect of tr.effects)if(effect.is(EditorView.announce)){first&&(this.announceDOM.textContent=""),first=!1,this.announceDOM.appendChild(document.createElement("div")).textContent=effect.value}}mountStyles(){this.styleModules=this.state.facet(styleModule),styleMod.StyleModule.mount(this.root,this.styleModules.concat(baseTheme$1).reverse())}readMeasured(){if(2==this.updateState)throw new Error("Reading the editor layout isn't allowed during an update");0==this.updateState&&this.measureScheduled>-1&&this.measure(!1)}requestMeasure(request){if(this.measureScheduled<0&&(this.measureScheduled=this.win.requestAnimationFrame((()=>this.measure()))),request){if(this.measureRequests.indexOf(request)>-1)return;if(null!=request.key)for(let i=0;i<this.measureRequests.length;i++)if(this.measureRequests[i].key===request.key)return void(this.measureRequests[i]=request);this.measureRequests.push(request)}}plugin(plugin){let known=this.pluginMap.get(plugin);return(void 0===known||known&&known.spec!=plugin)&&this.pluginMap.set(plugin,known=this.plugins.find((p=>p.spec==plugin))||null),known&&known.update(this).value}get documentTop(){return this.contentDOM.getBoundingClientRect().top+this.viewState.paddingTop}get documentPadding(){return{top:this.viewState.paddingTop,bottom:this.viewState.paddingBottom}}elementAtHeight(height){return this.readMeasured(),this.viewState.elementAtHeight(height)}lineBlockAtHeight(height){return this.readMeasured(),this.viewState.lineBlockAtHeight(height)}get viewportLineBlocks(){return this.viewState.viewportLines}lineBlockAt(pos){return this.viewState.lineBlockAt(pos)}get contentHeight(){return this.viewState.contentHeight}moveByChar(start,forward,by){return skipAtoms(this,start,moveByChar(this,start,forward,by))}moveByGroup(start,forward){return skipAtoms(this,start,moveByChar(this,start,forward,(initial=>function(view,pos,start){let categorize=view.state.charCategorizer(pos),cat=categorize(start);return next=>{let nextCat=categorize(next);return cat==state.CharCategory.Space&&(cat=nextCat),cat==nextCat}}(this,start.head,initial))))}moveToLineBoundary(start,forward,includeWrap=!0){return function(view,start,forward,includeWrap){let line=view.state.doc.lineAt(start.head),coords=includeWrap&&view.lineWrapping?view.coordsAtPos(start.assoc<0&&start.head>line.from?start.head-1:start.head):null;if(coords){let editorRect=view.dom.getBoundingClientRect(),direction=view.textDirectionAt(line.from),pos=view.posAtCoords({x:forward==(direction==exports.Direction.LTR)?editorRect.right-1:editorRect.left+1,y:(coords.top+coords.bottom)/2});if(null!=pos)return state.EditorSelection.cursor(pos,forward?-1:1)}let lineView=LineView.find(view.docView,start.head),end=lineView?forward?lineView.posAtEnd:lineView.posAtStart:forward?line.to:line.from;return state.EditorSelection.cursor(end,forward?-1:1)}(this,start,forward,includeWrap)}moveVertically(start,forward,distance){return skipAtoms(this,start,function(view,start,forward,distance){let startPos=start.head,dir=forward?1:-1;if(startPos==(forward?view.state.doc.length:0))return state.EditorSelection.cursor(startPos,start.assoc);let startY,goal=start.goalColumn,rect=view.contentDOM.getBoundingClientRect(),startCoords=view.coordsAtPos(startPos),docTop=view.documentTop;if(startCoords)null==goal&&(goal=startCoords.left-rect.left),startY=dir<0?startCoords.top:startCoords.bottom;else{let line=view.viewState.lineBlockAt(startPos);null==goal&&(goal=Math.min(rect.right-rect.left,view.defaultCharacterWidth*(startPos-line.from))),startY=(dir<0?line.top:line.bottom)+docTop}let resolvedGoal=rect.left+goal,dist=null!=distance?distance:view.defaultLineHeight>>1;for(let extra=0;;extra+=10){let curY=startY+(dist+extra)*dir,pos=posAtCoords(view,{x:resolvedGoal,y:curY},!1,dir);if(curY<rect.top||curY>rect.bottom||(dir<0?pos<startPos:pos>startPos))return state.EditorSelection.cursor(pos,start.assoc,void 0,goal)}}(this,start,forward,distance))}domAtPos(pos){return this.docView.domAtPos(pos)}posAtDOM(node,offset=0){return this.docView.posFromDOM(node,offset)}posAtCoords(coords,precise=!0){return this.readMeasured(),posAtCoords(this,coords,precise)}coordsAtPos(pos,side=1){this.readMeasured();let rect=this.docView.coordsAt(pos,side);if(!rect||rect.left==rect.right)return rect;let line=this.state.doc.lineAt(pos),order=this.bidiSpans(line);return flattenRect(rect,order[BidiSpan.find(order,pos-line.from,-1,side)].dir==exports.Direction.LTR==side>0)}get defaultCharacterWidth(){return this.viewState.heightOracle.charWidth}get defaultLineHeight(){return this.viewState.heightOracle.lineHeight}get textDirection(){return this.viewState.defaultTextDirection}textDirectionAt(pos){return!this.state.facet(perLineTextDirection)||pos<this.viewport.from||pos>this.viewport.to?this.textDirection:(this.readMeasured(),this.docView.textDirectionAt(pos))}get lineWrapping(){return this.viewState.heightOracle.lineWrapping}bidiSpans(line){if(line.length>MaxBidiLine)return trivialOrder(line.length);let dir=this.textDirectionAt(line.from);for(let entry of this.bidiCache)if(entry.from==line.from&&entry.dir==dir)return entry.order;let order=computeOrder(line.text,dir);return this.bidiCache.push(new CachedOrder(line.from,line.to,dir,order)),order}get hasFocus(){var _a;return(this.dom.ownerDocument.hasFocus()||browser.safari&&(null===(_a=this.inputState)||void 0===_a?void 0:_a.lastContextMenu)>Date.now()-3e4)&&this.root.activeElement==this.contentDOM}focus(){this.observer.ignore((()=>{focusPreventScroll(this.contentDOM),this.docView.updateSelection()}))}setRoot(root){this._root!=root&&(this._root=root,this.observer.setWindow((9==root.nodeType?root:root.ownerDocument).defaultView||window),this.mountStyles())}destroy(){for(let plugin of this.plugins)plugin.destroy(this);this.plugins=[],this.inputState.destroy(),this.dom.remove(),this.observer.destroy(),this.measureScheduled>-1&&cancelAnimationFrame(this.measureScheduled),this.destroyed=!0}static scrollIntoView(pos,options={}){return scrollIntoView.of(new ScrollTarget("number"==typeof pos?state.EditorSelection.cursor(pos):pos,options.y,options.x,options.yMargin,options.xMargin))}static domEventHandlers(handlers){return ViewPlugin.define((()=>({})),{eventHandlers:handlers})}static theme(spec,options){let prefix=styleMod.StyleModule.newName(),result=[theme.of(prefix),styleModule.of(buildTheme(`.${prefix}`,spec))];return options&&options.dark&&result.push(darkTheme.of(!0)),result}static baseTheme(spec){return state.Prec.lowest(styleModule.of(buildTheme("."+baseThemeID,spec,lightDarkIDs)))}static findFromDOM(dom){var _a;let content=dom.querySelector(".cm-content"),cView=content&&ContentView.get(content)||ContentView.get(dom);return(null===(_a=null==cView?void 0:cView.rootView)||void 0===_a?void 0:_a.view)||null}}EditorView.styleModule=styleModule,EditorView.inputHandler=inputHandler,EditorView.perLineTextDirection=perLineTextDirection,EditorView.exceptionSink=exceptionSink,EditorView.updateListener=updateListener,EditorView.editable=editable,EditorView.mouseSelectionStyle=mouseSelectionStyle,EditorView.dragMovesSelection=dragMovesSelection$1,EditorView.clickAddsSelectionRange=clickAddsSelectionRange,EditorView.decorations=decorations,EditorView.atomicRanges=atomicRanges,EditorView.scrollMargins=scrollMargins,EditorView.darkTheme=darkTheme,EditorView.contentAttributes=contentAttributes,EditorView.editorAttributes=editorAttributes,EditorView.lineWrapping=EditorView.contentAttributes.of({class:"cm-lineWrapping"}),EditorView.announce=state.StateEffect.define();const MaxBidiLine=4096,BadMeasure={};class CachedOrder{constructor(from,to,dir,order){this.from=from,this.to=to,this.dir=dir,this.order=order}static update(cache,changes){if(changes.empty)return cache;let result=[],lastDir=cache.length?cache[cache.length-1].dir:exports.Direction.LTR;for(let i=Math.max(0,cache.length-10);i<cache.length;i++){let entry=cache[i];entry.dir!=lastDir||changes.touchesRange(entry.from,entry.to)||result.push(new CachedOrder(changes.mapPos(entry.from,1),changes.mapPos(entry.to,-1),entry.dir,entry.order))}return result}}function attrsFromFacet(view,facet,base){for(let sources=view.state.facet(facet),i=sources.length-1;i>=0;i--){let source=sources[i],value="function"==typeof source?source(view):source;value&&combineAttrs(value,base)}return base}const currentPlatform=browser.mac?"mac":browser.windows?"win":browser.linux?"linux":"key";function modifiers(name,event,shift){return event.altKey&&(name="Alt-"+name),event.ctrlKey&&(name="Ctrl-"+name),event.metaKey&&(name="Meta-"+name),!1!==shift&&event.shiftKey&&(name="Shift-"+name),name}const handleKeyEvents=state.Prec.default(EditorView.domEventHandlers({keydown:(event,view)=>runHandlers(getKeymap(view.state),event,view,"editor")})),keymap=state.Facet.define({enables:handleKeyEvents}),Keymaps=new WeakMap;function getKeymap(state){let bindings=state.facet(keymap),map=Keymaps.get(bindings);return map||Keymaps.set(bindings,map=function(bindings,platform=currentPlatform){let bound=Object.create(null),isPrefix=Object.create(null),checkPrefix=(name,is)=>{let current=isPrefix[name];if(null==current)isPrefix[name]=is;else if(current!=is)throw new Error("Key binding "+name+" is used both as a regular binding and as a multi-stroke prefix")},add=(scope,key,command,preventDefault)=>{var _a,_b;let scopeObj=bound[scope]||(bound[scope]=Object.create(null)),parts=key.split(/ (?!$)/).map((k=>function(name,platform){const parts=name.split(/-(?!$)/);let alt,ctrl,shift,meta,result=parts[parts.length-1];"Space"==result&&(result=" ");for(let i=0;i<parts.length-1;++i){const mod=parts[i];if(/^(cmd|meta|m)$/i.test(mod))meta=!0;else if(/^a(lt)?$/i.test(mod))alt=!0;else if(/^(c|ctrl|control)$/i.test(mod))ctrl=!0;else if(/^s(hift)?$/i.test(mod))shift=!0;else{if(!/^mod$/i.test(mod))throw new Error("Unrecognized modifier name: "+mod);"mac"==platform?meta=!0:ctrl=!0}}return alt&&(result="Alt-"+result),ctrl&&(result="Ctrl-"+result),meta&&(result="Meta-"+result),shift&&(result="Shift-"+result),result}(k,platform)));for(let i=1;i<parts.length;i++){let prefix=parts.slice(0,i).join(" ");checkPrefix(prefix,!0),scopeObj[prefix]||(scopeObj[prefix]={preventDefault:!0,run:[view=>{let ourObj=storedPrefix={view:view,prefix:prefix,scope:scope};return setTimeout((()=>{storedPrefix==ourObj&&(storedPrefix=null)}),4e3),!0}]})}let full=parts.join(" ");checkPrefix(full,!1);let binding=scopeObj[full]||(scopeObj[full]={preventDefault:!1,run:(null===(_b=null===(_a=scopeObj._any)||void 0===_a?void 0:_a.run)||void 0===_b?void 0:_b.slice())||[]});command&&binding.run.push(command),preventDefault&&(binding.preventDefault=!0)};for(let b of bindings){let scopes=b.scope?b.scope.split(" "):["editor"];if(b.any)for(let scope of scopes){let scopeObj=bound[scope]||(bound[scope]=Object.create(null));scopeObj._any||(scopeObj._any={preventDefault:!1,run:[]});for(let key in scopeObj)scopeObj[key].run.push(b.any)}let name=b[platform]||b.key;if(name)for(let scope of scopes)add(scope,name,b.run,b.preventDefault),b.shift&&add(scope,"Shift-"+name,b.shift,b.preventDefault)}return bound}(bindings.reduce(((a,b)=>a.concat(b)),[]))),map}let storedPrefix=null;function runHandlers(map,event,view,scope){let name=w3cKeyname.keyName(event),charCode=state.codePointAt(name,0),isChar=state.codePointSize(charCode)==name.length&&" "!=name,prefix="",fallthrough=!1;storedPrefix&&storedPrefix.view==view&&storedPrefix.scope==scope&&(prefix=storedPrefix.prefix+" ",(fallthrough=modifierCodes.indexOf(event.keyCode)<0)&&(storedPrefix=null));let baseName,shiftName,ran=new Set,runFor=binding=>{if(binding){for(let cmd of binding.run)if(!ran.has(cmd)&&(ran.add(cmd),cmd(view,event)))return!0;binding.preventDefault&&(fallthrough=!0)}return!1},scopeObj=map[scope];if(scopeObj){if(runFor(scopeObj[prefix+modifiers(name,event,!isChar)]))return!0;if(isChar&&(event.altKey||event.metaKey||event.ctrlKey)&&!(browser.windows&&event.ctrlKey&&event.altKey)&&(baseName=w3cKeyname.base[event.keyCode])&&baseName!=name){if(runFor(scopeObj[prefix+modifiers(baseName,event,!0)]))return!0;if(event.shiftKey&&(shiftName=w3cKeyname.shift[event.keyCode])!=name&&shiftName!=baseName&&runFor(scopeObj[prefix+modifiers(shiftName,event,!1)]))return!0}else if(isChar&&event.shiftKey&&runFor(scopeObj[prefix+modifiers(name,event,!0)]))return!0;if(runFor(scopeObj._any))return!0}return fallthrough}class RectangleMarker{constructor(className,left,top,width,height){this.className=className,this.left=left,this.top=top,this.width=width,this.height=height}draw(){let elt=document.createElement("div");return elt.className=this.className,this.adjust(elt),elt}update(elt,prev){return prev.className==this.className&&(this.adjust(elt),!0)}adjust(elt){elt.style.left=this.left+"px",elt.style.top=this.top+"px",null!=this.width&&(elt.style.width=this.width+"px"),elt.style.height=this.height+"px"}eq(p){return this.left==p.left&&this.top==p.top&&this.width==p.width&&this.height==p.height&&this.className==p.className}static forRange(view,className,range){if(range.empty){let pos=view.coordsAtPos(range.head,range.assoc||1);if(!pos)return[];let base=getBase(view);return[new RectangleMarker(className,pos.left-base.left,pos.top-base.top,null,pos.bottom-pos.top)]}return function(view,className,range){if(range.to<=view.viewport.from||range.from>=view.viewport.to)return[];let from=Math.max(range.from,view.viewport.from),to=Math.min(range.to,view.viewport.to),ltr=view.textDirection==exports.Direction.LTR,content=view.contentDOM,contentRect=content.getBoundingClientRect(),base=getBase(view),lineStyle=window.getComputedStyle(content.firstChild),leftSide=contentRect.left+parseInt(lineStyle.paddingLeft)+Math.min(0,parseInt(lineStyle.textIndent)),rightSide=contentRect.right-parseInt(lineStyle.paddingRight),startBlock=blockAt(view,from),endBlock=blockAt(view,to),visualStart=startBlock.type==exports.BlockType.Text?startBlock:null,visualEnd=endBlock.type==exports.BlockType.Text?endBlock:null;view.lineWrapping&&(visualStart&&(visualStart=wrappedLine(view,from,visualStart)),visualEnd&&(visualEnd=wrappedLine(view,to,visualEnd)));if(visualStart&&visualEnd&&visualStart.from==visualEnd.from)return pieces(drawForLine(range.from,range.to,visualStart));{let top=visualStart?drawForLine(range.from,null,visualStart):drawForWidget(startBlock,!1),bottom=visualEnd?drawForLine(null,range.to,visualEnd):drawForWidget(endBlock,!0),between=[];return(visualStart||startBlock).to<(visualEnd||endBlock).from-1?between.push(piece(leftSide,top.bottom,rightSide,bottom.top)):top.bottom<bottom.top&&view.elementAtHeight((top.bottom+bottom.top)/2).type==exports.BlockType.Text&&(top.bottom=bottom.top=(top.bottom+bottom.top)/2),pieces(top).concat(between).concat(pieces(bottom))}function piece(left,top,right,bottom){return new RectangleMarker(className,left-base.left,top-base.top-.01,right-left,bottom-top+.01)}function pieces({top:top,bottom:bottom,horizontal:horizontal}){let pieces=[];for(let i=0;i<horizontal.length;i+=2)pieces.push(piece(horizontal[i],top,horizontal[i+1],bottom));return pieces}function drawForLine(from,to,line){let top=1e9,bottom=-1e9,horizontal=[];function addSpan(from,fromOpen,to,toOpen,dir){let fromCoords=view.coordsAtPos(from,from==line.to?-2:2),toCoords=view.coordsAtPos(to,to==line.from?2:-2);top=Math.min(fromCoords.top,toCoords.top,top),bottom=Math.max(fromCoords.bottom,toCoords.bottom,bottom),dir==exports.Direction.LTR?horizontal.push(ltr&&fromOpen?leftSide:fromCoords.left,ltr&&toOpen?rightSide:toCoords.right):horizontal.push(!ltr&&toOpen?leftSide:toCoords.left,!ltr&&fromOpen?rightSide:fromCoords.right)}let start=null!=from?from:line.from,end=null!=to?to:line.to;for(let r of view.visibleRanges)if(r.to>start&&r.from<end)for(let pos=Math.max(r.from,start),endPos=Math.min(r.to,end);;){let docLine=view.state.doc.lineAt(pos);for(let span of view.bidiSpans(docLine)){let spanFrom=span.from+docLine.from,spanTo=span.to+docLine.from;if(spanFrom>=endPos)break;spanTo>pos&&addSpan(Math.max(spanFrom,pos),null==from&&spanFrom<=start,Math.min(spanTo,endPos),null==to&&spanTo>=end,span.dir)}if(pos=docLine.to+1,pos>=endPos)break}return 0==horizontal.length&&addSpan(start,null==from,end,null==to,view.textDirection),{top:top,bottom:bottom,horizontal:horizontal}}function drawForWidget(block,top){let y=contentRect.top+(top?block.top:block.bottom);return{top:y,bottom:y,horizontal:[]}}}(view,className,range)}}function getBase(view){let rect=view.scrollDOM.getBoundingClientRect();return{left:(view.textDirection==exports.Direction.LTR?rect.left:rect.right-view.scrollDOM.clientWidth)-view.scrollDOM.scrollLeft,top:rect.top-view.scrollDOM.scrollTop}}function wrappedLine(view,pos,inside){let range=state.EditorSelection.cursor(pos);return{from:Math.max(inside.from,view.moveToLineBoundary(range,!1,!0).from),to:Math.min(inside.to,view.moveToLineBoundary(range,!0,!0).from),type:exports.BlockType.Text}}function blockAt(view,pos){let line=view.lineBlockAt(pos);if(Array.isArray(line.type))for(let l of line.type)if(l.to>pos||l.to==pos&&(l.to==line.to||l.type==exports.BlockType.Text))return l;return line}class LayerView{constructor(view,layer){this.view=view,this.layer=layer,this.drawn=[],this.measureReq={read:this.measure.bind(this),write:this.draw.bind(this)},this.dom=view.scrollDOM.appendChild(document.createElement("div")),this.dom.classList.add("cm-layer"),layer.above&&this.dom.classList.add("cm-layer-above"),layer.class&&this.dom.classList.add(layer.class),this.dom.setAttribute("aria-hidden","true"),this.setOrder(view.state),view.requestMeasure(this.measureReq),layer.mount&&layer.mount(this.dom,view)}update(update){update.startState.facet(layerOrder)!=update.state.facet(layerOrder)&&this.setOrder(update.state),(this.layer.update(update,this.dom)||update.geometryChanged)&&update.view.requestMeasure(this.measureReq)}setOrder(state){let pos=0,order=state.facet(layerOrder);for(;pos<order.length&&order[pos]!=this.layer;)pos++;this.dom.style.zIndex=String((this.layer.above?150:-1)-pos)}measure(){return this.layer.markers(this.view)}draw(markers){if(markers.length!=this.drawn.length||markers.some(((p,i)=>{return a=p,b=this.drawn[i],!(a.constructor==b.constructor&&a.eq(b));var a,b}))){let old=this.dom.firstChild,oldI=0;for(let marker of markers)marker.update&&old&&marker.constructor&&this.drawn[oldI].constructor&&marker.update(old,this.drawn[oldI])?(old=old.nextSibling,oldI++):this.dom.insertBefore(marker.draw(),old);for(;old;){let next=old.nextSibling;old.remove(),old=next}this.drawn=markers}}destroy(){this.layer.destroy&&this.layer.destroy(this.dom,this.view),this.dom.remove()}}const layerOrder=state.Facet.define();function layer(config){return[ViewPlugin.define((v=>new LayerView(v,config))),layerOrder.of(config)]}const CanHidePrimary=!browser.ios,selectionConfig=state.Facet.define({combine:configs=>state.combineConfig(configs,{cursorBlinkRate:1200,drawRangeCursor:!0},{cursorBlinkRate:(a,b)=>Math.min(a,b),drawRangeCursor:(a,b)=>a||b})});function configChanged(update){return update.startState.facet(selectionConfig)!=update.state.facet(selectionConfig)}const cursorLayer=layer({above:!0,markers(view){let{state:state$1}=view,conf=state$1.facet(selectionConfig),cursors=[];for(let r of state$1.selection.ranges){let prim=r==state$1.selection.main;if(r.empty?!prim||CanHidePrimary:conf.drawRangeCursor){let className=prim?"cm-cursor cm-cursor-primary":"cm-cursor cm-cursor-secondary",cursor=r.empty?r:state.EditorSelection.cursor(r.head,r.head>r.anchor?-1:1);for(let piece of RectangleMarker.forRange(view,className,cursor))cursors.push(piece)}}return cursors},update(update,dom){update.transactions.some((tr=>tr.selection))&&(dom.style.animationName="cm-blink"==dom.style.animationName?"cm-blink2":"cm-blink");let confChange=configChanged(update);return confChange&&setBlinkRate(update.state,dom),update.docChanged||update.selectionSet||confChange},mount(dom,view){setBlinkRate(view.state,dom)},class:"cm-cursorLayer"});function setBlinkRate(state,dom){dom.style.animationDuration=state.facet(selectionConfig).cursorBlinkRate+"ms"}const selectionLayer=layer({above:!1,markers:view=>view.state.selection.ranges.map((r=>r.empty?[]:RectangleMarker.forRange(view,"cm-selectionBackground",r))).reduce(((a,b)=>a.concat(b))),update:(update,dom)=>update.docChanged||update.selectionSet||update.viewportChanged||configChanged(update),class:"cm-selectionLayer"}),themeSpec={".cm-line":{"& ::selection":{backgroundColor:"transparent !important"},"&::selection":{backgroundColor:"transparent !important"}}};CanHidePrimary&&(themeSpec[".cm-line"].caretColor="transparent !important");const hideNativeSelection=state.Prec.highest(EditorView.theme(themeSpec)),setDropCursorPos=state.StateEffect.define({map:(pos,mapping)=>null==pos?null:mapping.mapPos(pos)}),dropCursorPos=state.StateField.define({create:()=>null,update:(pos,tr)=>(null!=pos&&(pos=tr.changes.mapPos(pos)),tr.effects.reduce(((pos,e)=>e.is(setDropCursorPos)?e.value:pos),pos))}),drawDropCursor=ViewPlugin.fromClass(class{constructor(view){this.view=view,this.cursor=null,this.measureReq={read:this.readPos.bind(this),write:this.drawCursor.bind(this)}}update(update){var _a;let cursorPos=update.state.field(dropCursorPos);null==cursorPos?null!=this.cursor&&(null===(_a=this.cursor)||void 0===_a||_a.remove(),this.cursor=null):(this.cursor||(this.cursor=this.view.scrollDOM.appendChild(document.createElement("div")),this.cursor.className="cm-dropCursor"),(update.startState.field(dropCursorPos)!=cursorPos||update.docChanged||update.geometryChanged)&&this.view.requestMeasure(this.measureReq))}readPos(){let pos=this.view.state.field(dropCursorPos),rect=null!=pos&&this.view.coordsAtPos(pos);if(!rect)return null;let outer=this.view.scrollDOM.getBoundingClientRect();return{left:rect.left-outer.left+this.view.scrollDOM.scrollLeft,top:rect.top-outer.top+this.view.scrollDOM.scrollTop,height:rect.bottom-rect.top}}drawCursor(pos){this.cursor&&(pos?(this.cursor.style.left=pos.left+"px",this.cursor.style.top=pos.top+"px",this.cursor.style.height=pos.height+"px"):this.cursor.style.left="-100000px")}destroy(){this.cursor&&this.cursor.remove()}setDropPos(pos){this.view.state.field(dropCursorPos)!=pos&&this.view.dispatch({effects:setDropCursorPos.of(pos)})}},{eventHandlers:{dragover(event){this.setDropPos(this.view.posAtCoords({x:event.clientX,y:event.clientY}))},dragleave(event){event.target!=this.view.contentDOM&&this.view.contentDOM.contains(event.relatedTarget)||this.setDropPos(null)},dragend(){this.setDropPos(null)},drop(){this.setDropPos(null)}}});function iterMatches(doc,re,from,to,f){re.lastIndex=0;for(let m,cursor=doc.iterRange(from,to),pos=from;!cursor.next().done;pos+=cursor.value.length)if(!cursor.lineBreak)for(;m=re.exec(cursor.value);)f(pos+m.index,m)}class MatchDecorator{constructor(config){const{regexp:regexp,decoration:decoration,decorate:decorate,boundary:boundary,maxLength:maxLength=1e3}=config;if(!regexp.global)throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");if(this.regexp=regexp,decorate)this.addMatch=(match,view,from,add)=>decorate(add,from,from+match[0].length,match,view);else if("function"==typeof decoration)this.addMatch=(match,view,from,add)=>{let deco=decoration(match,view,from);deco&&add(from,from+match[0].length,deco)};else{if(!decoration)throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");this.addMatch=(match,_view,from,add)=>add(from,from+match[0].length,decoration)}this.boundary=boundary,this.maxLength=maxLength}createDeco(view){let build=new state.RangeSetBuilder,add=build.add.bind(build);for(let{from:from,to:to}of function(view,maxLength){let visible=view.visibleRanges;if(1==visible.length&&visible[0].from==view.viewport.from&&visible[0].to==view.viewport.to)return visible;let result=[];for(let{from:from,to:to}of visible)from=Math.max(view.state.doc.lineAt(from).from,from-maxLength),to=Math.min(view.state.doc.lineAt(to).to,to+maxLength),result.length&&result[result.length-1].to>=from?result[result.length-1].to=to:result.push({from:from,to:to});return result}(view,this.maxLength))iterMatches(view.state.doc,this.regexp,from,to,((from,m)=>this.addMatch(m,view,from,add)));return build.finish()}updateDeco(update,deco){let changeFrom=1e9,changeTo=-1;return update.docChanged&&update.changes.iterChanges(((_f,_t,from,to)=>{to>update.view.viewport.from&&from<update.view.viewport.to&&(changeFrom=Math.min(from,changeFrom),changeTo=Math.max(to,changeTo))})),update.viewportChanged||changeTo-changeFrom>1e3?this.createDeco(update.view):changeTo>-1?this.updateRange(update.view,deco.map(update.changes),changeFrom,changeTo):deco}updateRange(view,deco,updateFrom,updateTo){for(let r of view.visibleRanges){let from=Math.max(r.from,updateFrom),to=Math.min(r.to,updateTo);if(to>from){let fromLine=view.state.doc.lineAt(from),toLine=fromLine.to<to?view.state.doc.lineAt(to):fromLine,start=Math.max(r.from,fromLine.from),end=Math.min(r.to,toLine.to);if(this.boundary){for(;from>fromLine.from;from--)if(this.boundary.test(fromLine.text[from-1-fromLine.from])){start=from;break}for(;to<toLine.to;to++)if(this.boundary.test(toLine.text[to-toLine.from])){end=to;break}}let m,ranges=[],add=(from,to,deco)=>ranges.push(deco.range(from,to));if(fromLine==toLine)for(this.regexp.lastIndex=start-fromLine.from;(m=this.regexp.exec(fromLine.text))&&m.index<end-fromLine.from;)this.addMatch(m,view,m.index+fromLine.from,add);else iterMatches(view.state.doc,this.regexp,start,end,((from,m)=>this.addMatch(m,view,from,add)));deco=deco.update({filterFrom:start,filterTo:end,filter:(from,to)=>from<start||to>end,add:ranges})}}return deco}}const UnicodeRegexpSupport=null!=/x/.unicode?"gu":"g",Specials=new RegExp("[\0-\b\n--\u2028\u2029\ufeff-]",UnicodeRegexpSupport),Names={0:"null",7:"bell",8:"backspace",10:"newline",11:"vertical tab",13:"carriage return",27:"escape",8203:"zero width space",8204:"zero width non-joiner",8205:"zero width joiner",8206:"left-to-right mark",8207:"right-to-left mark",8232:"line separator",8237:"left-to-right override",8238:"right-to-left override",8294:"left-to-right isolate",8295:"right-to-left isolate",8297:"pop directional isolate",8233:"paragraph separator",65279:"zero width no-break space",65532:"object replacement"};let _supportsTabSize=null;const specialCharConfig=state.Facet.define({combine(configs){let config=state.combineConfig(configs,{render:null,specialChars:Specials,addSpecialChars:null});return(config.replaceTabs=!function(){var _a;if(null==_supportsTabSize&&"undefined"!=typeof document&&document.body){let styles=document.body.style;_supportsTabSize=null!=(null!==(_a=styles.tabSize)&&void 0!==_a?_a:styles.MozTabSize)}return _supportsTabSize||!1}())&&(config.specialChars=new RegExp("\t|"+config.specialChars.source,UnicodeRegexpSupport)),config.addSpecialChars&&(config.specialChars=new RegExp(config.specialChars.source+"|"+config.addSpecialChars.source,UnicodeRegexpSupport)),config}});let _plugin=null;class SpecialCharWidget extends WidgetType{constructor(options,code){super(),this.options=options,this.code=code}eq(other){return other.code==this.code}toDOM(view){let ph=(code=this.code)>=32?"":10==code?"":String.fromCharCode(9216+code);var code;let desc=view.state.phrase("Control character")+" "+(Names[this.code]||"0x"+this.code.toString(16)),custom=this.options.render&&this.options.render(this.code,desc,ph);if(custom)return custom;let span=document.createElement("span");return span.textContent=ph,span.title=desc,span.setAttribute("aria-label",desc),span.className="cm-specialChar",span}ignoreEvent(){return!1}}class TabWidget extends WidgetType{constructor(width){super(),this.width=width}eq(other){return other.width==this.width}toDOM(){let span=document.createElement("span");return span.textContent="\t",span.className="cm-tab",span.style.width=this.width+"px",span}ignoreEvent(){return!1}}const plugin=ViewPlugin.fromClass(class{constructor(){this.height=1e3,this.attrs={style:"padding-bottom: 1000px"}}update(update){let{view:view}=update,height=view.viewState.editorHeight-view.defaultLineHeight-view.documentPadding.top-.5;height!=this.height&&(this.height=height,this.attrs={style:`padding-bottom: ${height}px`})}});const lineDeco=Decoration.line({class:"cm-activeLine"}),activeLineHighlighter=ViewPlugin.fromClass(class{constructor(view){this.decorations=this.getDeco(view)}update(update){(update.docChanged||update.selectionSet)&&(this.decorations=this.getDeco(update.view))}getDeco(view){let lastLineStart=-1,deco=[];for(let r of view.state.selection.ranges){let line=view.lineBlockAt(r.head);line.from>lastLineStart&&(deco.push(lineDeco.range(line.from)),lastLineStart=line.from)}return Decoration.set(deco)}},{decorations:v=>v.decorations});class Placeholder extends WidgetType{constructor(content){super(),this.content=content}toDOM(){let wrap=document.createElement("span");return wrap.className="cm-placeholder",wrap.style.pointerEvents="none",wrap.appendChild("string"==typeof this.content?document.createTextNode(this.content):this.content),"string"==typeof this.content?wrap.setAttribute("aria-label","placeholder "+this.content):wrap.setAttribute("aria-hidden","true"),wrap}ignoreEvent(){return!1}}function getPos(view,event){let offset=view.posAtCoords({x:event.clientX,y:event.clientY},!1),line=view.state.doc.lineAt(offset),off=offset-line.from,col=off>2e3?-1:off==line.length?function(view,x){let ref=view.coordsAtPos(view.viewport.from);return ref?Math.round(Math.abs((ref.left-x)/view.defaultCharacterWidth)):-1}(view,event.clientX):state.countColumn(line.text,view.state.tabSize,offset-line.from);return{line:line.number,col:col,off:off}}function rectangleSelectionStyle(view,event){let start=getPos(view,event),startSel=view.state.selection;return start?{update(update){if(update.docChanged){let newStart=update.changes.mapPos(update.startState.doc.line(start.line).from),newLine=update.state.doc.lineAt(newStart);start={line:newLine.number,col:start.col,off:Math.min(start.off,newLine.length)},startSel=startSel.map(update.changes)}},get(event,_extend,multiple){let cur=getPos(view,event);if(!cur)return startSel;let ranges=function(state$1,a,b){let startLine=Math.min(a.line,b.line),endLine=Math.max(a.line,b.line),ranges=[];if(a.off>2e3||b.off>2e3||a.col<0||b.col<0){let startOff=Math.min(a.off,b.off),endOff=Math.max(a.off,b.off);for(let i=startLine;i<=endLine;i++){let line=state$1.doc.line(i);line.length<=endOff&&ranges.push(state.EditorSelection.range(line.from+startOff,line.to+endOff))}}else{let startCol=Math.min(a.col,b.col),endCol=Math.max(a.col,b.col);for(let i=startLine;i<=endLine;i++){let line=state$1.doc.line(i),start=state.findColumn(line.text,startCol,state$1.tabSize,!0);if(start<0)ranges.push(state.EditorSelection.cursor(line.to));else{let end=state.findColumn(line.text,endCol,state$1.tabSize);ranges.push(state.EditorSelection.range(line.from+start,line.from+end))}}}return ranges}(view.state,start,cur);return ranges.length?multiple?state.EditorSelection.create(ranges.concat(startSel.ranges)):state.EditorSelection.create(ranges):startSel}}:null}const keys={Alt:[18,e=>e.altKey],Control:[17,e=>e.ctrlKey],Shift:[16,e=>e.shiftKey],Meta:[91,e=>e.metaKey]},showCrosshair={style:"cursor: crosshair"};class TooltipViewManager{constructor(view,facet,createTooltipView){this.facet=facet,this.createTooltipView=createTooltipView,this.input=view.state.facet(facet),this.tooltips=this.input.filter((t=>t)),this.tooltipViews=this.tooltips.map(createTooltipView)}update(update){var _a;let input=update.state.facet(this.facet),tooltips=input.filter((x=>x));if(input===this.input){for(let t of this.tooltipViews)t.update&&t.update(update);return!1}let tooltipViews=[];for(let i=0;i<tooltips.length;i++){let tip=tooltips[i],known=-1;if(tip){for(let i=0;i<this.tooltips.length;i++){let other=this.tooltips[i];other&&other.create==tip.create&&(known=i)}if(known<0)tooltipViews[i]=this.createTooltipView(tip);else{let tooltipView=tooltipViews[i]=this.tooltipViews[known];tooltipView.update&&tooltipView.update(update)}}}for(let t of this.tooltipViews)tooltipViews.indexOf(t)<0&&(t.dom.remove(),null===(_a=t.destroy)||void 0===_a||_a.call(t));return this.input=input,this.tooltips=tooltips,this.tooltipViews=tooltipViews,!0}}function windowSpace(view){let{win:win}=view;return{top:0,left:0,bottom:win.innerHeight,right:win.innerWidth}}const tooltipConfig=state.Facet.define({combine:values=>{var _a,_b,_c;return{position:browser.ios?"absolute":(null===(_a=values.find((conf=>conf.position)))||void 0===_a?void 0:_a.position)||"fixed",parent:(null===(_b=values.find((conf=>conf.parent)))||void 0===_b?void 0:_b.parent)||null,tooltipSpace:(null===(_c=values.find((conf=>conf.tooltipSpace)))||void 0===_c?void 0:_c.tooltipSpace)||windowSpace}}}),tooltipPlugin=ViewPlugin.fromClass(class{constructor(view){this.view=view,this.inView=!0,this.lastTransaction=0,this.measureTimeout=-1;let config=view.state.facet(tooltipConfig);this.position=config.position,this.parent=config.parent,this.classes=view.themeClasses,this.createContainer(),this.measureReq={read:this.readMeasure.bind(this),write:this.writeMeasure.bind(this),key:this},this.manager=new TooltipViewManager(view,showTooltip,(t=>this.createTooltip(t))),this.intersectionObserver="function"==typeof IntersectionObserver?new IntersectionObserver((entries=>{Date.now()>this.lastTransaction-50&&entries.length>0&&entries[entries.length-1].intersectionRatio<1&&this.measureSoon()}),{threshold:[1]}):null,this.observeIntersection(),view.win.addEventListener("resize",this.measureSoon=this.measureSoon.bind(this)),this.maybeMeasure()}createContainer(){this.parent?(this.container=document.createElement("div"),this.container.style.position="relative",this.container.className=this.view.themeClasses,this.parent.appendChild(this.container)):this.container=this.view.dom}observeIntersection(){if(this.intersectionObserver){this.intersectionObserver.disconnect();for(let tooltip of this.manager.tooltipViews)this.intersectionObserver.observe(tooltip.dom)}}measureSoon(){this.measureTimeout<0&&(this.measureTimeout=setTimeout((()=>{this.measureTimeout=-1,this.maybeMeasure()}),50))}update(update){update.transactions.length&&(this.lastTransaction=Date.now());let updated=this.manager.update(update);updated&&this.observeIntersection();let shouldMeasure=updated||update.geometryChanged,newConfig=update.state.facet(tooltipConfig);if(newConfig.position!=this.position){this.position=newConfig.position;for(let t of this.manager.tooltipViews)t.dom.style.position=this.position;shouldMeasure=!0}if(newConfig.parent!=this.parent){this.parent&&this.container.remove(),this.parent=newConfig.parent,this.createContainer();for(let t of this.manager.tooltipViews)this.container.appendChild(t.dom);shouldMeasure=!0}else this.parent&&this.view.themeClasses!=this.classes&&(this.classes=this.container.className=this.view.themeClasses);shouldMeasure&&this.maybeMeasure()}createTooltip(tooltip){let tooltipView=tooltip.create(this.view);if(tooltipView.dom.classList.add("cm-tooltip"),tooltip.arrow&&!tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")){let arrow=document.createElement("div");arrow.className="cm-tooltip-arrow",tooltipView.dom.appendChild(arrow)}return tooltipView.dom.style.position=this.position,tooltipView.dom.style.top="-10000px",this.container.appendChild(tooltipView.dom),tooltipView.mount&&tooltipView.mount(this.view),tooltipView}destroy(){var _a,_b;this.view.win.removeEventListener("resize",this.measureSoon);for(let tooltipView of this.manager.tooltipViews)tooltipView.dom.remove(),null===(_a=tooltipView.destroy)||void 0===_a||_a.call(tooltipView);null===(_b=this.intersectionObserver)||void 0===_b||_b.disconnect(),clearTimeout(this.measureTimeout)}readMeasure(){let editor=this.view.dom.getBoundingClientRect();return{editor:editor,parent:this.parent?this.container.getBoundingClientRect():editor,pos:this.manager.tooltips.map(((t,i)=>{let tv=this.manager.tooltipViews[i];return tv.getCoords?tv.getCoords(t.pos):this.view.coordsAtPos(t.pos)})),size:this.manager.tooltipViews.map((({dom:dom})=>dom.getBoundingClientRect())),space:this.view.state.facet(tooltipConfig).tooltipSpace(this.view)}}writeMeasure(measured){let{editor:editor,space:space}=measured,others=[];for(let i=0;i<this.manager.tooltips.length;i++){let tooltip=this.manager.tooltips[i],tView=this.manager.tooltipViews[i],{dom:dom}=tView,pos=measured.pos[i],size=measured.size[i];if(!pos||pos.bottom<=Math.max(editor.top,space.top)||pos.top>=Math.min(editor.bottom,space.bottom)||pos.right<Math.max(editor.left,space.left)-.1||pos.left>Math.min(editor.right,space.right)+.1){dom.style.top="-10000px";continue}let arrow=tooltip.arrow?tView.dom.querySelector(".cm-tooltip-arrow"):null,arrowHeight=arrow?7:0,width=size.right-size.left,height=size.bottom-size.top,offset=tView.offset||noOffset,ltr=this.view.textDirection==exports.Direction.LTR,left=size.width>space.right-space.left?ltr?space.left:space.right-size.width:ltr?Math.min(pos.left-(arrow?14:0)+offset.x,space.right-width):Math.max(space.left,pos.left-width+(arrow?14:0)-offset.x),above=!!tooltip.above;!tooltip.strictSide&&(above?pos.top-(size.bottom-size.top)-offset.y<space.top:pos.bottom+(size.bottom-size.top)+offset.y>space.bottom)&&above==space.bottom-pos.bottom>pos.top-space.top&&(above=!above);let spaceVert=(above?pos.top-space.top:space.bottom-pos.bottom)-arrowHeight;if(spaceVert<height&&!1!==tView.resize){if(spaceVert<this.view.defaultLineHeight){dom.style.top="-10000px";continue}dom.style.height=(height=spaceVert)+"px"}else dom.style.height&&(dom.style.height="");let top=above?pos.top-height-arrowHeight-offset.y:pos.bottom+arrowHeight+offset.y,right=left+width;if(!0!==tView.overlap)for(let r of others)r.left<right&&r.right>left&&r.top<top+height&&r.bottom>top&&(top=above?r.top-height-2-arrowHeight:r.bottom+arrowHeight+2);"absolute"==this.position?(dom.style.top=top-measured.parent.top+"px",dom.style.left=left-measured.parent.left+"px"):(dom.style.top=top+"px",dom.style.left=left+"px"),arrow&&(arrow.style.left=pos.left+(ltr?offset.x:-offset.x)-(left+14-7)+"px"),!0!==tView.overlap&&others.push({left:left,top:top,right:right,bottom:top+height}),dom.classList.toggle("cm-tooltip-above",above),dom.classList.toggle("cm-tooltip-below",!above),tView.positioned&&tView.positioned(measured.space)}}maybeMeasure(){if(this.manager.tooltips.length&&(this.view.inView&&this.view.requestMeasure(this.measureReq),this.inView!=this.view.inView&&(this.inView=this.view.inView,!this.inView)))for(let tv of this.manager.tooltipViews)tv.dom.style.top="-10000px"}},{eventHandlers:{scroll(){this.maybeMeasure()}}}),baseTheme=EditorView.baseTheme({".cm-tooltip":{zIndex:100,boxSizing:"border-box"},"&light .cm-tooltip":{border:"1px solid #bbb",backgroundColor:"#f5f5f5"},"&light .cm-tooltip-section:not(:first-child)":{borderTop:"1px solid #bbb"},"&dark .cm-tooltip":{backgroundColor:"#333338",color:"white"},".cm-tooltip-arrow":{height:"7px",width:"14px",position:"absolute",zIndex:-1,overflow:"hidden","&:before, &:after":{content:"''",position:"absolute",width:0,height:0,borderLeft:"7px solid transparent",borderRight:"7px solid transparent"},".cm-tooltip-above &":{bottom:"-7px","&:before":{borderTop:"7px solid #bbb"},"&:after":{borderTop:"7px solid #f5f5f5",bottom:"1px"}},".cm-tooltip-below &":{top:"-7px","&:before":{borderBottom:"7px solid #bbb"},"&:after":{borderBottom:"7px solid #f5f5f5",top:"1px"}}},"&dark .cm-tooltip .cm-tooltip-arrow":{"&:before":{borderTopColor:"#333338",borderBottomColor:"#333338"},"&:after":{borderTopColor:"transparent",borderBottomColor:"transparent"}}}),noOffset={x:0,y:0},showTooltip=state.Facet.define({enables:[tooltipPlugin,baseTheme]}),showHoverTooltip=state.Facet.define();class HoverTooltipHost{constructor(view){this.view=view,this.mounted=!1,this.dom=document.createElement("div"),this.dom.classList.add("cm-tooltip-hover"),this.manager=new TooltipViewManager(view,showHoverTooltip,(t=>this.createHostedView(t)))}static create(view){return new HoverTooltipHost(view)}createHostedView(tooltip){let hostedView=tooltip.create(this.view);return hostedView.dom.classList.add("cm-tooltip-section"),this.dom.appendChild(hostedView.dom),this.mounted&&hostedView.mount&&hostedView.mount(this.view),hostedView}mount(view){for(let hostedView of this.manager.tooltipViews)hostedView.mount&&hostedView.mount(view);this.mounted=!0}positioned(space){for(let hostedView of this.manager.tooltipViews)hostedView.positioned&&hostedView.positioned(space)}update(update){this.manager.update(update)}}const showHoverTooltipHost=showTooltip.compute([showHoverTooltip],(state=>{let tooltips=state.facet(showHoverTooltip).filter((t=>t));return 0===tooltips.length?null:{pos:Math.min(...tooltips.map((t=>t.pos))),end:Math.max(...tooltips.filter((t=>null!=t.end)).map((t=>t.end))),create:HoverTooltipHost.create,above:tooltips[0].above,arrow:tooltips.some((t=>t.arrow))}}));class HoverPlugin{constructor(view,source,field,setHover,hoverTime){this.view=view,this.source=source,this.field=field,this.setHover=setHover,this.hoverTime=hoverTime,this.hoverTimeout=-1,this.restartTimeout=-1,this.pending=null,this.lastMove={x:0,y:0,target:view.dom,time:0},this.checkHover=this.checkHover.bind(this),view.dom.addEventListener("mouseleave",this.mouseleave=this.mouseleave.bind(this)),view.dom.addEventListener("mousemove",this.mousemove=this.mousemove.bind(this))}update(){this.pending&&(this.pending=null,clearTimeout(this.restartTimeout),this.restartTimeout=setTimeout((()=>this.startHover()),20))}get active(){return this.view.state.field(this.field)}checkHover(){if(this.hoverTimeout=-1,this.active)return;let hovered=Date.now()-this.lastMove.time;hovered<this.hoverTime?this.hoverTimeout=setTimeout(this.checkHover,this.hoverTime-hovered):this.startHover()}startHover(){clearTimeout(this.restartTimeout);let{lastMove:lastMove}=this,pos=this.view.contentDOM.contains(lastMove.target)?this.view.posAtCoords(lastMove):null;if(null==pos)return;let posCoords=this.view.coordsAtPos(pos);if(null==posCoords||lastMove.y<posCoords.top||lastMove.y>posCoords.bottom||lastMove.x<posCoords.left-this.view.defaultCharacterWidth||lastMove.x>posCoords.right+this.view.defaultCharacterWidth)return;let bidi=this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find((s=>s.from<=pos&&s.to>=pos)),rtl=bidi&&bidi.dir==exports.Direction.RTL?-1:1,open=this.source(this.view,pos,lastMove.x<posCoords.left?-rtl:rtl);if(null==open?void 0:open.then){let pending=this.pending={pos:pos};open.then((result=>{this.pending==pending&&(this.pending=null,result&&this.view.dispatch({effects:this.setHover.of(result)}))}),(e=>logException(this.view.state,e,"hover tooltip")))}else open&&this.view.dispatch({effects:this.setHover.of(open)})}mousemove(event){var _a;this.lastMove={x:event.clientX,y:event.clientY,target:event.target,time:Date.now()},this.hoverTimeout<0&&(this.hoverTimeout=setTimeout(this.checkHover,this.hoverTime));let tooltip=this.active;if(tooltip&&!isInTooltip(this.lastMove.target)||this.pending){let{pos:pos}=tooltip||this.pending,end=null!==(_a=null==tooltip?void 0:tooltip.end)&&void 0!==_a?_a:pos;(pos==end?this.view.posAtCoords(this.lastMove)==pos:function(view,from,to,x,y,margin){let range=document.createRange(),fromDOM=view.domAtPos(from),toDOM=view.domAtPos(to);range.setEnd(toDOM.node,toDOM.offset),range.setStart(fromDOM.node,fromDOM.offset);let rects=range.getClientRects();range.detach();for(let i=0;i<rects.length;i++){let rect=rects[i];if(Math.max(rect.top-y,y-rect.bottom,rect.left-x,x-rect.right)<=margin)return!0}return!1}(this.view,pos,end,event.clientX,event.clientY,6))||(this.view.dispatch({effects:this.setHover.of(null)}),this.pending=null)}}mouseleave(e){clearTimeout(this.hoverTimeout),this.hoverTimeout=-1,this.active&&!isInTooltip(e.relatedTarget)&&this.view.dispatch({effects:this.setHover.of(null)})}destroy(){clearTimeout(this.hoverTimeout),this.view.dom.removeEventListener("mouseleave",this.mouseleave),this.view.dom.removeEventListener("mousemove",this.mousemove)}}function isInTooltip(elt){for(let cur=elt;cur;cur=cur.parentNode)if(1==cur.nodeType&&cur.classList.contains("cm-tooltip"))return!0;return!1}const closeHoverTooltipEffect=state.StateEffect.define(),closeHoverTooltips=closeHoverTooltipEffect.of(null);const panelConfig=state.Facet.define({combine(configs){let topContainer,bottomContainer;for(let c of configs)topContainer=topContainer||c.topContainer,bottomContainer=bottomContainer||c.bottomContainer;return{topContainer:topContainer,bottomContainer:bottomContainer}}});const panelPlugin=ViewPlugin.fromClass(class{constructor(view){this.input=view.state.facet(showPanel),this.specs=this.input.filter((s=>s)),this.panels=this.specs.map((spec=>spec(view)));let conf=view.state.facet(panelConfig);this.top=new PanelGroup(view,!0,conf.topContainer),this.bottom=new PanelGroup(view,!1,conf.bottomContainer),this.top.sync(this.panels.filter((p=>p.top))),this.bottom.sync(this.panels.filter((p=>!p.top)));for(let p of this.panels)p.dom.classList.add("cm-panel"),p.mount&&p.mount()}update(update){let conf=update.state.facet(panelConfig);this.top.container!=conf.topContainer&&(this.top.sync([]),this.top=new PanelGroup(update.view,!0,conf.topContainer)),this.bottom.container!=conf.bottomContainer&&(this.bottom.sync([]),this.bottom=new PanelGroup(update.view,!1,conf.bottomContainer)),this.top.syncClasses(),this.bottom.syncClasses();let input=update.state.facet(showPanel);if(input!=this.input){let specs=input.filter((x=>x)),panels=[],top=[],bottom=[],mount=[];for(let spec of specs){let panel,known=this.specs.indexOf(spec);known<0?(panel=spec(update.view),mount.push(panel)):(panel=this.panels[known],panel.update&&panel.update(update)),panels.push(panel),(panel.top?top:bottom).push(panel)}this.specs=specs,this.panels=panels,this.top.sync(top),this.bottom.sync(bottom);for(let p of mount)p.dom.classList.add("cm-panel"),p.mount&&p.mount()}else for(let p of this.panels)p.update&&p.update(update)}destroy(){this.top.sync([]),this.bottom.sync([])}},{provide:plugin=>EditorView.scrollMargins.of((view=>{let value=view.plugin(plugin);return value&&{top:value.top.scrollMargin(),bottom:value.bottom.scrollMargin()}}))});class PanelGroup{constructor(view,top,container){this.view=view,this.top=top,this.container=container,this.dom=void 0,this.classes="",this.panels=[],this.syncClasses()}sync(panels){for(let p of this.panels)p.destroy&&panels.indexOf(p)<0&&p.destroy();this.panels=panels,this.syncDOM()}syncDOM(){if(0==this.panels.length)return void(this.dom&&(this.dom.remove(),this.dom=void 0));if(!this.dom){this.dom=document.createElement("div"),this.dom.className=this.top?"cm-panels cm-panels-top":"cm-panels cm-panels-bottom",this.dom.style[this.top?"top":"bottom"]="0";let parent=this.container||this.view.dom;parent.insertBefore(this.dom,this.top?parent.firstChild:null)}let curDOM=this.dom.firstChild;for(let panel of this.panels)if(panel.dom.parentNode==this.dom){for(;curDOM!=panel.dom;)curDOM=rm(curDOM);curDOM=curDOM.nextSibling}else this.dom.insertBefore(panel.dom,curDOM);for(;curDOM;)curDOM=rm(curDOM)}scrollMargin(){return!this.dom||this.container?0:Math.max(0,this.top?this.dom.getBoundingClientRect().bottom-Math.max(0,this.view.scrollDOM.getBoundingClientRect().top):Math.min(innerHeight,this.view.scrollDOM.getBoundingClientRect().bottom)-this.dom.getBoundingClientRect().top)}syncClasses(){if(this.container&&this.classes!=this.view.themeClasses){for(let cls of this.classes.split(" "))cls&&this.container.classList.remove(cls);for(let cls of(this.classes=this.view.themeClasses).split(" "))cls&&this.container.classList.add(cls)}}}function rm(node){let next=node.nextSibling;return node.remove(),next}const showPanel=state.Facet.define({enables:panelPlugin});class GutterMarker extends state.RangeValue{compare(other){return this==other||this.constructor==other.constructor&&this.eq(other)}eq(other){return!1}destroy(dom){}}GutterMarker.prototype.elementClass="",GutterMarker.prototype.toDOM=void 0,GutterMarker.prototype.mapMode=state.MapMode.TrackBefore,GutterMarker.prototype.startSide=GutterMarker.prototype.endSide=-1,GutterMarker.prototype.point=!0;const gutterLineClass=state.Facet.define(),defaults={class:"",renderEmptyElements:!1,elementStyle:"",markers:()=>state.RangeSet.empty,lineMarker:()=>null,lineMarkerChange:null,initialSpacer:null,updateSpacer:null,domEventHandlers:{}},activeGutters=state.Facet.define();const unfixGutters=state.Facet.define({combine:values=>values.some((x=>x))});function gutters(config){let result=[gutterView];return config&&!1===config.fixed&&result.push(unfixGutters.of(!0)),result}const gutterView=ViewPlugin.fromClass(class{constructor(view){this.view=view,this.prevViewport=view.viewport,this.dom=document.createElement("div"),this.dom.className="cm-gutters",this.dom.setAttribute("aria-hidden","true"),this.dom.style.minHeight=this.view.contentHeight+"px",this.gutters=view.state.facet(activeGutters).map((conf=>new SingleGutterView(view,conf)));for(let gutter of this.gutters)this.dom.appendChild(gutter.dom);this.fixed=!view.state.facet(unfixGutters),this.fixed&&(this.dom.style.position="sticky"),this.syncGutters(!1),view.scrollDOM.insertBefore(this.dom,view.contentDOM)}update(update){if(this.updateGutters(update)){let vpA=this.prevViewport,vpB=update.view.viewport,vpOverlap=Math.min(vpA.to,vpB.to)-Math.max(vpA.from,vpB.from);this.syncGutters(vpOverlap<.8*(vpB.to-vpB.from))}update.geometryChanged&&(this.dom.style.minHeight=this.view.contentHeight+"px"),this.view.state.facet(unfixGutters)!=!this.fixed&&(this.fixed=!this.fixed,this.dom.style.position=this.fixed?"sticky":""),this.prevViewport=update.view.viewport}syncGutters(detach){let after=this.dom.nextSibling;detach&&this.dom.remove();let lineClasses=state.RangeSet.iter(this.view.state.facet(gutterLineClass),this.view.viewport.from),classSet=[],contexts=this.gutters.map((gutter=>new UpdateContext(gutter,this.view.viewport,-this.view.documentPadding.top)));for(let line of this.view.viewportLineBlocks){let text;if(Array.isArray(line.type)){for(let b of line.type)if(b.type==exports.BlockType.Text){text=b;break}}else text=line.type==exports.BlockType.Text?line:void 0;if(text){classSet.length&&(classSet=[]),advanceCursor(lineClasses,classSet,line.from);for(let cx of contexts)cx.line(this.view,text,classSet)}}for(let cx of contexts)cx.finish();detach&&this.view.scrollDOM.insertBefore(this.dom,after)}updateGutters(update){let prev=update.startState.facet(activeGutters),cur=update.state.facet(activeGutters),change=update.docChanged||update.heightChanged||update.viewportChanged||!state.RangeSet.eq(update.startState.facet(gutterLineClass),update.state.facet(gutterLineClass),update.view.viewport.from,update.view.viewport.to);if(prev==cur)for(let gutter of this.gutters)gutter.update(update)&&(change=!0);else{change=!0;let gutters=[];for(let conf of cur){let known=prev.indexOf(conf);known<0?gutters.push(new SingleGutterView(this.view,conf)):(this.gutters[known].update(update),gutters.push(this.gutters[known]))}for(let g of this.gutters)g.dom.remove(),gutters.indexOf(g)<0&&g.destroy();for(let g of gutters)this.dom.appendChild(g.dom);this.gutters=gutters}return change}destroy(){for(let view of this.gutters)view.destroy();this.dom.remove()}},{provide:plugin=>EditorView.scrollMargins.of((view=>{let value=view.plugin(plugin);return value&&0!=value.gutters.length&&value.fixed?view.textDirection==exports.Direction.LTR?{left:value.dom.offsetWidth}:{right:value.dom.offsetWidth}:null}))});function asArray(val){return Array.isArray(val)?val:[val]}function advanceCursor(cursor,collect,pos){for(;cursor.value&&cursor.from<=pos;)cursor.from==pos&&collect.push(cursor.value),cursor.next()}class UpdateContext{constructor(gutter,viewport,height){this.gutter=gutter,this.height=height,this.i=0,this.cursor=state.RangeSet.iter(gutter.markers,viewport.from)}line(view,line,extraMarkers){let localMarkers=[];advanceCursor(this.cursor,localMarkers,line.from),extraMarkers.length&&(localMarkers=localMarkers.concat(extraMarkers));let forLine=this.gutter.config.lineMarker(view,line,localMarkers);forLine&&localMarkers.unshift(forLine);let gutter=this.gutter;if(0==localMarkers.length&&!gutter.config.renderEmptyElements)return;let above=line.top-this.height;if(this.i==gutter.elements.length){let newElt=new GutterElement(view,line.height,above,localMarkers);gutter.elements.push(newElt),gutter.dom.appendChild(newElt.dom)}else gutter.elements[this.i].update(view,line.height,above,localMarkers);this.height=line.bottom,this.i++}finish(){let gutter=this.gutter;for(;gutter.elements.length>this.i;){let last=gutter.elements.pop();gutter.dom.removeChild(last.dom),last.destroy()}}}class SingleGutterView{constructor(view,config){this.view=view,this.config=config,this.elements=[],this.spacer=null,this.dom=document.createElement("div"),this.dom.className="cm-gutter"+(this.config.class?" "+this.config.class:"");for(let prop in config.domEventHandlers)this.dom.addEventListener(prop,(event=>{let y,target=event.target;if(target!=this.dom&&this.dom.contains(target)){for(;target.parentNode!=this.dom;)target=target.parentNode;let rect=target.getBoundingClientRect();y=(rect.top+rect.bottom)/2}else y=event.clientY;let line=view.lineBlockAtHeight(y-view.documentTop);config.domEventHandlers[prop](view,line,event)&&event.preventDefault()}));this.markers=asArray(config.markers(view)),config.initialSpacer&&(this.spacer=new GutterElement(view,0,0,[config.initialSpacer(view)]),this.dom.appendChild(this.spacer.dom),this.spacer.dom.style.cssText+="visibility: hidden; pointer-events: none")}update(update){let prevMarkers=this.markers;if(this.markers=asArray(this.config.markers(update.view)),this.spacer&&this.config.updateSpacer){let updated=this.config.updateSpacer(this.spacer.markers[0],update);updated!=this.spacer.markers[0]&&this.spacer.update(update.view,0,0,[updated])}let vp=update.view.viewport;return!state.RangeSet.eq(this.markers,prevMarkers,vp.from,vp.to)||!!this.config.lineMarkerChange&&this.config.lineMarkerChange(update)}destroy(){for(let elt of this.elements)elt.destroy()}}class GutterElement{constructor(view,height,above,markers){this.height=-1,this.above=0,this.markers=[],this.dom=document.createElement("div"),this.dom.className="cm-gutterElement",this.update(view,height,above,markers)}update(view,height,above,markers){this.height!=height&&(this.dom.style.height=(this.height=height)+"px"),this.above!=above&&(this.dom.style.marginTop=(this.above=above)?above+"px":""),function(a,b){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!a[i].compare(b[i]))return!1;return!0}(this.markers,markers)||this.setMarkers(view,markers)}setMarkers(view,markers){let cls="cm-gutterElement",domPos=this.dom.firstChild;for(let iNew=0,iOld=0;;){let skipTo=iOld,marker=iNew<markers.length?markers[iNew++]:null,matched=!1;if(marker){let c=marker.elementClass;c&&(cls+=" "+c);for(let i=iOld;i<this.markers.length;i++)if(this.markers[i].compare(marker)){skipTo=i,matched=!0;break}}else skipTo=this.markers.length;for(;iOld<skipTo;){let next=this.markers[iOld++];if(next.toDOM){next.destroy(domPos);let after=domPos.nextSibling;domPos.remove(),domPos=after}}if(!marker)break;marker.toDOM&&(matched?domPos=domPos.nextSibling:this.dom.insertBefore(marker.toDOM(view),domPos)),matched&&iOld++}this.dom.className=cls,this.markers=markers}destroy(){this.setMarkers(null,[])}}const lineNumberMarkers=state.Facet.define(),lineNumberConfig=state.Facet.define({combine:values=>state.combineConfig(values,{formatNumber:String,domEventHandlers:{}},{domEventHandlers(a,b){let result=Object.assign({},a);for(let event in b){let exists=result[event],add=b[event];result[event]=exists?(view,line,event)=>exists(view,line,event)||add(view,line,event):add}return result}})});class NumberMarker extends GutterMarker{constructor(number){super(),this.number=number}eq(other){return this.number==other.number}toDOM(){return document.createTextNode(this.number)}}function formatNumber(view,number){return view.state.facet(lineNumberConfig).formatNumber(number,view.state)}const lineNumberGutter=activeGutters.compute([lineNumberConfig],(state=>({class:"cm-lineNumbers",renderEmptyElements:!1,markers:view=>view.state.facet(lineNumberMarkers),lineMarker:(view,line,others)=>others.some((m=>m.toDOM))?null:new NumberMarker(formatNumber(view,view.state.doc.lineAt(line.from).number)),lineMarkerChange:update=>update.startState.facet(lineNumberConfig)!=update.state.facet(lineNumberConfig),initialSpacer:view=>new NumberMarker(formatNumber(view,maxLineNumber(view.state.doc.lines))),updateSpacer(spacer,update){let max=formatNumber(update.view,maxLineNumber(update.view.state.doc.lines));return max==spacer.number?spacer:new NumberMarker(max)},domEventHandlers:state.facet(lineNumberConfig).domEventHandlers})));function maxLineNumber(lines){let last=9;for(;last<lines;)last=10*last+9;return last}const activeLineGutterMarker=new class extends GutterMarker{constructor(){super(...arguments),this.elementClass="cm-activeLineGutter"}},activeLineGutterHighlighter=gutterLineClass.compute(["selection"],(state$1=>{let marks=[],last=-1;for(let range of state$1.selection.ranges){let linePos=state$1.doc.lineAt(range.head).from;linePos>last&&(last=linePos,marks.push(activeLineGutterMarker.range(linePos)))}return state.RangeSet.of(marks)}));const WhitespaceDeco=new Map;function matcher(decorator){return ViewPlugin.define((view=>({decorations:decorator.createDeco(view),update(u){this.decorations=decorator.updateDeco(u,this.decorations)}})),{decorations:v=>v.decorations})}const whitespaceHighlighter=matcher(new MatchDecorator({regexp:/\t| +/g,decoration:match=>function(space){let deco=WhitespaceDeco.get(space);return deco||WhitespaceDeco.set(space,deco=Decoration.mark({attributes:"\t"===space?{class:"cm-highlightTab"}:{class:"cm-highlightSpace","data-display":space.replace(/ /g,"")}})),deco}(match[0]),boundary:/\S/}));const trailingHighlighter=matcher(new MatchDecorator({regexp:/\s+$/g,decoration:Decoration.mark({class:"cm-trailingSpace"}),boundary:/\S/}));const __test={HeightMap:HeightMap,HeightOracle:HeightOracle,MeasuredHeights:MeasuredHeights,QueryType:QueryType,ChangedRange:ChangedRange,computeOrder:computeOrder,moveVisually:moveVisually};exports.BidiSpan=BidiSpan,exports.BlockInfo=BlockInfo,exports.Decoration=Decoration,exports.EditorView=EditorView,exports.GutterMarker=GutterMarker,exports.MatchDecorator=MatchDecorator,exports.RectangleMarker=RectangleMarker,exports.ViewPlugin=ViewPlugin,exports.ViewUpdate=ViewUpdate,exports.WidgetType=WidgetType,exports.__test=__test,exports.closeHoverTooltips=closeHoverTooltips,exports.crosshairCursor=function(options={}){let[code,getter]=keys[options.key||"Alt"],plugin=ViewPlugin.fromClass(class{constructor(view){this.view=view,this.isDown=!1}set(isDown){this.isDown!=isDown&&(this.isDown=isDown,this.view.update([]))}},{eventHandlers:{keydown(e){this.set(e.keyCode==code||getter(e))},keyup(e){e.keyCode!=code&&getter(e)||this.set(!1)},mousemove(e){this.set(getter(e))}}});return[plugin,EditorView.contentAttributes.of((view=>{var _a;return(null===(_a=view.plugin(plugin))||void 0===_a?void 0:_a.isDown)?showCrosshair:null}))]},exports.drawSelection=function(config={}){return[selectionConfig.of(config),cursorLayer,selectionLayer,hideNativeSelection,nativeSelectionHidden.of(!0)]},exports.dropCursor=function(){return[dropCursorPos,drawDropCursor]},exports.getPanel=function(view,panel){let plugin=view.plugin(panelPlugin),index=plugin?plugin.specs.indexOf(panel):-1;return index>-1?plugin.panels[index]:null},exports.getTooltip=function(view,tooltip){let plugin=view.plugin(tooltipPlugin);if(!plugin)return null;let found=plugin.manager.tooltips.indexOf(tooltip);return found<0?null:plugin.manager.tooltipViews[found]},exports.gutter=function(config){return[gutters(),activeGutters.of(Object.assign(Object.assign({},defaults),config))]},exports.gutterLineClass=gutterLineClass,exports.gutters=gutters,exports.hasHoverTooltips=function(state){return state.facet(showHoverTooltip).some((x=>x))},exports.highlightActiveLine=function(){return activeLineHighlighter},exports.highlightActiveLineGutter=function(){return activeLineGutterHighlighter},exports.highlightSpecialChars=function(config={}){return[specialCharConfig.of(config),_plugin||(_plugin=ViewPlugin.fromClass(class{constructor(view){this.view=view,this.decorations=Decoration.none,this.decorationCache=Object.create(null),this.decorator=this.makeDecorator(view.state.facet(specialCharConfig)),this.decorations=this.decorator.createDeco(view)}makeDecorator(conf){return new MatchDecorator({regexp:conf.specialChars,decoration:(m,view,pos)=>{let{doc:doc}=view.state,code=state.codePointAt(m[0],0);if(9==code){let line=doc.lineAt(pos),size=view.state.tabSize,col=state.countColumn(line.text,size,pos-line.from);return Decoration.replace({widget:new TabWidget((size-col%size)*this.view.defaultCharacterWidth)})}return this.decorationCache[code]||(this.decorationCache[code]=Decoration.replace({widget:new SpecialCharWidget(conf,code)}))},boundary:conf.replaceTabs?void 0:/[^]/})}update(update){let conf=update.state.facet(specialCharConfig);update.startState.facet(specialCharConfig)!=conf?(this.decorator=this.makeDecorator(conf),this.decorations=this.decorator.createDeco(update.view)):this.decorations=this.decorator.updateDeco(update,this.decorations)}},{decorations:v=>v.decorations}))]},exports.highlightTrailingWhitespace=function(){return trailingHighlighter},exports.highlightWhitespace=function(){return whitespaceHighlighter},exports.hoverTooltip=function(source,options={}){let setHover=state.StateEffect.define(),hoverState=state.StateField.define({create:()=>null,update(value,tr){if(value&&(options.hideOnChange&&(tr.docChanged||tr.selection)||options.hideOn&&options.hideOn(tr,value)))return null;if(value&&tr.docChanged){let newPos=tr.changes.mapPos(value.pos,-1,state.MapMode.TrackDel);if(null==newPos)return null;let copy=Object.assign(Object.create(null),value);copy.pos=newPos,null!=value.end&&(copy.end=tr.changes.mapPos(value.end)),value=copy}for(let effect of tr.effects)effect.is(setHover)&&(value=effect.value),effect.is(closeHoverTooltipEffect)&&(value=null);return value},provide:f=>showHoverTooltip.from(f)});return[hoverState,ViewPlugin.define((view=>new HoverPlugin(view,source,hoverState,setHover,options.hoverTime||300))),showHoverTooltipHost]},exports.keymap=keymap,exports.layer=layer,exports.lineNumberMarkers=lineNumberMarkers,exports.lineNumbers=function(config={}){return[lineNumberConfig.of(config),gutters(),lineNumberGutter]},exports.logException=logException,exports.panels=function(config){return config?[panelConfig.of(config)]:[]},exports.placeholder=function(content){return ViewPlugin.fromClass(class{constructor(view){this.view=view,this.placeholder=Decoration.set([Decoration.widget({widget:new Placeholder(content),side:1}).range(0)])}get decorations(){return this.view.state.doc.length?Decoration.none:this.placeholder}},{decorations:v=>v.decorations})},exports.rectangularSelection=function(options){let filter=(null==options?void 0:options.eventFilter)||(e=>e.altKey&&0==e.button);return EditorView.mouseSelectionStyle.of(((view,event)=>filter(event)?rectangleSelectionStyle(view,event):null))},exports.repositionTooltips=function(view){var _a;null===(_a=view.plugin(tooltipPlugin))||void 0===_a||_a.maybeMeasure()},exports.runScopeHandlers=function(view,event,scope){return runHandlers(getKeymap(view.state),event,view,scope)},exports.scrollPastEnd=function(){return[plugin,contentAttributes.of((view=>{var _a;return(null===(_a=view.plugin(plugin))||void 0===_a?void 0:_a.attrs)||null}))]},exports.showPanel=showPanel,exports.showTooltip=showTooltip,exports.tooltips=function(config={}){return tooltipConfig.of(config)}},{"@codemirror/state":11,"style-mod":17,"w3c-keyname":18}],13:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const DefaultBufferLength=1024;let nextPropID=0;class Range{constructor(from,to){this.from=from,this.to=to}}class NodeProp{constructor(config={}){this.id=nextPropID++,this.perNode=!!config.perNode,this.deserialize=config.deserialize||(()=>{throw new Error("This node type doesn't define a deserialize function")})}add(match){if(this.perNode)throw new RangeError("Can't add per-node props to node types");return"function"!=typeof match&&(match=NodeType.match(match)),type=>{let result=match(type);return void 0===result?null:[this,result]}}}NodeProp.closedBy=new NodeProp({deserialize:str=>str.split(" ")}),NodeProp.openedBy=new NodeProp({deserialize:str=>str.split(" ")}),NodeProp.group=new NodeProp({deserialize:str=>str.split(" ")}),NodeProp.contextHash=new NodeProp({perNode:!0}),NodeProp.lookAhead=new NodeProp({perNode:!0}),NodeProp.mounted=new NodeProp({perNode:!0});class MountedTree{constructor(tree,overlay,parser){this.tree=tree,this.overlay=overlay,this.parser=parser}}const noProps=Object.create(null);class NodeType{constructor(name,props,id,flags=0){this.name=name,this.props=props,this.id=id,this.flags=flags}static define(spec){let props=spec.props&&spec.props.length?Object.create(null):noProps,flags=(spec.top?1:0)|(spec.skipped?2:0)|(spec.error?4:0)|(null==spec.name?8:0),type=new NodeType(spec.name||"",props,spec.id,flags);if(spec.props)for(let src of spec.props)if(Array.isArray(src)||(src=src(type)),src){if(src[0].perNode)throw new RangeError("Can't store a per-node prop on a node type");props[src[0].id]=src[1]}return type}prop(prop){return this.props[prop.id]}get isTop(){return(1&this.flags)>0}get isSkipped(){return(2&this.flags)>0}get isError(){return(4&this.flags)>0}get isAnonymous(){return(8&this.flags)>0}is(name){if("string"==typeof name){if(this.name==name)return!0;let group=this.prop(NodeProp.group);return!!group&&group.indexOf(name)>-1}return this.id==name}static match(map){let direct=Object.create(null);for(let prop in map)for(let name of prop.split(" "))direct[name]=map[prop];return node=>{for(let groups=node.prop(NodeProp.group),i=-1;i<(groups?groups.length:0);i++){let found=direct[i<0?node.name:groups[i]];if(found)return found}}}}NodeType.none=new NodeType("",Object.create(null),0,8);class NodeSet{constructor(types){this.types=types;for(let i=0;i<types.length;i++)if(types[i].id!=i)throw new RangeError("Node type ids should correspond to array positions when creating a node set")}extend(...props){let newTypes=[];for(let type of this.types){let newProps=null;for(let source of props){let add=source(type);add&&(newProps||(newProps=Object.assign({},type.props)),newProps[add[0].id]=add[1])}newTypes.push(newProps?new NodeType(type.name,newProps,type.id,type.flags):type)}return new NodeSet(newTypes)}}const CachedNode=new WeakMap,CachedInnerNode=new WeakMap;var IterMode;exports.IterMode=void 0,(IterMode=exports.IterMode||(exports.IterMode={}))[IterMode.ExcludeBuffers=1]="ExcludeBuffers",IterMode[IterMode.IncludeAnonymous=2]="IncludeAnonymous",IterMode[IterMode.IgnoreMounts=4]="IgnoreMounts",IterMode[IterMode.IgnoreOverlays=8]="IgnoreOverlays";class Tree{constructor(type,children,positions,length,props){if(this.type=type,this.children=children,this.positions=positions,this.length=length,this.props=null,props&&props.length){this.props=Object.create(null);for(let[prop,value]of props)this.props["number"==typeof prop?prop:prop.id]=value}}toString(){let mounted=this.prop(NodeProp.mounted);if(mounted&&!mounted.overlay)return mounted.tree.toString();let children="";for(let ch of this.children){let str=ch.toString();str&&(children&&(children+=","),children+=str)}return this.type.name?(/\W/.test(this.type.name)&&!this.type.isError?JSON.stringify(this.type.name):this.type.name)+(children.length?"("+children+")":""):children}cursor(mode=0){return new TreeCursor(this.topNode,mode)}cursorAt(pos,side=0,mode=0){let scope=CachedNode.get(this)||this.topNode,cursor=new TreeCursor(scope);return cursor.moveTo(pos,side),CachedNode.set(this,cursor._tree),cursor}get topNode(){return new TreeNode(this,0,0,null)}resolve(pos,side=0){let node=resolveNode(CachedNode.get(this)||this.topNode,pos,side,!1);return CachedNode.set(this,node),node}resolveInner(pos,side=0){let node=resolveNode(CachedInnerNode.get(this)||this.topNode,pos,side,!0);return CachedInnerNode.set(this,node),node}iterate(spec){let{enter:enter,leave:leave,from:from=0,to:to=this.length}=spec;for(let c=this.cursor((spec.mode||0)|exports.IterMode.IncludeAnonymous);;){let entered=!1;if(c.from<=to&&c.to>=from&&(c.type.isAnonymous||!1!==enter(c))){if(c.firstChild())continue;entered=!0}for(;entered&&leave&&!c.type.isAnonymous&&leave(c),!c.nextSibling();){if(!c.parent())return;entered=!0}}}prop(prop){return prop.perNode?this.props?this.props[prop.id]:void 0:this.type.prop(prop)}get propValues(){let result=[];if(this.props)for(let id in this.props)result.push([+id,this.props[id]]);return result}balance(config={}){return this.children.length<=8?this:balanceRange(NodeType.none,this.children,this.positions,0,this.children.length,0,this.length,((children,positions,length)=>new Tree(this.type,children,positions,length,this.propValues)),config.makeTree||((children,positions,length)=>new Tree(NodeType.none,children,positions,length)))}static build(data){return function(data){var _a;let{buffer:buffer,nodeSet:nodeSet,maxBufferLength:maxBufferLength=DefaultBufferLength,reused:reused=[],minRepeatType:minRepeatType=nodeSet.types.length}=data,cursor=Array.isArray(buffer)?new FlatBufferCursor(buffer,buffer.length):buffer,types=nodeSet.types,contextHash=0,lookAhead=0;function takeNode(parentStart,minPos,children,positions,inRepeat){let{id:id,start:start,end:end,size:size}=cursor,lookAheadAtStart=lookAhead;for(;size<0;){if(cursor.next(),-1==size){let node=reused[id];return children.push(node),void positions.push(start-parentStart)}if(-3==size)return void(contextHash=id);if(-4==size)return void(lookAhead=id);throw new RangeError(`Unrecognized record size: ${size}`)}let node,buffer,type=types[id],startPos=start-parentStart;if(end-start<=maxBufferLength&&(buffer=findBufferSize(cursor.pos-minPos,inRepeat))){let data=new Uint16Array(buffer.size-buffer.skip),endPos=cursor.pos-buffer.size,index=data.length;for(;cursor.pos>endPos;)index=copyToBuffer(buffer.start,data,index);node=new TreeBuffer(data,end-buffer.start,nodeSet),startPos=buffer.start-parentStart}else{let endPos=cursor.pos-size;cursor.next();let localChildren=[],localPositions=[],localInRepeat=id>=minRepeatType?id:-1,lastGroup=0,lastEnd=end;for(;cursor.pos>endPos;)localInRepeat>=0&&cursor.id==localInRepeat&&cursor.size>=0?(cursor.end<=lastEnd-maxBufferLength&&(makeRepeatLeaf(localChildren,localPositions,start,lastGroup,cursor.end,lastEnd,localInRepeat,lookAheadAtStart),lastGroup=localChildren.length,lastEnd=cursor.end),cursor.next()):takeNode(start,endPos,localChildren,localPositions,localInRepeat);if(localInRepeat>=0&&lastGroup>0&&lastGroup<localChildren.length&&makeRepeatLeaf(localChildren,localPositions,start,lastGroup,start,lastEnd,localInRepeat,lookAheadAtStart),localChildren.reverse(),localPositions.reverse(),localInRepeat>-1&&lastGroup>0){let make=makeBalanced(type);node=balanceRange(type,localChildren,localPositions,0,localChildren.length,0,end-start,make,make)}else node=makeTree(type,localChildren,localPositions,end-start,lookAheadAtStart-end)}children.push(node),positions.push(startPos)}function makeBalanced(type){return(children,positions,length)=>{let last,lookAheadProp,lookAhead=0,lastI=children.length-1;if(lastI>=0&&(last=children[lastI])instanceof Tree){if(!lastI&&last.type==type&&last.length==length)return last;(lookAheadProp=last.prop(NodeProp.lookAhead))&&(lookAhead=positions[lastI]+last.length+lookAheadProp)}return makeTree(type,children,positions,length,lookAhead)}}function makeRepeatLeaf(children,positions,base,i,from,to,type,lookAhead){let localChildren=[],localPositions=[];for(;children.length>i;)localChildren.push(children.pop()),localPositions.push(positions.pop()+base-from);children.push(makeTree(nodeSet.types[type],localChildren,localPositions,to-from,lookAhead-to)),positions.push(from-base)}function makeTree(type,children,positions,length,lookAhead=0,props){if(contextHash){let pair=[NodeProp.contextHash,contextHash];props=props?[pair].concat(props):[pair]}if(lookAhead>25){let pair=[NodeProp.lookAhead,lookAhead];props=props?[pair].concat(props):[pair]}return new Tree(type,children,positions,length,props)}function findBufferSize(maxSize,inRepeat){let fork=cursor.fork(),size=0,start=0,skip=0,minStart=fork.end-maxBufferLength,result={size:0,start:0,skip:0};scan:for(let minPos=fork.pos-maxSize;fork.pos>minPos;){let nodeSize=fork.size;if(fork.id==inRepeat&&nodeSize>=0){result.size=size,result.start=start,result.skip=skip,skip+=4,size+=4,fork.next();continue}let startPos=fork.pos-nodeSize;if(nodeSize<0||startPos<minPos||fork.start<minStart)break;let localSkipped=fork.id>=minRepeatType?4:0,nodeStart=fork.start;for(fork.next();fork.pos>startPos;){if(fork.size<0){if(-3!=fork.size)break scan;localSkipped+=4}else fork.id>=minRepeatType&&(localSkipped+=4);fork.next()}start=nodeStart,size+=nodeSize,skip+=localSkipped}return(inRepeat<0||size==maxSize)&&(result.size=size,result.start=start,result.skip=skip),result.size>4?result:void 0}function copyToBuffer(bufferStart,buffer,index){let{id:id,start:start,end:end,size:size}=cursor;if(cursor.next(),size>=0&&id<minRepeatType){let startIndex=index;if(size>4){let endPos=cursor.pos-(size-4);for(;cursor.pos>endPos;)index=copyToBuffer(bufferStart,buffer,index)}buffer[--index]=startIndex,buffer[--index]=end-bufferStart,buffer[--index]=start-bufferStart,buffer[--index]=id}else-3==size?contextHash=id:-4==size&&(lookAhead=id);return index}let children=[],positions=[];for(;cursor.pos>0;)takeNode(data.start||0,data.bufferStart||0,children,positions,-1);let length=null!==(_a=data.length)&&void 0!==_a?_a:children.length?positions[0]+children[0].length:0;return new Tree(types[data.topID],children.reverse(),positions.reverse(),length)}(data)}}Tree.empty=new Tree(NodeType.none,[],[],0);class FlatBufferCursor{constructor(buffer,index){this.buffer=buffer,this.index=index}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}get pos(){return this.index}next(){this.index-=4}fork(){return new FlatBufferCursor(this.buffer,this.index)}}class TreeBuffer{constructor(buffer,length,set){this.buffer=buffer,this.length=length,this.set=set}get type(){return NodeType.none}toString(){let result=[];for(let index=0;index<this.buffer.length;)result.push(this.childString(index)),index=this.buffer[index+3];return result.join(",")}childString(index){let id=this.buffer[index],endIndex=this.buffer[index+3],type=this.set.types[id],result=type.name;if(/\W/.test(result)&&!type.isError&&(result=JSON.stringify(result)),endIndex==(index+=4))return result;let children=[];for(;index<endIndex;)children.push(this.childString(index)),index=this.buffer[index+3];return result+"("+children.join(",")+")"}findChild(startIndex,endIndex,dir,pos,side){let{buffer:buffer}=this,pick=-1;for(let i=startIndex;i!=endIndex&&!(checkSide(side,pos,buffer[i+1],buffer[i+2])&&(pick=i,dir>0));i=buffer[i+3]);return pick}slice(startI,endI,from){let b=this.buffer,copy=new Uint16Array(endI-startI),len=0;for(let i=startI,j=0;i<endI;){copy[j++]=b[i++],copy[j++]=b[i++]-from;let to=copy[j++]=b[i++]-from;copy[j++]=b[i++]-startI,len=Math.max(len,to)}return new TreeBuffer(copy,len,this.set)}}function checkSide(side,pos,from,to){switch(side){case-2:return from<pos;case-1:return to>=pos&&from<pos;case 0:return from<pos&&to>pos;case 1:return from<=pos&&to>pos;case 2:return to>pos;case 4:return!0}}function enterUnfinishedNodesBefore(node,pos){let scan=node.childBefore(pos);for(;scan;){let last=scan.lastChild;if(!last||last.to!=scan.to)break;last.type.isError&&last.from==last.to?(node=scan,scan=last.prevSibling):scan=last}return node}function resolveNode(node,pos,side,overlays){for(var _a;node.from==node.to||(side<1?node.from>=pos:node.from>pos)||(side>-1?node.to<=pos:node.to<pos);){let parent=!overlays&&node instanceof TreeNode&&node.index<0?null:node.parent;if(!parent)return node;node=parent}let mode=overlays?0:exports.IterMode.IgnoreOverlays;if(overlays)for(let scan=node,parent=scan.parent;parent;scan=parent,parent=scan.parent)scan instanceof TreeNode&&scan.index<0&&(null===(_a=parent.enter(pos,side,mode))||void 0===_a?void 0:_a.from)!=scan.from&&(node=parent);for(;;){let inner=node.enter(pos,side,mode);if(!inner)return node;node=inner}}class TreeNode{constructor(_tree,from,index,_parent){this._tree=_tree,this.from=from,this.index=index,this._parent=_parent}get type(){return this._tree.type}get name(){return this._tree.type.name}get to(){return this.from+this._tree.length}nextChild(i,dir,pos,side,mode=0){for(let parent=this;;){for(let{children:children,positions:positions}=parent._tree,e=dir>0?children.length:-1;i!=e;i+=dir){let next=children[i],start=positions[i]+parent.from;if(checkSide(side,pos,start,start+next.length))if(next instanceof TreeBuffer){if(mode&exports.IterMode.ExcludeBuffers)continue;let index=next.findChild(0,next.buffer.length,dir,pos-start,side);if(index>-1)return new BufferNode(new BufferContext(parent,next,i,start),null,index)}else if(mode&exports.IterMode.IncludeAnonymous||!next.type.isAnonymous||hasChild(next)){let mounted;if(!(mode&exports.IterMode.IgnoreMounts)&&next.props&&(mounted=next.prop(NodeProp.mounted))&&!mounted.overlay)return new TreeNode(mounted.tree,start,i,parent);let inner=new TreeNode(next,start,i,parent);return mode&exports.IterMode.IncludeAnonymous||!inner.type.isAnonymous?inner:inner.nextChild(dir<0?next.children.length-1:0,dir,pos,side)}}if(mode&exports.IterMode.IncludeAnonymous||!parent.type.isAnonymous)return null;if(i=parent.index>=0?parent.index+dir:dir<0?-1:parent._parent._tree.children.length,parent=parent._parent,!parent)return null}}get firstChild(){return this.nextChild(0,1,0,4)}get lastChild(){return this.nextChild(this._tree.children.length-1,-1,0,4)}childAfter(pos){return this.nextChild(0,1,pos,2)}childBefore(pos){return this.nextChild(this._tree.children.length-1,-1,pos,-2)}enter(pos,side,mode=0){let mounted;if(!(mode&exports.IterMode.IgnoreOverlays)&&(mounted=this._tree.prop(NodeProp.mounted))&&mounted.overlay){let rPos=pos-this.from;for(let{from:from,to:to}of mounted.overlay)if((side>0?from<=rPos:from<rPos)&&(side<0?to>=rPos:to>rPos))return new TreeNode(mounted.tree,mounted.overlay[0].from+this.from,-1,this)}return this.nextChild(0,1,pos,side,mode)}nextSignificantParent(){let val=this;for(;val.type.isAnonymous&&val._parent;)val=val._parent;return val}get parent(){return this._parent?this._parent.nextSignificantParent():null}get nextSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index+1,1,0,4):null}get prevSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index-1,-1,0,4):null}cursor(mode=0){return new TreeCursor(this,mode)}get tree(){return this._tree}toTree(){return this._tree}resolve(pos,side=0){return resolveNode(this,pos,side,!1)}resolveInner(pos,side=0){return resolveNode(this,pos,side,!0)}enterUnfinishedNodesBefore(pos){return enterUnfinishedNodesBefore(this,pos)}getChild(type,before=null,after=null){let r=getChildren(this,type,before,after);return r.length?r[0]:null}getChildren(type,before=null,after=null){return getChildren(this,type,before,after)}toString(){return this._tree.toString()}get node(){return this}matchContext(context){return matchNodeContext(this,context)}}function getChildren(node,type,before,after){let cur=node.cursor(),result=[];if(!cur.firstChild())return result;if(null!=before)for(;!cur.type.is(before);)if(!cur.nextSibling())return result;for(;;){if(null!=after&&cur.type.is(after))return result;if(cur.type.is(type)&&result.push(cur.node),!cur.nextSibling())return null==after?result:[]}}function matchNodeContext(node,context,i=context.length-1){for(let p=node.parent;i>=0;p=p.parent){if(!p)return!1;if(!p.type.isAnonymous){if(context[i]&&context[i]!=p.name)return!1;i--}}return!0}class BufferContext{constructor(parent,buffer,index,start){this.parent=parent,this.buffer=buffer,this.index=index,this.start=start}}class BufferNode{get name(){return this.type.name}get from(){return this.context.start+this.context.buffer.buffer[this.index+1]}get to(){return this.context.start+this.context.buffer.buffer[this.index+2]}constructor(context,_parent,index){this.context=context,this._parent=_parent,this.index=index,this.type=context.buffer.set.types[context.buffer.buffer[index]]}child(dir,pos,side){let{buffer:buffer}=this.context,index=buffer.findChild(this.index+4,buffer.buffer[this.index+3],dir,pos-this.context.start,side);return index<0?null:new BufferNode(this.context,this,index)}get firstChild(){return this.child(1,0,4)}get lastChild(){return this.child(-1,0,4)}childAfter(pos){return this.child(1,pos,2)}childBefore(pos){return this.child(-1,pos,-2)}enter(pos,side,mode=0){if(mode&exports.IterMode.ExcludeBuffers)return null;let{buffer:buffer}=this.context,index=buffer.findChild(this.index+4,buffer.buffer[this.index+3],side>0?1:-1,pos-this.context.start,side);return index<0?null:new BufferNode(this.context,this,index)}get parent(){return this._parent||this.context.parent.nextSignificantParent()}externalSibling(dir){return this._parent?null:this.context.parent.nextChild(this.context.index+dir,dir,0,4)}get nextSibling(){let{buffer:buffer}=this.context,after=buffer.buffer[this.index+3];return after<(this._parent?buffer.buffer[this._parent.index+3]:buffer.buffer.length)?new BufferNode(this.context,this._parent,after):this.externalSibling(1)}get prevSibling(){let{buffer:buffer}=this.context,parentStart=this._parent?this._parent.index+4:0;return this.index==parentStart?this.externalSibling(-1):new BufferNode(this.context,this._parent,buffer.findChild(parentStart,this.index,-1,0,4))}cursor(mode=0){return new TreeCursor(this,mode)}get tree(){return null}toTree(){let children=[],positions=[],{buffer:buffer}=this.context,startI=this.index+4,endI=buffer.buffer[this.index+3];if(endI>startI){let from=buffer.buffer[this.index+1];children.push(buffer.slice(startI,endI,from)),positions.push(0)}return new Tree(this.type,children,positions,this.to-this.from)}resolve(pos,side=0){return resolveNode(this,pos,side,!1)}resolveInner(pos,side=0){return resolveNode(this,pos,side,!0)}enterUnfinishedNodesBefore(pos){return enterUnfinishedNodesBefore(this,pos)}toString(){return this.context.buffer.childString(this.index)}getChild(type,before=null,after=null){let r=getChildren(this,type,before,after);return r.length?r[0]:null}getChildren(type,before=null,after=null){return getChildren(this,type,before,after)}get node(){return this}matchContext(context){return matchNodeContext(this,context)}}class TreeCursor{get name(){return this.type.name}constructor(node,mode=0){if(this.mode=mode,this.buffer=null,this.stack=[],this.index=0,this.bufferNode=null,node instanceof TreeNode)this.yieldNode(node);else{this._tree=node.context.parent,this.buffer=node.context;for(let n=node._parent;n;n=n._parent)this.stack.unshift(n.index);this.bufferNode=node,this.yieldBuf(node.index)}}yieldNode(node){return!!node&&(this._tree=node,this.type=node.type,this.from=node.from,this.to=node.to,!0)}yieldBuf(index,type){this.index=index;let{start:start,buffer:buffer}=this.buffer;return this.type=type||buffer.set.types[buffer.buffer[index]],this.from=start+buffer.buffer[index+1],this.to=start+buffer.buffer[index+2],!0}yield(node){return!!node&&(node instanceof TreeNode?(this.buffer=null,this.yieldNode(node)):(this.buffer=node.context,this.yieldBuf(node.index,node.type)))}toString(){return this.buffer?this.buffer.buffer.childString(this.index):this._tree.toString()}enterChild(dir,pos,side){if(!this.buffer)return this.yield(this._tree.nextChild(dir<0?this._tree._tree.children.length-1:0,dir,pos,side,this.mode));let{buffer:buffer}=this.buffer,index=buffer.findChild(this.index+4,buffer.buffer[this.index+3],dir,pos-this.buffer.start,side);return!(index<0)&&(this.stack.push(this.index),this.yieldBuf(index))}firstChild(){return this.enterChild(1,0,4)}lastChild(){return this.enterChild(-1,0,4)}childAfter(pos){return this.enterChild(1,pos,2)}childBefore(pos){return this.enterChild(-1,pos,-2)}enter(pos,side,mode=this.mode){return this.buffer?!(mode&exports.IterMode.ExcludeBuffers)&&this.enterChild(1,pos,side):this.yield(this._tree.enter(pos,side,mode))}parent(){if(!this.buffer)return this.yieldNode(this.mode&exports.IterMode.IncludeAnonymous?this._tree._parent:this._tree.parent);if(this.stack.length)return this.yieldBuf(this.stack.pop());let parent=this.mode&exports.IterMode.IncludeAnonymous?this.buffer.parent:this.buffer.parent.nextSignificantParent();return this.buffer=null,this.yieldNode(parent)}sibling(dir){if(!this.buffer)return!!this._tree._parent&&this.yield(this._tree.index<0?null:this._tree._parent.nextChild(this._tree.index+dir,dir,0,4,this.mode));let{buffer:buffer}=this.buffer,d=this.stack.length-1;if(dir<0){let parentStart=d<0?0:this.stack[d]+4;if(this.index!=parentStart)return this.yieldBuf(buffer.findChild(parentStart,this.index,-1,0,4))}else{let after=buffer.buffer[this.index+3];if(after<(d<0?buffer.buffer.length:buffer.buffer[this.stack[d]+3]))return this.yieldBuf(after)}return d<0&&this.yield(this.buffer.parent.nextChild(this.buffer.index+dir,dir,0,4,this.mode))}nextSibling(){return this.sibling(1)}prevSibling(){return this.sibling(-1)}atLastNode(dir){let index,parent,{buffer:buffer}=this;if(buffer){if(dir>0){if(this.index<buffer.buffer.buffer.length)return!1}else for(let i=0;i<this.index;i++)if(buffer.buffer.buffer[i+3]<this.index)return!1;({index:index,parent:parent}=buffer)}else({index:index,_parent:parent}=this._tree);for(;parent;({index:index,_parent:parent}=parent))if(index>-1)for(let i=index+dir,e=dir<0?-1:parent._tree.children.length;i!=e;i+=dir){let child=parent._tree.children[i];if(this.mode&exports.IterMode.IncludeAnonymous||child instanceof TreeBuffer||!child.type.isAnonymous||hasChild(child))return!1}return!0}move(dir,enter){if(enter&&this.enterChild(dir,0,4))return!0;for(;;){if(this.sibling(dir))return!0;if(this.atLastNode(dir)||!this.parent())return!1}}next(enter=!0){return this.move(1,enter)}prev(enter=!0){return this.move(-1,enter)}moveTo(pos,side=0){for(;(this.from==this.to||(side<1?this.from>=pos:this.from>pos)||(side>-1?this.to<=pos:this.to<pos))&&this.parent(););for(;this.enterChild(1,pos,side););return this}get node(){if(!this.buffer)return this._tree;let cache=this.bufferNode,result=null,depth=0;if(cache&&cache.context==this.buffer)scan:for(let index=this.index,d=this.stack.length;d>=0;){for(let c=cache;c;c=c._parent)if(c.index==index){if(index==this.index)return c;result=c,depth=d+1;break scan}index=this.stack[--d]}for(let i=depth;i<this.stack.length;i++)result=new BufferNode(this.buffer,result,this.stack[i]);return this.bufferNode=new BufferNode(this.buffer,result,this.index)}get tree(){return this.buffer?null:this._tree._tree}iterate(enter,leave){for(let depth=0;;){let mustLeave=!1;if(this.type.isAnonymous||!1!==enter(this)){if(this.firstChild()){depth++;continue}this.type.isAnonymous||(mustLeave=!0)}for(;mustLeave&&leave&&leave(this),mustLeave=this.type.isAnonymous,!this.nextSibling();){if(!depth)return;this.parent(),depth--,mustLeave=!0}}}matchContext(context){if(!this.buffer)return matchNodeContext(this.node,context);let{buffer:buffer}=this.buffer,{types:types}=buffer.set;for(let i=context.length-1,d=this.stack.length-1;i>=0;d--){if(d<0)return matchNodeContext(this.node,context,i);let type=types[buffer.buffer[this.stack[d]]];if(!type.isAnonymous){if(context[i]&&context[i]!=type.name)return!1;i--}}return!0}}function hasChild(tree){return tree.children.some((ch=>ch instanceof TreeBuffer||!ch.type.isAnonymous||hasChild(ch)))}const nodeSizeCache=new WeakMap;function nodeSize(balanceType,node){if(!balanceType.isAnonymous||node instanceof TreeBuffer||node.type!=balanceType)return 1;let size=nodeSizeCache.get(node);if(null==size){size=1;for(let child of node.children){if(child.type!=balanceType||!(child instanceof Tree)){size=1;break}size+=nodeSize(balanceType,child)}nodeSizeCache.set(node,size)}return size}function balanceRange(balanceType,children,positions,from,to,start,length,mkTop,mkTree){let total=0;for(let i=from;i<to;i++)total+=nodeSize(balanceType,children[i]);let maxChild=Math.ceil(1.5*total/8),localChildren=[],localPositions=[];return function divide(children,positions,from,to,offset){for(let i=from;i<to;){let groupFrom=i,groupStart=positions[i],groupSize=nodeSize(balanceType,children[i]);for(i++;i<to;i++){let nextSize=nodeSize(balanceType,children[i]);if(groupSize+nextSize>=maxChild)break;groupSize+=nextSize}if(i==groupFrom+1){if(groupSize>maxChild){let only=children[groupFrom];divide(only.children,only.positions,0,only.children.length,positions[groupFrom]+offset);continue}localChildren.push(children[groupFrom])}else{let length=positions[i-1]+children[i-1].length-groupStart;localChildren.push(balanceRange(balanceType,children,positions,groupFrom,i,groupStart,length,null,mkTree))}localPositions.push(groupStart+offset-start)}}(children,positions,from,to,0),(mkTop||mkTree)(localChildren,localPositions,length)}class TreeFragment{constructor(from,to,tree,offset,openStart=!1,openEnd=!1){this.from=from,this.to=to,this.tree=tree,this.offset=offset,this.open=(openStart?1:0)|(openEnd?2:0)}get openStart(){return(1&this.open)>0}get openEnd(){return(2&this.open)>0}static addTree(tree,fragments=[],partial=!1){let result=[new TreeFragment(0,tree.length,tree,0,!1,partial)];for(let f of fragments)f.to>tree.length&&result.push(f);return result}static applyChanges(fragments,changes,minGap=128){if(!changes.length)return fragments;let result=[],fI=1,nextF=fragments.length?fragments[0]:null;for(let cI=0,pos=0,off=0;;cI++){let nextC=cI<changes.length?changes[cI]:null,nextPos=nextC?nextC.fromA:1e9;if(nextPos-pos>=minGap)for(;nextF&&nextF.from<nextPos;){let cut=nextF;if(pos>=cut.from||nextPos<=cut.to||off){let fFrom=Math.max(cut.from,pos)-off,fTo=Math.min(cut.to,nextPos)-off;cut=fFrom>=fTo?null:new TreeFragment(fFrom,fTo,cut.tree,cut.offset+off,cI>0,!!nextC)}if(cut&&result.push(cut),nextF.to>nextPos)break;nextF=fI<fragments.length?fragments[fI++]:null}if(!nextC)break;pos=nextC.toA,off=nextC.toA-nextC.toB}return result}}class StringInput{constructor(string){this.string=string}get length(){return this.string.length}chunk(from){return this.string.slice(from)}get lineChunks(){return!1}read(from,to){return this.string.slice(from,to)}}class InnerParse{constructor(parser,parse,overlay,target,ranges){this.parser=parser,this.parse=parse,this.overlay=overlay,this.target=target,this.ranges=ranges}}class ActiveOverlay{constructor(parser,predicate,mounts,index,start,target,prev){this.parser=parser,this.predicate=predicate,this.mounts=mounts,this.index=index,this.start=start,this.target=target,this.prev=prev,this.depth=0,this.ranges=[]}}const stoppedInner=new NodeProp({perNode:!0});class MixedParse{constructor(base,nest,input,fragments,ranges){this.nest=nest,this.input=input,this.fragments=fragments,this.ranges=ranges,this.inner=[],this.innerDone=0,this.baseTree=null,this.stoppedAt=null,this.baseParse=base}advance(){if(this.baseParse){let done=this.baseParse.advance();if(!done)return null;if(this.baseParse=null,this.baseTree=done,this.startInner(),null!=this.stoppedAt)for(let inner of this.inner)inner.parse.stopAt(this.stoppedAt)}if(this.innerDone==this.inner.length){let result=this.baseTree;return null!=this.stoppedAt&&(result=new Tree(result.type,result.children,result.positions,result.length,result.propValues.concat([[stoppedInner,this.stoppedAt]]))),result}let inner=this.inner[this.innerDone],done=inner.parse.advance();if(done){this.innerDone++;let props=Object.assign(Object.create(null),inner.target.props);props[NodeProp.mounted.id]=new MountedTree(done,inner.overlay,inner.parser),inner.target.props=props}return null}get parsedPos(){if(this.baseParse)return 0;let pos=this.input.length;for(let i=this.innerDone;i<this.inner.length;i++)this.inner[i].ranges[0].from<pos&&(pos=Math.min(pos,this.inner[i].parse.parsedPos));return pos}stopAt(pos){if(this.stoppedAt=pos,this.baseParse)this.baseParse.stopAt(pos);else for(let i=this.innerDone;i<this.inner.length;i++)this.inner[i].parse.stopAt(pos)}startInner(){let fragmentCursor=new FragmentCursor(this.fragments),overlay=null,covered=null,cursor=new TreeCursor(new TreeNode(this.baseTree,this.ranges[0].from,0,null),exports.IterMode.IncludeAnonymous|exports.IterMode.IgnoreMounts);scan:for(let nest,isCovered;null==this.stoppedAt||cursor.from<this.stoppedAt;){let range,enter=!0;if(fragmentCursor.hasNode(cursor)){if(overlay){let match=overlay.mounts.find((m=>m.frag.from<=cursor.from&&m.frag.to>=cursor.to&&m.mount.overlay));if(match)for(let r of match.mount.overlay){let from=r.from+match.pos,to=r.to+match.pos;from>=cursor.from&&to<=cursor.to&&!overlay.ranges.some((r=>r.from<to&&r.to>from))&&overlay.ranges.push({from:from,to:to})}}enter=!1}else if(covered&&(isCovered=checkCover(covered.ranges,cursor.from,cursor.to)))enter=2!=isCovered;else if(!cursor.type.isAnonymous&&cursor.from<cursor.to&&(nest=this.nest(cursor,this.input))){cursor.tree||materialize(cursor);let oldMounts=fragmentCursor.findMounts(cursor.from,nest.parser);if("function"==typeof nest.overlay)overlay=new ActiveOverlay(nest.parser,nest.overlay,oldMounts,this.inner.length,cursor.from,cursor.tree,overlay);else{let ranges=punchRanges(this.ranges,nest.overlay||[new Range(cursor.from,cursor.to)]);ranges.length&&this.inner.push(new InnerParse(nest.parser,nest.parser.startParse(this.input,enterFragments(oldMounts,ranges),ranges),nest.overlay?nest.overlay.map((r=>new Range(r.from-cursor.from,r.to-cursor.from))):null,cursor.tree,ranges)),nest.overlay?ranges.length&&(covered={ranges:ranges,depth:0,prev:covered}):enter=!1}}else overlay&&(range=overlay.predicate(cursor))&&(!0===range&&(range=new Range(cursor.from,cursor.to)),range.from<range.to&&overlay.ranges.push(range));if(enter&&cursor.firstChild())overlay&&overlay.depth++,covered&&covered.depth++;else for(;!cursor.nextSibling();){if(!cursor.parent())break scan;if(overlay&&!--overlay.depth){let ranges=punchRanges(this.ranges,overlay.ranges);ranges.length&&this.inner.splice(overlay.index,0,new InnerParse(overlay.parser,overlay.parser.startParse(this.input,enterFragments(overlay.mounts,ranges),ranges),overlay.ranges.map((r=>new Range(r.from-overlay.start,r.to-overlay.start))),overlay.target,ranges)),overlay=overlay.prev}covered&&!--covered.depth&&(covered=covered.prev)}}}}function checkCover(covered,from,to){for(let range of covered){if(range.from>=to)break;if(range.to>from)return range.from<=from&&range.to>=to?2:1}return 0}function sliceBuf(buf,startI,endI,nodes,positions,off){if(startI<endI){let from=buf.buffer[startI+1];nodes.push(buf.slice(startI,endI,from)),positions.push(from-off)}}function materialize(cursor){let{node:node}=cursor,depth=0;do{cursor.parent(),depth++}while(!cursor.tree);let i=0,base=cursor.tree,off=0;for(;off=base.positions[i]+cursor.from,!(off<=node.from&&off+base.children[i].length>=node.to);i++);let buf=base.children[i],b=buf.buffer;base.children[i]=function split(startI,endI,type,innerOffset,length){let i=startI;for(;b[i+2]+off<=node.from;)i=b[i+3];let children=[],positions=[];sliceBuf(buf,startI,i,children,positions,innerOffset);let from=b[i+1],to=b[i+2],isTarget=from+off==node.from&&to+off==node.to&&b[i]==node.type.id;return children.push(isTarget?node.toTree():split(i+4,b[i+3],buf.set.types[b[i]],from,to-from)),positions.push(from-innerOffset),sliceBuf(buf,b[i+3],endI,children,positions,innerOffset),new Tree(type,children,positions,length)}(0,b.length,NodeType.none,0,buf.length);for(let d=0;d<=depth;d++)cursor.childAfter(node.from)}class StructureCursor{constructor(root,offset){this.offset=offset,this.done=!1,this.cursor=root.cursor(exports.IterMode.IncludeAnonymous|exports.IterMode.IgnoreMounts)}moveTo(pos){let{cursor:cursor}=this,p=pos-this.offset;for(;!this.done&&cursor.from<p;)cursor.to>=pos&&cursor.enter(p,1,exports.IterMode.IgnoreOverlays|exports.IterMode.ExcludeBuffers)||cursor.next(!1)||(this.done=!0)}hasNode(cursor){if(this.moveTo(cursor.from),!this.done&&this.cursor.from+this.offset==cursor.from&&this.cursor.tree)for(let tree=this.cursor.tree;;){if(tree==cursor.tree)return!0;if(!(tree.children.length&&0==tree.positions[0]&&tree.children[0]instanceof Tree))break;tree=tree.children[0]}return!1}}class FragmentCursor{constructor(fragments){var _a;if(this.fragments=fragments,this.curTo=0,this.fragI=0,fragments.length){let first=this.curFrag=fragments[0];this.curTo=null!==(_a=first.tree.prop(stoppedInner))&&void 0!==_a?_a:first.to,this.inner=new StructureCursor(first.tree,-first.offset)}else this.curFrag=this.inner=null}hasNode(node){for(;this.curFrag&&node.from>=this.curTo;)this.nextFrag();return this.curFrag&&this.curFrag.from<=node.from&&this.curTo>=node.to&&this.inner.hasNode(node)}nextFrag(){var _a;if(this.fragI++,this.fragI==this.fragments.length)this.curFrag=this.inner=null;else{let frag=this.curFrag=this.fragments[this.fragI];this.curTo=null!==(_a=frag.tree.prop(stoppedInner))&&void 0!==_a?_a:frag.to,this.inner=new StructureCursor(frag.tree,-frag.offset)}}findMounts(pos,parser){var _a;let result=[];if(this.inner){this.inner.cursor.moveTo(pos,1);for(let pos=this.inner.cursor.node;pos;pos=pos.parent){let mount=null===(_a=pos.tree)||void 0===_a?void 0:_a.prop(NodeProp.mounted);if(mount&&mount.parser==parser)for(let i=this.fragI;i<this.fragments.length;i++){let frag=this.fragments[i];if(frag.from>=pos.to)break;frag.tree==this.curFrag.tree&&result.push({frag:frag,pos:pos.from-frag.offset,mount:mount})}}}return result}}function punchRanges(outer,ranges){let copy=null,current=ranges;for(let i=1,j=0;i<outer.length;i++){let gapFrom=outer[i-1].to,gapTo=outer[i].from;for(;j<current.length;j++){let r=current[j];if(r.from>=gapTo)break;r.to<=gapFrom||(copy||(current=copy=ranges.slice()),r.from<gapFrom?(copy[j]=new Range(r.from,gapFrom),r.to>gapTo&&copy.splice(j+1,0,new Range(gapTo,r.to))):r.to>gapTo?copy[j--]=new Range(gapTo,r.to):copy.splice(j--,1))}}return current}function findCoverChanges(a,b,from,to){let iA=0,iB=0,inA=!1,inB=!1,pos=-1e9,result=[];for(;;){let nextA=iA==a.length?1e9:inA?a[iA].to:a[iA].from,nextB=iB==b.length?1e9:inB?b[iB].to:b[iB].from;if(inA!=inB){let start=Math.max(pos,from),end=Math.min(nextA,nextB,to);start<end&&result.push(new Range(start,end))}if(pos=Math.min(nextA,nextB),1e9==pos)break;nextA==pos&&(inA?(inA=!1,iA++):inA=!0),nextB==pos&&(inB?(inB=!1,iB++):inB=!0)}return result}function enterFragments(mounts,ranges){let result=[];for(let{pos:pos,mount:mount,frag:frag}of mounts){let startPos=pos+(mount.overlay?mount.overlay[0].from:0),endPos=startPos+mount.tree.length,from=Math.max(frag.from,startPos),to=Math.min(frag.to,endPos);if(mount.overlay){let changes=findCoverChanges(ranges,mount.overlay.map((r=>new Range(r.from+pos,r.to+pos))),from,to);for(let i=0,pos=from;;i++){let last=i==changes.length,end=last?to:changes[i].from;if(end>pos&&result.push(new TreeFragment(pos,end,mount.tree,-startPos,frag.from>=pos||frag.openStart,frag.to<=end||frag.openEnd)),last)break;pos=changes[i].to}}else result.push(new TreeFragment(from,to,mount.tree,-startPos,frag.from>=startPos||frag.openStart,frag.to<=endPos||frag.openEnd))}return result}exports.DefaultBufferLength=DefaultBufferLength,exports.MountedTree=MountedTree,exports.NodeProp=NodeProp,exports.NodeSet=NodeSet,exports.NodeType=NodeType,exports.NodeWeakMap=class{constructor(){this.map=new WeakMap}setBuffer(buffer,index,value){let inner=this.map.get(buffer);inner||this.map.set(buffer,inner=new Map),inner.set(index,value)}getBuffer(buffer,index){let inner=this.map.get(buffer);return inner&&inner.get(index)}set(node,value){node instanceof BufferNode?this.setBuffer(node.context.buffer,node.index,value):node instanceof TreeNode&&this.map.set(node.tree,value)}get(node){return node instanceof BufferNode?this.getBuffer(node.context.buffer,node.index):node instanceof TreeNode?this.map.get(node.tree):void 0}cursorSet(cursor,value){cursor.buffer?this.setBuffer(cursor.buffer.buffer,cursor.index,value):this.map.set(cursor.tree,value)}cursorGet(cursor){return cursor.buffer?this.getBuffer(cursor.buffer.buffer,cursor.index):this.map.get(cursor.tree)}},exports.Parser=class{startParse(input,fragments,ranges){return"string"==typeof input&&(input=new StringInput(input)),ranges=ranges?ranges.length?ranges.map((r=>new Range(r.from,r.to))):[new Range(0,0)]:[new Range(0,input.length)],this.createParse(input,fragments||[],ranges)}parse(input,fragments,ranges){let parse=this.startParse(input,fragments,ranges);for(;;){let done=parse.advance();if(done)return done}}},exports.Tree=Tree,exports.TreeBuffer=TreeBuffer,exports.TreeCursor=TreeCursor,exports.TreeFragment=TreeFragment,exports.parseMixed=function(nest){return(parse,input,fragments,ranges)=>new MixedParse(parse,nest,input,fragments,ranges)}},{}],14:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var common=require("@lezer/common");let nextTagID=0;class Tag{constructor(set,base,modified){this.set=set,this.base=base,this.modified=modified,this.id=nextTagID++}static define(parent){if(null==parent?void 0:parent.base)throw new Error("Can not derive from a modified tag");let tag=new Tag([],null,[]);if(tag.set.push(tag),parent)for(let t of parent.set)tag.set.push(t);return tag}static defineModifier(){let mod=new Modifier;return tag=>tag.modified.indexOf(mod)>-1?tag:Modifier.get(tag.base||tag,tag.modified.concat(mod).sort(((a,b)=>a.id-b.id)))}}let nextModifierID=0;class Modifier{constructor(){this.instances=[],this.id=nextModifierID++}static get(base,mods){if(!mods.length)return base;let exists=mods[0].instances.find((t=>{return t.base==base&&(a=mods,b=t.modified,a.length==b.length&&a.every(((x,i)=>x==b[i])));var a,b}));if(exists)return exists;let set=[],tag=new Tag(set,base,mods);for(let m of mods)m.instances.push(tag);let configs=function(array){let sets=[[]];for(let i=0;i<array.length;i++)for(let j=0,e=sets.length;j<e;j++)sets.push(sets[j].concat(array[i]));return sets.sort(((a,b)=>b.length-a.length))}(mods);for(let parent of base.set)if(!parent.modified.length)for(let config of configs)set.push(Modifier.get(parent,config));return tag}}const ruleNodeProp=new common.NodeProp;class Rule{constructor(tags,mode,context,next){this.tags=tags,this.mode=mode,this.context=context,this.next=next}get opaque(){return 0==this.mode}get inherit(){return 1==this.mode}sort(other){return!other||other.depth<this.depth?(this.next=other,this):(other.next=this.sort(other.next),other)}get depth(){return this.context?this.context.length:0}}function tagHighlighter(tags,options){let map=Object.create(null);for(let style of tags)if(Array.isArray(style.tag))for(let tag of style.tag)map[tag.id]=style.class;else map[style.tag.id]=style.class;let{scope:scope,all:all=null}=options||{};return{style:tags=>{let cls=all;for(let tag of tags)for(let sub of tag.set){let tagClass=map[sub.id];if(tagClass){cls=cls?cls+" "+tagClass:tagClass;break}}return cls},scope:scope}}Rule.empty=new Rule([],2,null);class HighlightBuilder{constructor(at,highlighters,span){this.at=at,this.highlighters=highlighters,this.span=span,this.class=""}startSpan(at,cls){cls!=this.class&&(this.flush(at),at>this.at&&(this.at=at),this.class=cls)}flush(to){to>this.at&&this.class&&this.span(this.at,to,this.class)}highlightRange(cursor,from,to,inheritedClass,highlighters){let{type:type,from:start,to:end}=cursor;if(start>=to||end<=from)return;type.isTop&&(highlighters=this.highlighters.filter((h=>!h.scope||h.scope(type))));let cls=inheritedClass,rule=getStyleTags(cursor)||Rule.empty,tagCls=function(highlighters,tags){let result=null;for(let highlighter of highlighters){let value=highlighter.style(tags);value&&(result=result?result+" "+value:value)}return result}(highlighters,rule.tags);if(tagCls&&(cls&&(cls+=" "),cls+=tagCls,1==rule.mode&&(inheritedClass+=(inheritedClass?" ":"")+tagCls)),this.startSpan(cursor.from,cls),rule.opaque)return;let mounted=cursor.tree&&cursor.tree.prop(common.NodeProp.mounted);if(mounted&&mounted.overlay){let inner=cursor.node.enter(mounted.overlay[0].from+start,1),innerHighlighters=this.highlighters.filter((h=>!h.scope||h.scope(mounted.tree.type))),hasChild=cursor.firstChild();for(let i=0,pos=start;;i++){let next=i<mounted.overlay.length?mounted.overlay[i]:null,nextPos=next?next.from+start:end,rangeFrom=Math.max(from,pos),rangeTo=Math.min(to,nextPos);if(rangeFrom<rangeTo&&hasChild)for(;cursor.from<rangeTo&&(this.highlightRange(cursor,rangeFrom,rangeTo,inheritedClass,highlighters),this.startSpan(Math.min(rangeTo,cursor.to),cls),!(cursor.to>=nextPos)&&cursor.nextSibling()););if(!next||nextPos>to)break;pos=next.to+start,pos>from&&(this.highlightRange(inner.cursor(),Math.max(from,next.from+start),Math.min(to,pos),inheritedClass,innerHighlighters),this.startSpan(pos,cls))}hasChild&&cursor.parent()}else if(cursor.firstChild()){do{if(!(cursor.to<=from)){if(cursor.from>=to)break;this.highlightRange(cursor,from,to,inheritedClass,highlighters),this.startSpan(Math.min(to,cursor.to),cls)}}while(cursor.nextSibling());cursor.parent()}}}function getStyleTags(node){let rule=node.type.prop(ruleNodeProp);for(;rule&&rule.context&&!node.matchContext(rule.context);)rule=rule.next;return rule||null}const t=Tag.define,comment=t(),name=t(),typeName=t(name),propertyName=t(name),literal=t(),string=t(literal),number=t(literal),content=t(),heading=t(content),keyword=t(),operator=t(),punctuation=t(),bracket=t(punctuation),meta=t(),tags={comment:comment,lineComment:t(comment),blockComment:t(comment),docComment:t(comment),name:name,variableName:t(name),typeName:typeName,tagName:t(typeName),propertyName:propertyName,attributeName:t(propertyName),className:t(name),labelName:t(name),namespace:t(name),macroName:t(name),literal:literal,string:string,docString:t(string),character:t(string),attributeValue:t(string),number:number,integer:t(number),float:t(number),bool:t(literal),regexp:t(literal),escape:t(literal),color:t(literal),url:t(literal),keyword:keyword,self:t(keyword),null:t(keyword),atom:t(keyword),unit:t(keyword),modifier:t(keyword),operatorKeyword:t(keyword),controlKeyword:t(keyword),definitionKeyword:t(keyword),moduleKeyword:t(keyword),operator:operator,derefOperator:t(operator),arithmeticOperator:t(operator),logicOperator:t(operator),bitwiseOperator:t(operator),compareOperator:t(operator),updateOperator:t(operator),definitionOperator:t(operator),typeOperator:t(operator),controlOperator:t(operator),punctuation:punctuation,separator:t(punctuation),bracket:bracket,angleBracket:t(bracket),squareBracket:t(bracket),paren:t(bracket),brace:t(bracket),content:content,heading:heading,heading1:t(heading),heading2:t(heading),heading3:t(heading),heading4:t(heading),heading5:t(heading),heading6:t(heading),contentSeparator:t(content),list:t(content),quote:t(content),emphasis:t(content),strong:t(content),link:t(content),monospace:t(content),strikethrough:t(content),inserted:t(),deleted:t(),changed:t(),invalid:t(),meta:meta,documentMeta:t(meta),annotation:t(meta),processingInstruction:t(meta),definition:Tag.defineModifier(),constant:Tag.defineModifier(),function:Tag.defineModifier(),standard:Tag.defineModifier(),local:Tag.defineModifier(),special:Tag.defineModifier()},classHighlighter=tagHighlighter([{tag:tags.link,class:"tok-link"},{tag:tags.heading,class:"tok-heading"},{tag:tags.emphasis,class:"tok-emphasis"},{tag:tags.strong,class:"tok-strong"},{tag:tags.keyword,class:"tok-keyword"},{tag:tags.atom,class:"tok-atom"},{tag:tags.bool,class:"tok-bool"},{tag:tags.url,class:"tok-url"},{tag:tags.labelName,class:"tok-labelName"},{tag:tags.inserted,class:"tok-inserted"},{tag:tags.deleted,class:"tok-deleted"},{tag:tags.literal,class:"tok-literal"},{tag:tags.string,class:"tok-string"},{tag:tags.number,class:"tok-number"},{tag:[tags.regexp,tags.escape,tags.special(tags.string)],class:"tok-string2"},{tag:tags.variableName,class:"tok-variableName"},{tag:tags.local(tags.variableName),class:"tok-variableName tok-local"},{tag:tags.definition(tags.variableName),class:"tok-variableName tok-definition"},{tag:tags.special(tags.variableName),class:"tok-variableName2"},{tag:tags.definition(tags.propertyName),class:"tok-propertyName tok-definition"},{tag:tags.typeName,class:"tok-typeName"},{tag:tags.namespace,class:"tok-namespace"},{tag:tags.className,class:"tok-className"},{tag:tags.macroName,class:"tok-macroName"},{tag:tags.propertyName,class:"tok-propertyName"},{tag:tags.operator,class:"tok-operator"},{tag:tags.comment,class:"tok-comment"},{tag:tags.meta,class:"tok-meta"},{tag:tags.invalid,class:"tok-invalid"},{tag:tags.punctuation,class:"tok-punctuation"}]);exports.Tag=Tag,exports.classHighlighter=classHighlighter,exports.getStyleTags=getStyleTags,exports.highlightTree=function(tree,highlighter,putStyle,from=0,to=tree.length){let builder=new HighlightBuilder(from,Array.isArray(highlighter)?highlighter:[highlighter],putStyle);builder.highlightRange(tree.cursor(),from,to,"",builder.highlighters),builder.flush(to)},exports.styleTags=function(spec){let byName=Object.create(null);for(let prop in spec){let tags=spec[prop];Array.isArray(tags)||(tags=[tags]);for(let part of prop.split(" "))if(part){let pieces=[],mode=2,rest=part;for(let pos=0;;){if("..."==rest&&pos>0&&pos+3==part.length){mode=1;break}let m=/^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);if(!m)throw new RangeError("Invalid path: "+part);if(pieces.push("*"==m[0]?"":'"'==m[0][0]?JSON.parse(m[0]):m[0]),pos+=m[0].length,pos==part.length)break;let next=part[pos++];if(pos==part.length&&"!"==next){mode=0;break}if("/"!=next)throw new RangeError("Invalid path: "+part);rest=part.slice(pos)}let last=pieces.length-1,inner=pieces[last];if(!inner)throw new RangeError("Invalid path: "+part);let rule=new Rule(tags,mode,last>0?pieces.slice(0,last):null);byName[inner]=rule.sort(byName[inner])}}return ruleNodeProp.add(byName)},exports.tagHighlighter=tagHighlighter,exports.tags=tags},{"@lezer/common":13}],15:[function(require,module,exports){"use strict";const stringify=require("./stringify.js");module.exports=root=>{const content="string"==typeof root?document.getElementById(root):root;return ml=>{let str;try{str=stringify(ml),content.innerHTML=str}catch(err){console.log(ml)}}}},{"./stringify.js":16}],16:[function(require,module,exports){"use strict";module.exports=function(a,indentation){const cr=indentation>0?"\n":"",indent=function(indentation){if(!(indentation>0))return txt=>txt;var space=" ".repeat(indentation);return txt=>{if("string"!=typeof txt)return txt;const arr=txt.split("\n");return 1===arr.length?space+txt:arr.map((e=>""===e.trim()?e:space+e)).join("\n")}}(indentation);return function rec(a){let res,body="",isFlat=!0;return a.some(((e,i,arr)=>{if(0===i)return res="<"+e,1===arr.length;if(1===i){if((o=e)&&"[object Object]"===Object.prototype.toString.call(o))return Object.keys(e).map((key=>{let val=e[key];Array.isArray(val)&&(val=val.join(" ")),res+=" "+key+'="'+val+'"'})),2===arr.length||void(res+=">");res+=">"}var o;switch(typeof e){case"string":case"number":case"boolean":case"undefined":return void(body+=e+cr)}isFlat=!1,body+=rec(e)}))?res+"/>"+cr:isFlat?res+body.split("\n").filter((e=>""!==e.trim())).join("\n")+"</"+a[0]+">"+cr:res+cr+indent(body)+"</"+a[0]+">"+cr}(a)}},{}],17:[function(require,module,exports){var COUNT="undefined"==typeof Symbol?"__":Symbol.for(""),SET="undefined"==typeof Symbol?"__styleSet"+Math.floor(1e8*Math.random()):Symbol("styleSet"),top="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:{},StyleModule=exports.StyleModule=function(spec,options){this.rules=[];var finish=(options||{}).finish;function splitSelector(selector){return/^@/.test(selector)?[selector]:selector.split(/,\s*/)}function render(selectors,spec,target,isKeyframes){var local=[],isAt=/^@(\w+)\b/.exec(selectors[0]),keyframes=isAt&&"keyframes"==isAt[1];if(isAt&&null==spec)return target.push(selectors[0]+";");for(var prop in spec){var value=spec[prop];if(/&/.test(prop))render(prop.split(/,\s*/).map((function(part){return selectors.map((function(sel){return part.replace(/&/,sel)}))})).reduce((function(a,b){return a.concat(b)})),value,target);else if(value&&"object"==typeof value){if(!isAt)throw new RangeError("The value of a property ("+prop+") should be a primitive value.");render(splitSelector(prop),value,local,keyframes)}else null!=value&&local.push(prop.replace(/_.*/,"").replace(/[A-Z]/g,(function(l){return"-"+l.toLowerCase()}))+": "+value+";")}(local.length||keyframes)&&target.push((!finish||isAt||isKeyframes?selectors:selectors.map(finish)).join(", ")+" {"+local.join(" ")+"}")}for(var prop in spec)render(splitSelector(prop),spec[prop],this.rules)};StyleModule.prototype.getRules=function(){return this.rules.join("\n")},StyleModule.newName=function(){var id=top[COUNT]||1;return top[COUNT]=id+1,""+id.toString(36)},StyleModule.mount=function(root,modules){(root[SET]||new StyleSet(root)).mount(Array.isArray(modules)?modules:[modules])};var adoptedSet=null,StyleSet=function(root){if(!root.head&&root.adoptedStyleSheets&&"undefined"!=typeof CSSStyleSheet){if(adoptedSet)return root.adoptedStyleSheets=[adoptedSet.sheet].concat(root.adoptedStyleSheets),root[SET]=adoptedSet;this.sheet=new CSSStyleSheet,root.adoptedStyleSheets=[this.sheet].concat(root.adoptedStyleSheets),adoptedSet=this}else{this.styleTag=(root.ownerDocument||root).createElement("style");var target=root.head||root;target.insertBefore(this.styleTag,target.firstChild)}this.modules=[],root[SET]=this};StyleSet.prototype.mount=function(modules){for(var sheet=this.sheet,pos=0,j=0,i=0;i<modules.length;i++){var mod=modules[i],index=this.modules.indexOf(mod);if(index<j&&index>-1&&(this.modules.splice(index,1),j--,index=-1),-1==index){if(this.modules.splice(j++,0,mod),sheet)for(var k=0;k<mod.rules.length;k++)sheet.insertRule(mod.rules[k],pos++)}else{for(;j<index;)pos+=this.modules[j++].rules.length;pos+=mod.rules.length,j++}}if(!sheet){for(var text="",i$1=0;i$1<this.modules.length;i$1++)text+=this.modules[i$1].getRules()+"\n";this.styleTag.textContent=text}}},{}],18:[function(require,module,exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});for(var base={8:"Backspace",9:"Tab",10:"Enter",12:"NumLock",13:"Enter",16:"Shift",17:"Control",18:"Alt",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",44:"PrintScreen",45:"Insert",46:"Delete",59:";",61:"=",91:"Meta",92:"Meta",106:"*",107:"+",108:",",109:"-",110:".",111:"/",144:"NumLock",145:"ScrollLock",160:"Shift",161:"Shift",162:"Control",163:"Control",164:"Alt",165:"Alt",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},shift={48:")",49:"!",50:"@",51:"#",52:"$",53:"%",54:"^",55:"&",56:"*",57:"(",59:":",61:"+",173:"_",186:":",187:"+",188:"<",189:"_",190:">",191:"?",192:"~",219:"{",220:"|",221:"}",222:'"'},chrome="undefined"!=typeof navigator&&/Chrome\/(\d+)/.exec(navigator.userAgent),mac=("undefined"!=typeof navigator&&/Gecko\/\d+/.test(navigator.userAgent),"undefined"!=typeof navigator&&/Mac/.test(navigator.platform)),ie="undefined"!=typeof navigator&&/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent),brokenModifierNames=mac||chrome&&+chrome[1]<57,i=0;i<10;i++)base[48+i]=base[96+i]=String(i);for(i=1;i<=24;i++)base[i+111]="F"+i;for(i=65;i<=90;i++)base[i]=String.fromCharCode(i+32),shift[i]=String.fromCharCode(i);for(var code in base)shift.hasOwnProperty(code)||(shift[code]=base[code]);exports.base=base,exports.keyName=function(event){var name=!(brokenModifierNames&&(event.ctrlKey||event.altKey||event.metaKey)||ie&&event.shiftKey&&event.key&&1==event.key.length||"Unidentified"==event.key)&&event.key||(event.shiftKey?shift:base)[event.keyCode]||event.key||"Unidentified";return"Esc"==name&&(name="Escape"),"Del"==name&&(name="Delete"),"Left"==name&&(name="ArrowLeft"),"Up"==name&&(name="ArrowUp"),"Right"==name&&(name="ArrowRight"),"Down"==name&&(name="ArrowDown"),name},exports.shift=shift},{}]},{},[1]);